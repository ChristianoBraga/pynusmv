\documentclass{article}
		
\usepackage{moreverb}
		
\title{Documentation}
\author{Auto-generated document}
		
\begin{document}
	\maketitle
			
	\tableofcontents
			
		
	\section{addons\_core}
		
	\section{compass}
		
	\section{compile}
		
	\subsection{ProbAssign.c}
		
	\texttt{ProbAssign\_ptr ProbAssign\_create(node\_ptr assigns, node\_ptr value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ProbAssign class constructor]

  Description        [The ProbAssign class constructor]

  SideEffects        []

  SeeAlso            [ProbAssign_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ProbAssign\_destroy(ProbAssign\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ProbAssign class destructor]

  Description        [The ProbAssign class destructor]

  SideEffects        []

  SeeAlso            [ProbAssign_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr ProbAssign\_get\_assigns\_expr(const ProbAssign\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Getters for the vars assignments]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr ProbAssign\_get\_prob(const ProbAssign\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getters for the probabilistic value]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void prob\_assign\_init(ProbAssign\_ptr self, node\_ptr assigns, node\_ptr value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ProbAssign class private initializer]

  Description        [The ProbAssign class private initializer]

  SideEffects        []

  SeeAlso            [ProbAssign_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void prob\_assign\_deinit(ProbAssign\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ProbAssign class private deinitializer]

  Description        [The ProbAssign class private deinitializer]

  SideEffects        []

  SeeAlso            [ProbAssign_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compile.c}
		
	\texttt{void Compass\_check\_prob\_list(TypeChecker\_ptr tc, NodeList\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks semantics of given probabilistic list]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compass\_check\_ap\_list(TypeChecker\_ptr tc, NodeList\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks semantics of given atomic proposition list]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr Compass\_process\_prob\_list(BddEnc\_ptr enc, NodeList\_ptr list, add\_ptr trans)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        [list is assumed to be already checked here. Returned add
  is referenced]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\section{parser}
		
	\section{ap}
		
	\subsection{ParserAp.c}
		
	\texttt{ParserAp\_ptr ParserAp\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserAp\_destroy(ParserAp\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserAp\_parse\_from\_file(ParserAp\_ptr self, FILE* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserAp\_parse\_from\_string(ParserAp\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr ParserAp\_get\_ap\_list(const ParserAp\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of ap read by the parser]

  Description        [Returned list is owned by self, and should not be 
  changed or destroyed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserAp\_reset(ParserAp\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void parser\_ap\_add(ParserAp\_ptr self, node\_ptr ap)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_ap\_mk\_ap(ParserAp\_ptr self, node\_ptr label, node\_ptr ap)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_ap\_init(ParserAp\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_ap\_deinit(ParserAp\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{prob}
		
	\subsection{ParserProb.c}
		
	\texttt{ParserProb\_ptr ParserProb\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserProb\_destroy(ParserProb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserProb\_parse\_from\_file(ParserProb\_ptr self, FILE* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserProb\_parse\_from\_string(ParserProb\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr ParserProb\_get\_prob\_list(const ParserProb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of prob read by the parser]

  Description        [Returned list is owned by self, and should not be 
  changed or destroyed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserProb\_reset(ParserProb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void parser\_prob\_add(ParserProb\_ptr self, node\_ptr prob)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_prob(ParserProb\_ptr self, node\_ptr assigns, node\_ptr prob)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_var\_assign(ParserProb\_ptr self, node\_ptr var, node\_ptr val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_var\_assigns(ParserProb\_ptr self, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_dot(ParserProb\_ptr self, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_array(ParserProb\_ptr self, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_atom(ParserProb\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_num(ParserProb\_ptr self, const int num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_true(ParserProb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_false(ParserProb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_prob\_mk\_real(ParserProb\_ptr self, const char* real\_text)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_prob\_init(ParserProb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_prob\_deinit(ParserProb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{sigref}
		
	\subsection{sigrefWrite.c}
		
	\texttt{void Compass\_write\_sigref(FILE* file, BddFsm\_ptr fsm, NodeList\_ptr probs\_list, /* can be NULL */ Expr\_ptr tau, /* can be NULL */ NodeList\_ptr ap\_list, /* can be NULL */ boolean do\_indent /* Beautify the XML output */ )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Compass\_write\_language\_sigref(BddEnc\_ptr enc, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis        [Handles the piece of sigref format regarding the language
(<variables> ... </variables>) ]

Description     [Returns 0 if successful, a negative number if an occurs]

SideEffects     []

SeeAlso         []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Compass\_print\_add\_sigref\_format(DdManager* dd, add\_ptr add, FILE* file, boolean do\_indent)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis        [Prints recursively an ADD node.
<dd_node ... </dd_node>]

Description     [Returns 0 if successful, a negative number if an occurs]

SideEffects     []

SeeAlso         []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compass\_print\_add\_child\_sigref(DdManager* dd, add\_ptr add, FILE* file, int indent, const char* child\_tag, hash\_ptr hash, boolean do\_indent)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis        [Private service to a node child, used by
print_add_sigref_format]

Description     [Returns 0 if successful, a negative number if an occurs]

SideEffects     []

SeeAlso         []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compassCmd.c}
		
	\texttt{void Compass\_init\_cmd()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the commands provided by this package]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCompassGenSigref(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  CommandName        []            

  CommandSynopsis    []  

  CommandArguments   []  

  CommandDescription []  

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compassPkg.c}
		
	\texttt{void Compass\_init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the addon]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compass\_reset(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reinitializes the addon]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compass\_quit(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deinitializes the addon]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{addonsCore.c}
		
	\texttt{void AddonsCore\_Init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initialization of the AddonsCore Sub-Packages]

  Description        [Initialization of the AddonsCore Sub-Packages]

  SideEffects        [Sub-Packages are initialized with possible side
  effects on some global variables (e.g., shell commands)]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void AddonsCore\_Reset(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reset the Addons core Sub-Packages]

  Description        [Reset the Addons core Sub-Packages]

  SideEffects        [Reset all the structures used by the Addons core 
  Sub-Packages]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void AddonsCore\_Quit(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Quit the Addons core Sub-Packages]

  Description        [Quit the Addons core Sub-Packages]

  SideEffects        [Quits all the structures used by the Addons core
  Sub-Packages]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\section{be}
		
	\subsection{beCnf.c}
		
	\texttt{Be\_Cnf\_ptr Be\_Cnf\_Create(const be\_ptr be)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Constructor for the Be_Cnf structure]

  Description [When the returned pointer is no longer used,
  call Be_Cnf_Delete]

  SideEffects []

  SeeAlso     [Be_Cnf_Delete]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_Cnf\_Delete(Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Be_Cnf structure destructor]

  Description []

  SideEffects []

  SeeAlso     [Be_Cnf_Create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_Cnf\_RemoveDuplicateLiterals(Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes any duplicate literal appearing in single clauses]

  Description [Removes any duplicate literal appearing in single clauses]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Cnf\_GetOriginalProblem(const Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the original BE problem this CNF was created from]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_Cnf\_GetFormulaLiteral(const Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the literal assigned to the whole formula.
  It may be negative. If the formula is a constant unspecified value is returned]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr Be\_Cnf\_GetVarsList(const Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the independent variables list in the CNF
  representation]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr Be\_Cnf\_GetClausesList(const Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a list of lists which contains the CNF-ed formula]

  Description [Each list in the list is a set of integers which
  represents a single clause. Any integer value depends on the variable
  name and the time which the variasble is considered in, whereas the
  integer sign is the variable polarity in the CNF-ed representation.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_Cnf\_GetMaxVarIndex(const Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the maximum variable index in the list of clauses]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{size\_t Be\_Cnf\_GetVarsNumber(const Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the number of independent variables in the given
  Be_Cnf structure]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{size\_t Be\_Cnf\_GetClausesNumber(const Be\_Cnf\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the number of clauses in the given Be_Cnf structure]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_Cnf\_SetFormulaLiteral(Be\_Cnf\_ptr self, const int formula\_literal)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the literal assigned to the whole formula]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_Cnf\_SetMaxVarIndex(Be\_Cnf\_ptr self, const int max\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the maximum variable index value]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_Cnf\_PrintStat(const Be\_Cnf\_ptr self, FILE* outFile, char* prefix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Print out some statistics]

  Description [Print out, in this order: the clause number, the var number, the
               highest variable index, the average clause size, the highest
               clause size]

  SideEffects ["outFile" is written]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void \_be\_cnf\_destroy\_clause(void* data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Frees the array used to store the clause.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{beManager.c}
		
	\texttt{Be\_Manager\_ptr Be\_Manager\_Create(void* spec\_manager, Be\_Spec2Be\_fun spec2be\_converter, Be\_Be2Spec\_fun be2spec\_converter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a generic Be_Manager]

  Description [spec_manager is the specific structure which is used to manage
  the low-level structure. For example the RbcManager class in the
  RBC dependant implementation.
  This does not assume the ownership of 'spec_manager'. If you have dynamically
  created the spec_manager instance, you are responsible for deleting it after
  you deleted the Be_manager instance.
  This "virtual" function is supplied in order to be called by any
  specific class derived from Be_Manager, in its constructor code.
  spec2be and be2spec converters are gateways in order to polymorphically
  convert the low level support structure (for example a rbc pointer) to
  the generic be_ptr and viceversa.]

  SideEffects []

  SeeAlso     [Be_RbcManager_Create, Be_Manager_Delete]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_Manager\_Delete(Be\_Manager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Be_Manager destroyer]

  Description [Call this function from the destructor of the derived class
  that implements the Be_Manager class. Any other use is to be considered
  unusual.]

  SideEffects [self will be deleted from memory.]

  SeeAlso     [Be_RbcManager_Delete, Be_Manager_Create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Manager\_Spec2Be(const Be\_Manager\_ptr self, void* spec\_expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a specific-format boolean expression
  (for example in rbc format) into a generic BE]

  Description [Calls self->spec2be_converter in order to implement the
  polymorphism mechanism]

  SideEffects [Calls self->be2spec_converter in order to implement the
  polymorphism mechanism]

  SeeAlso     [Be_Manager_Be2Spec]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Be\_Manager\_Be2Spec(const Be\_Manager\_ptr self, be\_ptr be)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a generic BE into a specific-format boolean expression
  (for example in rbc format)]

  Description []

  SideEffects []

  SeeAlso     [Be_Manager_Spec2Be]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Be\_Manager\_GetData(const Be\_Manager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Derived classes data can be retrieved by this method]

  Description [When you instantiate a derived BE manager (for example the
  rbc manager) you can store any useful specific data by using
  Be_Manager_SetData. Those data can be lately retrieved by Be_Manager_GetData
  which gets a generic, structure-independent Be_Manager.]

  SideEffects []

  SeeAlso     [Be_Manager_SetData]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_Manager\_SetData(Be\_Manager\_ptr self, void* data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets specific structure manager data into the generic
  manager]

  Description [You can retieve saved data by using the method
  Be_Manager_GetData. This implements a kind of inheritance mechanism.]

  SideEffects [self will change its internal state.]

  SeeAlso     [Be_Manager_GetData]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Be\_Manager\_GetSpecManager(Be\_Manager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the specific manager under the be manager]

  Description [Gets the specific manager under the be manager]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bePkg.c}
		
	\texttt{void Be\_Init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Initializes the module]
  Description [Call before any other function contained in this module]

  SideEffects [Any module structure is allocated and initialized if required]

  SeeAlso     [Be_Quit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_Quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [De-initializes the module]
  Description [Call as soon as you finished to use this module services]

  SideEffects [Any module structure is deleted if required]

  SeeAlso     [Be_Init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_shiftHashInit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes private hast table member for shifting
  operations]

  Description        [Call be_shiftHash_Quit() before quit from the be  
  module]

  SideEffects        [Private global vars htShift_ptr will change]

  SeeAlso            [Be_LogicalShiftVar, Hash_Quit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_shiftHash\_Quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deletes private hast table member for shifting
  operations]

  Description        [Call be_shiftHash_Quit() before quit from BMC module]

  SideEffects        [Private global vars htShift_ptr will be put to NULL]

  SeeAlso            [be_shiftHashInit]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{beRbcManager.c}
		
	\texttt{Be\_Manager\_ptr Be\_RbcManager\_Create(const size\_t capacity)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a rbc-specific Be_Manager]

  Description [You must call Be_RbcManager_Delete when the created instance
  is no longer used.]

  SideEffects []

  SeeAlso     [Be_RbcManager_Delete]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_RbcManager\_Delete(Be\_Manager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys the given Be_MAnager instance you previously
  created by using Be_RbcManager_Create]

  Description []

  SideEffects []

  SeeAlso     [Be_RbcManager_Create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_RbcManager\_Reserve(Be\_Manager\_ptr self, const size\_t size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Changes the maximum number of variables the rbc manager can
  handle]

  Description []

  SideEffects [The given rbc manager will possibly change]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_RbcManager\_Reset (const Be\_Manager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Resets RBC cache]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Be\_IsTrue(Be\_Manager\_ptr manager, be\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given be is the true value,
  otherwise returns false]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Be\_IsFalse(Be\_Manager\_ptr manager, be\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given be is the false value,
  otherwise returns false]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Be\_IsConstant(Be\_Manager\_ptr manager, be\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given be is a constant value,
  such as either False or True]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Truth(Be\_Manager\_ptr manager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a 'true' constant value]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Falsity(Be\_Manager\_ptr manager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a 'false' constant value]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Not(Be\_Manager\_ptr manager, be\_ptr left)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Negates its argument]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_And(Be\_Manager\_ptr manager, be\_ptr left, be\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a new be which is the conjunction between
  its two arguments]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Or(Be\_Manager\_ptr manager, be\_ptr left, be\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a new be which is the disjunction of
  its two arguments]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Xor(Be\_Manager\_ptr manager, be\_ptr left, be\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a new be which is the exclusive-disjunction
  of its two arguments]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Implies(Be\_Manager\_ptr manager, be\_ptr arg1, be\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a new be which is the implication between
  its two arguments]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Iff(Be\_Manager\_ptr manager, be\_ptr left, be\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a new be which is the logical equivalence
  between its two arguments]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Ite(Be\_Manager\_ptr manager, be\_ptr c, be\_ptr t, be\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds an if-then-else operation be]

  Description        []

  SideEffects        [...]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_LogicalShiftVar(Be\_Manager\_ptr manager, be\_ptr f, int shift, const int* log2phy, const int* phy2log)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a fresh copy G(X') of the be F(X) by shifting
  each variable index of a given amount]

  Description [Shifting operation replaces each occurence of the
               variable x_i in `f' with the variable x_(i + shift).  A
               simple lazy mechanism is implemented to optimize that
               cases which given expression is a constant in.

               The two indices arrays log2phy and phy2log map
               respectively the logical level to the physical level,
               and the physical level to the logical levels. They
               allow the be encoder to freely organize the variables
               into a logical and a physical level. This feature has
               been introduced with NuSMV-2.4 that ships dynamic
               encodings.

               !!!! WARNING !!!!
                 Since version 2.4 memoizing has been moved to BeEnc,
                 as there is no way of calculating a good hashing key
                 as the time would be requested, but timing
                 information are not available at this stage.
               ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_LogicalVarSubst(Be\_Manager\_ptr manager, be\_ptr f, int* subst, const int* log2phy, const int* phy2log)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Replaces all variables in f with other variables, taking
               them at logical level]

  Description [Replaces every occurence of the variable x_i in in `f'
               with the variable x_j provided that subst[i] = j.

               Notice that in this context, 'i' and 'j' are LOGICAL
               indices, not physical, i.e. the substitution array is
               provided in terms of logical indices, and is related
               only to the logical level.

               For a substitution at physical level, see Be_VarSubst.

               There is no need for `subst' to contain all the
               variables, but it should map at least the variables in
               `f' in order for the substitution to work properly.

               The two indices arrays log2phy and phy2log map
               respectively the logical level to the physical level,
               and the physical level to the logical levels. They
               allow the be encoder to freely organize the variables
               into a logical and a physical level. This feature has
               been introduced with NuSMV-2.3 that ships dynamic
               encodings.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Be\_Cnf\_ptr Be\_ConvertToCnf(Be\_Manager\_ptr manager, be\_ptr f, int polarity)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts the given be into the corresponding CNF-ed be]

  Description [Since it creates a new Be_Cnf structure, the caller
  is responsible for deleting it when it is no longer used
  (via Be_Cnf_Delete).

  'polarity' is used to determine if the clauses generated should
   represent the RBC positively, negatively, or both (1, -1 or 0
   respectively). For an RBC that is known to be true, the clauses
   that represent it being false are not needed (they would be removed
   anyway by propogating the unit literal which states that the RBC is
   true). Similarly for when the RBC is known to be false. This
   parameter is only used with the compact cnf conversion algorithm,
   and is ignored if the simple algorithm is used.]

  SideEffects []

  SeeAlso     [Be_Cnf_Delete]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr Be\_CnfModelToBeModel(Be\_Manager\_ptr manager, Slist\_ptr cnfModel)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts the given CNF model into BE model]

  Description [Since it creates a new lsit , the caller
  is responsible for deleting it when it is no longer used
  (via lsDestroy)]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_CnfLiteral2BeLiteral(const Be\_Manager\_ptr self, int cnfLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a CNF literal into a BE literal]

  Description [The function returns 0 if there is no BE index
  associated with the given CNF index.  A given CNF literal should be
  created by given BE manager (through Be_ConvertToCnf).]

  SideEffects []

  SeeAlso     [Be_ConvertToCnf]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_BeLiteral2CnfLiteral(const Be\_Manager\_ptr self, int beLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a BE literal into a CNF literal (sign is taken into
  account)]

  Description []

  SideEffects []

  SeeAlso     [Be_ConvertToCnf]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_BeLiteral2BeIndex(const Be\_Manager\_ptr self, int beLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a BE literal into a CNF literal]

  Description []

  SideEffects []

  SeeAlso     [Be_ConvertToCnf]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_BeIndex2BeLiteral(const Be\_Manager\_ptr self, int beIndex)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a BE index into a BE literal (always positive)]

  Description []

  SideEffects []

  SeeAlso     [Be_ConvertToCnf]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_BeIndex2CnfLiteral(const Be\_Manager\_ptr self, int beIndex)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns a CNF literal (always positive) associated with a
  given BE index]

  Description [If no CNF index is associated with a given BE index, 0
  is returned. BE indexes are associated with CNF indexes through
  function Be_ConvertToCnf.  ]

  SideEffects []

  SeeAlso     [Be_ConvertToCnf]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_DumpDavinci(Be\_Manager\_ptr manager, be\_ptr f, FILE* outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dumps the given be into a file with Davinci format]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_DumpGdl(Be\_Manager\_ptr manager, be\_ptr f, FILE* outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dumps the given be into a file with Davinci format]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_DumpSexpr(Be\_Manager\_ptr manager, be\_ptr f, FILE* outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dumps the given be into a file]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_Index2Var(Be\_Manager\_ptr manager, int varIndex)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts the given variable index into the corresponding be]

  Description [If corresponding index had not been previously
  allocated, it will be allocated. If corresponding node does not
  exist in the dag, it will be inserted.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_Var2Index(Be\_Manager\_ptr manager, be\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts the given variable (as boolean expression) into
  the corresponding index]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Be\_PrintStats(Be\_Manager\_ptr manager, int clustSize, FILE* outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints out some statistical data about the underlying
  rbc structure]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Be\_CnfLiteral\_IsSignPositive(const Be\_Manager\_ptr self, int cnfLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true iff sign of literal is positive.]

  Description []

  SideEffects []

  SeeAlso     [Be_CnfLiteral_Negate, Be_BeLiteral_IsSignPositive]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_CnfLiteral\_Negate(const Be\_Manager\_ptr self, int cnfLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns negated literal.]

  Description []

  SideEffects []

  SeeAlso     [Be_CnfLiteral_IsSignPositive, Be_BeLiteral_Negate]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Be\_BeLiteral\_IsSignPositive(const Be\_Manager\_ptr self, int beLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true iff sign of literal is positive.]

  Description []

  SideEffects []

  SeeAlso     [Be_BeLiteral_Negate, Be_CnfLiteral_IsSignPositive]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Be\_BeLiteral\_Negate(const Be\_Manager\_ptr self, int beLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns negated literal.]

  Description []

  SideEffects []

  SeeAlso     [Be_BeLiteral_IsSignPositive, Be_CnfLiteral_Negate]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Be\_apply\_inlining(Be\_Manager\_ptr mgr, be\_ptr f, boolean add\_conj)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Performs the inlining of f, either including or not
  the conjuction set.]

  Description [If add_conj is true, the conjuction set is included, otherwise
        only the inlined formula is returned for a lazy SAT solving.]

  SideEffects []

  SeeAlso     [InlineResult]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* beRbc\_Be2Rbc(Be\_Manager\_ptr mgr, be\_ptr be)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a be into a rbc]

  Description [The current implementation is really a simple type renaming.
  Internally used by Be_Manager via the inheritance mechanism.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr beRbc\_Rbc2Be(Be\_Manager\_ptr mgr, void* rbc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a rbc into a be]

  Description [The current implementation is really a simple type renaming.
  Internally used by Be_Manager via the inheritance mechanism.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{bmc}
		
	\section{sbmc}
		
	\subsection{sbmcBmc.c}
		
	\texttt{int Bmc\_SBMCGenSolveLtl(Prop\_ptr ltlprop, const int k, const int relative\_loop, const boolean must\_inc\_length, const boolean must\_solve, const Bmc\_DumpType dump\_type, const char* dump\_fname\_template)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a LTL property generates and solve the problems
  for all Ki (k_min<=i<=k_max). If bIncreaseK is 0 then k_min==k_max==k and
  only one problem is generated. If bIncreaseK is 1 then k_min == 0 and
  k_max == k.
  Each problem Ki takes into account of all possible loops from k_min to Ki
  if loopback is '*' (BMC_ALL_LOOPS). <BR>
  Also see the Bmc_GenSolve_Action possible values]

  Description        []

  SideEffects        []

  SeeAlso            [Bmc_GenSolve_Action]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_expandFilename(const int k, const int l, const int prop\_idx, const char* filename\_to\_be\_expanded, char* filename\_expanded, const size\_t filename\_expanded\_maxlen)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This is only a useful wrapper for easily call
  Bmc_Utils_ExpandMacrosInFilename]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcBmcInc.c}
		
	\texttt{int Sbmc\_zigzag\_incr(Prop\_ptr ltlprop, const int max\_k, const int opt\_do\_virtual\_unrolling, const int opt\_do\_completeness\_check)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [High level function that performs incremental sbmc]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Sbmc\_zigzag\_incr\_assume(Prop\_ptr ltlprop, const int max\_k, const int opt\_do\_virtual\_unrolling, const int opt\_do\_completeness\_check, Slist\_ptr assumptions, Slist\_ptr* conflict)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [High level function that performs incremental
  sbmc under assumptions. Currently this routine requires MiniSAT being
  used as SAT solver.]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static hash\_ptr sbmc\_bmc\_inc\_setup\_layer(BeFsm\_ptr be\_fsm, const char* layer\_name, state\_vars\_struct* state\_vars, node\_ptr bltlspec, const int opt\_do\_virtual\_unrolling, const int opt\_do\_completeness\_check, const int opt\_force\_state\_vars, node\_ptr * ass\_SimplePath\_node )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates and sets up a new layer whose name is provided]

  Description [This is a private service of Sbmc_zigzag_incr. Returned
  hash is used by the caller and will be destroyed later by
  bmc_inc_shutdown_layer]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sbmc\_bmc\_inc\_shutdown\_layer(BeFsm\_ptr be\_fsm, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Shuts down the layer that had been created by
  sbmc_bmc_inc_setup_layer]

  Description [This is a private service of Sbmc_zigzag_incr.
  info_map is the hash previously returned by sbmc_bmc_inc_setup_layer]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcCmd.c}
		
	\texttt{int Sbmc\_CommandCheckLtlSpecSBmc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Uses Kepa's and Timo's method for doing bmc]

  Description        [Model check using sbmc]

  SideEffects        [None]

  SeeAlso            []

  CommandName        [check_ltlspec_sbmc]

  CommandSynopsis    [Finds error up to depth k]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\]\ | -P
  "name"\] \[-k max_length\] \[-l loopback\] \[-1\] \[-o filename\]]

  CommandDescription [
  This command generates one or more problems, and calls
  SAT solver for each one. Each problem is related to a specific problem
  bound, which increases from zero (0) to the given maximum problem
  length. Here "<i>length</i>" is the bound of the problem that system
  is going to generate and/or solve. <BR>
  In this context the maximum problem bound is represented by the
  <i>-k</i> command parameter, or by its default value stored in the
  environment variable <i>bmc_length</i>.<BR>
  The single generated problem also depends on the "<i>loopback</i>"
  parameter you can explicitly specify by the <i>-l</i> option, or by its
  default value stored in the environment variable <i>bmc_loopback</i>. <BR>
  The property to be checked may be specified using the <i>-n idx</i> or
  the <i>-p "formula"</i> options. <BR>
  If you need to generate a dimacs dump file of all generated problems, you
  must use the option <i>-o "filename"</i>. <BR>
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid LTL specification
       formula actually located in the properties database. <BR>
    <dt> <tt>-p "formula" \[IN context\]</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTLSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>max_length</i></tt>
       <dd> <i>max_length</i> is the maximum problem bound must be reached.
       Only natural number are valid values for this option. If no value
       is given the environment variable <i>bmc_length</i> is considered
       instead.
    <dt> <tt>-l <i>loopback</i></tt>
       <dd> <i>loopback</i> value may be: <BR>
       - a natural number in (0, <i>max_length-1</i>). Positive sign ('+') can
       be also used as prefix of the number. Any invalid combination of length
       and loopback will be skipped during the generation/solving process.<BR>
       - a negative number in (-1, -<i>bmc_length</i>). In this case
       <i>loopback</i> is considered a value relative to <i>max_length</i>.
       Any invalid combination of length and loopback will be skipped
       during the generation/solving process.<BR>
       - the symbol 'X', which means "no loopback" <BR>
       - the symbol '*', which means "all possible loopback from zero to
       <i>length-1</i>"
    <dt> <tt>-1</tt>
       <dd> Generates and solves a single problem with length <tt>k</tt>
    <dt> <tt>-o <i>filename</i></tt>
       <dd> <i>filename</i> is the name of the dumped dimacs file.
       It may contain special symbols which will be macro-expanded to form
       the real file name. Possible symbols are: <BR>
       - @F: model name with path part <BR>
       - @f: model name without path part <BR>
       - @k: current problem bound <BR>
       - @l: current loopback value <BR>
       - @n: index of the currently processed formula in the properties
       database <BR>
       - @@: the '@' character
  </dl>

  For further information about this implementation see:
  T. Latvala, A. Biere, K. Heljanko, and T. Junttila. Simple is
  Better: Efficient Bounded Model Checking for Past LTL. In: R. Cousot
  (ed.), Verification, Model Checking, and Abstract Interpretation,
  6th International Conference VMCAI 2005, Paris, France, Volume 3385
  of LNCS, pp. 380-395, Springer, 2005.  Copyright (c)
  Springer-Verlag.

  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Sbmc\_CommandGenLtlSpecSBmc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generate length_max+1 problems iterating the problem
  bound from zero to length_max, and dumps each problem to a dimacs file.
  Uses Kepa's and Timo's method for doing bmc]

  Description        [Each problem is dumped for the given LTL specification,
  or for all LTL specifications if no formula is given.
  Generation parameters are the maximum bound and the loopback values. <BR>
  After command line processing it calls the function Bmc_SBMCGenSolveLtl
  to generate and dump all problems from zero to k.Uses Kepa's and Timo's method for doing bmc ]

  SideEffects        [None]

  SeeAlso            []

  CommandName        [gen_ltlspec_sbmc]

  CommandSynopsis    [Dumps into one or more dimacs files the given LTL
  specification, or all LTL specifications if no formula is given.
  Generation and dumping parameters are the maximum bound and the loopback
  values. Uses Kepa's and Timo's method for doing bmc.]

 CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\]
  \[-k max_length\] \[-l loopback\] \[-1\] \[-o filename\]]

  CommandDescription [ This command generates one or more problems, and
  dumps each problem into a dimacs file. Each problem is related to a specific
  problem bound, which increases from zero (0) to the given maximum problem
  bound. In this short description "<i>length</i>" is the bound of the
  problem that system is going to dump out. Uses Kepa's and Timo's method for doing bmc. <BR>
  In this context the maximum problem bound is represented by the
  <i>max_length</i> parameter, or by its default value stored in the
  environment variable <i>bmc_length</i>.<BR>
  Each dumped problem also depends on the loopback you can explicitly
  specify by the <i>-l</i> option, or by its default value stored in the
  environment variable <i>bmc_loopback</i>. <BR>
  The property to be checked may be specified using the <i>-n idx</i> or
  the <i>-p "formula"</i> options. <BR>
  You may specify dimacs file name by using the option <i>-o "filename"</i>,
  otherwise the default value stored in the environment variable
  <i>bmc_dimacs_filename</i> will be considered.<BR>
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid LTL specification
       formula actually located in the properties database. <BR>
    <dt> <tt>-p "formula" \[IN context\]</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTLSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>max_length</i></tt>
       <dd> <i>max_length</i> is the maximum problem bound must be reached.
       Only natural number are valid values for this option. If no value
       is given the environment variable <i>bmc_length</i> is considered
       instead.
    <dt> <tt>-l <i>loopback</i></tt>
       <dd> <i>loopback</i> value may be: <BR>
       - a natural number in (0, <i>max_length-1</i>). Positive sign ('+') can
       be also used as prefix of the number. Any invalid combination of length
       and loopback will be skipped during the generation/solving process.<BR>
       - a negative number in (-1, -<i>bmc_length</i>). In this case
       <i>loopback</i> is considered a value relative to <i>max_length</i>.
       Any invalid combination of length and loopback will be skipped
       during the generation/solving process.<BR>
       - the symbol 'X', which means "no loopback" <BR>
       - the symbol '*', which means "all possible loopback from zero to
       <i>length-1</i>"
    <dt> <tt>-1</tt>
       <dd> Generates a single problem with length <tt>k</tt>
    <dt> <tt>-o <i>filename</i></tt>
       <dd> <i>filename</i> is the name of the dumped dimacs file.
       It may contain special symbols which will be macro-expanded to form
       the real file name. Possible symbols are: <BR>
       - @F: model name with path part <BR>
       - @f: model name without path part <BR>
       - @k: current problem bound <BR>
       - @l: current loopback value <BR>
       - @n: index of the currently processed formula in the properties
       database <BR>
       - @@: the '@' character
  </dl>

  For further information about this implementation see:
  T. Latvala, A. Biere, K. Heljanko, and T. Junttila. Simple is
  Better: Efficient Bounded Model Checking for Past LTL. In: R. Cousot
  (ed.), Verification, Model Checking, and Abstract Interpretation,
  6th International Conference VMCAI 2005, Paris, France, Volume 3385
  of LNCS, pp. 380-395, Springer, 2005.  Copyright (c)
  Springer-Verlag.
  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Sbmc\_CommandLTLCheckZigzagInc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Uses Kepa's and Timo's method for doing incremental bmc]

  Description        [

  For further information about this implementation see: K. Heljanko,
  T. Junttila and T. Latvala.  Incremental and Complete Bounded Model
  Checking for Full PLTL.  In K. Etessami and S. Rajamani (eds.),
  Computer Aided Verification, Edinburgh, Scotland, Volume 3576 of
  LNCS, pp. 98-111, Springer, 2005. Copyright (c) Springer-Verlag.]

    SideEffects        [None]

  SeeAlso            []

  CommandName        [check_ltlspec_sbmc_inc]

  CommandSynopsis    [Incremental SBMC LTL model checking]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\]\ | -P
  "name"\] \[-k max_length\] \[-c\] \[-N\]]

  CommandDescription [
  This command generates one or more problems, and calls
  SAT solver for each one. Each problem is related to a specific problem
  bound, which increases from zero (0) to the given maximum problem
  length. Here "<i>length</i>" is the bound of the problem that system
  is going to generate and/or solve. <BR>
  In this context the maximum problem bound is represented by the
  <i>-k</i> command parameter, or by its default value stored in the
  environment variable <i>bmc_length</i>.<BR>
  The property to be checked may be specified using the <i>-n idx</i>,
  <i>-p "formula"</i>, or <i>-P "property_name"</i> options. <BR>
  Completeness check, although slower, can be used to determine whether
  the property holds.<BR>
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid LTL specification
       formula actually located in the properties database. <BR>
    <dt> <tt>-p "formula" \[IN context\]</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTLSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>max_length</i></tt>
       <dd> <i>max_length</i> is the maximum problem bound must be reached.
       Only natural number are valid values for this option. If no value
       is given the environment variable <i>bmc_length</i> is considered
       instead.
    <dt> <tt>-c</tt>
       <dd> Performs completeness check at every step. This can be
       effectively used to determine whether a property holds.</tt>
    <dt><tt>-N</tt>
       <dd> Does not perform virtual unrolling.
  </dl>

  For further information about this implementation see:
  T. Latvala, A. Biere, K. Heljanko, and T. Junttila. Simple is
  Better: Efficient Bounded Model Checking for Past LTL. In: R. Cousot
  (ed.), Verification, Model Checking, and Abstract Interpretation,
  6th International Conference VMCAI 2005, Paris, France, Volume 3385
  of LNCS, pp. 380-395, Springer, 2005.  Copyright (c)
  Springer-Verlag.

  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Sbmc\_check\_psl\_property(Prop\_ptr prop, boolean dump\_prob, boolean inc\_sat, boolean do\_completeness\_check, boolean do\_virtual\_unrolling, boolean single\_prob, int k, int rel\_loop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Top-level function for bmc of PSL properties]

  Description        [The parameters are:
  - prop is the PSL property to be checked
  - dump_prob is true if the problem must be dumped as DIMACS file (default filename
  from system corresponding variable)
  - inc_sat is true if incremental sat must be used. If there is no
  support for inc sat, an internal error will occur.
  - single_prob is true if k must be not incremented from 0 to k_max
    (single problem)
  - k and rel_loop are the bmc parameters.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Outcome sbmc\_cmd\_options\_handling(int argc, char** argv, Prop\_Type prop\_type, /* output parameters: */ Prop\_ptr* res\_prop, int* res\_k, int* res\_l, char** res\_o, boolean* res\_N, boolean* res\_c, boolean* res\_1)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Sbmc commands options handling for commands (optionally)
  acceping options -k -l -o -p -n -N -c]

  Description [ Output variables called res_* are pointers to
  variables that will be changed if the user specified a value for the
  corresponding option. For example if the user specified "-k 2", then
  *res_k will be assigned to 2. The caller can selectively choose which
  options can be specified by the user, by passing either a valid pointer
  as output parameter, or NULL to disable the corresponding option.
  For example by passing NULL as actual parameter of res_l, option -l will
  be not accepted.

  If both specified, k and l will be checked for mutual consistency.
  Loop will contain a relative value, like the one the user specified.

  prop_type is the expected property type, if specified.

  All integers values will not be changed if the corresponding options
  had not be specified by the user, so the caller might assign them to
  default values before calling this function.

  All strings will be allocated by the function if the corresponding
  options had been used by the user. In this case it is responsability
  of the caller to free them. Strings will be assigned to NULL if the
  user had not specified any corresponding option.

  Returns OUTCOME_GENERIC_ERROR if an error has occurred;
  Returns OUTCOME_SUCCESS_REQUIRED_HELP if -h options had been specified;
  Returns OUTCOME_SUCCESS in all other cases.
  ]

  SideEffects        [Result parameters might change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcGen.c}
		
	\texttt{be\_ptr Bmc\_Gen\_SBMCProblem(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the LTL problem at length k with loopback l
  (single loop, no loop and all loopbacks are allowed)]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcHash.c}
		
	\texttt{hashPtr Bmc\_Hash\_new\_htable()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create a new hash_table]

  Description        [Create a new hash_table]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_Hash\_find(hashPtr table, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Find a node in the table]

  Description        [Find a node in the table. Return BMC_HASH_NOTFOUND if the
  node is not present ]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned Bmc\_Hash\_size(hashPtr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return the number of occupied slots]

  Description        [Return the number of occupied slots]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Hash\_insert (hashPtr table, node\_ptr key, int data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert an element in the table]

  Description        [Insert an element in the table]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Hash\_delete\_table(hashPtr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Delete the table]

  Description        [Delete the table]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int find(hashPtr table, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return index of node, a free index if the node is not in the table]

  Description        [Return index of node, a free index if the node is not in the table]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcNodeStack.c}
		
	\texttt{Bmc\_Stack\_ptr Bmc\_Stack\_new\_stack()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create a new stack]

  Description        [Create a new stack]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Stack\_push(Bmc\_Stack\_ptr thestack, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Push a node unto the stack]

  Description        [Push a node unto the stack]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned Bmc\_Stack\_size(Bmc\_Stack\_ptr thestack)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return the number of occupied slots]

  Description        [Return the number of occupied slots]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Bmc\_Stack\_pop (Bmc\_Stack\_ptr thestack)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pop an element from the stack]

  Description        [Pop an element from the stack]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Stack\_delete(Bmc\_Stack\_ptr thestack)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Delete the stack]

  Description        [Delete the stack]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Bmc\_Stack\_top(Bmc\_Stack\_ptr thestack)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return the top element of the stack]

  Description        [Return the top element of the stack]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcPkg.c}
		
	\texttt{void SBmc\_Init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the SBMC sub package]

  Description        [Initializes the SBMC sub package]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SBmc\_Quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees all resources allocated for SBMC]

  Description        [Frees all resources allocated for the SBMC model manager]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SBmc\_AddCmd()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds all bmc-related commands to the interactive shell]

  Description        []

  SideEffects        []

  SeeAlso            [CInit_Init]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcStructs.c}
		
	\texttt{state\_vars\_struct* sbmc\_state\_vars\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an empty state_vars_struct]

  Description        [Creates an empty state_vars_struct]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_destroy(state\_vars\_struct* svs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [state_vars_struct destroyer]

  Description        [state_vars_struct destroyer]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_state\_vars\_get\_trans\_state\_vars(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"trans_state_vars\"]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr sbmc\_state\_vars\_get\_l\_var(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"l_var\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr sbmc\_state\_vars\_get\_LoopExists\_var(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"LoopExists_var\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr sbmc\_state\_vars\_get\_LastState\_var(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"LastState_var\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_state\_vars\_get\_translation\_vars\_pd0(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"translation_vars_pd0\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_state\_vars\_get\_translation\_vars\_pdx(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"translation_vars_pdx\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_state\_vars\_get\_translation\_vars\_aux(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"translation_vars_aux\"]

  Description        [state_vars_struct destroyer]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_state\_vars\_get\_formula\_state\_vars(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"formula_state_vars\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_state\_vars\_get\_formula\_input\_vars(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"formula_input_vars\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_state\_vars\_get\_simple\_path\_system\_vars(const state\_vars\_struct * ss)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [getter for field \"simple_path_system_vars\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_trans\_state\_vars(state\_vars\_struct * ss, lsList f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"transition_state_vars\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_l\_var(state\_vars\_struct * ss, node\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"l_var\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_LoopExists\_var(state\_vars\_struct * ss, node\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"LoopExists_var\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_LastState\_var(state\_vars\_struct * ss, node\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"LastState_var\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_translation\_vars\_pd0(state\_vars\_struct * ss, lsList f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"translation_state_vars_pd0\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_translation\_vars\_pdx(state\_vars\_struct * ss, lsList f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"translation_vars_pdx\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_translation\_vars\_aux(state\_vars\_struct * ss, lsList f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"translation_vars_aux\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_formula\_state\_vars(state\_vars\_struct * ss, lsList f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"formula_state_vars\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_formula\_input\_vars(state\_vars\_struct * ss, lsList f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"formula_input_vars\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_set\_simple\_path\_system\_vars(state\_vars\_struct * ss, lsList f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [setter for field \"simple_path_system_vars\"]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_state\_vars\_print(state\_vars\_struct *svs, FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Print a state_vars_struct]

  Description        [Print a state_vars_struct to 'out']

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr sbmc\_set\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an associtative list to avoid duplicates
  of node_ptr]

  Description        [An associtative list to avoid duplicates of
  node_ptr. If a node is in this set, it has a constant 1 associated
  to it in the associative hash.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_set\_destroy(hash\_ptr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destroy an associative list used to avoid
  duplicates of node_ptr.]

  Description        [Destroy an associative list used to avoid
  duplicates of node_ptr.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_set\_insert(hash\_ptr hash, node\_ptr bexp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a node in the hash]

  Description        [Insert a node in the hash associating constant 1]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sbmc\_set\_is\_in(hash\_ptr hash, node\_ptr bexp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if a node_ptr was already inserted.]

  Description        [Checks whether a node_ptr was already
  inserted. In affermative case return 1, else 0.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{sbmc\_node\_info * sbmc\_alloc\_node\_info()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an empty structure to hold information
  associated to each subformula.]

  Description        [Creates an empty structure to hold information
  associated to each subformula.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_node\_info\_free(sbmc\_node\_info * info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees a structure to hold information
  associated to each subformula.]

  Description        [Frees a structure to hold information
  associated to each subformula.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr sbmc\_node\_info\_assoc\_create(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an asociative list for pairs node_ptr
  sbmc_node_info *]

  Description        [Creates an asociative list for pairs node_ptr
  sbmc_node_info *]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_node\_info\_assoc\_free(hash\_ptr * a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an asociative list for pairs node_ptr
  sbmc_node_info *]

  Description        [Creates an asociative list for pairs node_ptr
  sbmc_node_info *]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_node\_info\_assoc\_insert(hash\_ptr a, node\_ptr n, sbmc\_node\_info * i)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert in the assoc table the infomrnation for
  the subformula.]

  Description        [Insert in the assoc table the infomrnation for
  the subformula.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{sbmc\_node\_info * sbmc\_node\_info\_assoc\_find(hash\_ptr a, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return the information associated to a
  subformula if any.]

  Description        [Return the information associated to a
  subformula if any.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcTableau.c}
		
	\texttt{be\_ptr Bmc\_SBMCTableau\_GetNoLoop(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau without loop]

  Description        [Fairness is ignored]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_SBMCTableau\_GetSingleLoop(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau for a single loop. This function takes
                      into account of fairness]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_SBMCTableau\_GetAllLoops(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau for all possible loops in \[l, k\[,
  taking into account of fairness using Kepa/Timo method]

  Description        [Fairness is taken care of by adding it to the formula.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_SBMCTableau\_GetLoopCondition(const BeEnc\_ptr be\_enc, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a tableau that constraints state k to be equal to
                      state l. This is the condition for a path of length (k+1)
                      to represent a (k-l)loop (new semantics).]

  Description        [State l and state k are forced to represent the same
                      state by conjuncting the if-and-only-if conditions
                      {Vil<->Vik} between Vil (variable i at time l) and Vik
                      (variable i at time k) for each variable Vi.]

  SideEffects        []

  SeeAlso            [Bmc_Tableau_GetAllLoopsDisjunction]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcTableauInc.c}
		
	\texttt{be\_ptr sbmc\_equal\_vectors\_formula(const BeEnc\_ptr be\_enc, lsList vars, const unsigned int i, const unsigned int j)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes the BE formula "\land_{v \in vars} s_i = s_j"]

  Description        [Creates the BE for the formula "\land_{v \in vars} s_i = s_j"]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr sbmc\_init\_LTL\_info(SymbLayer\_ptr layer, node\_ptr ltlspec, lsList state\_vars\_formula\_pd0, lsList state\_vars\_formula\_pdx, lsList state\_vars\_formula\_aux, const int opt\_force\_state\_vars, const int opt\_do\_virtual\_unrolling)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Associates each subformula node of ltlspec with
  a sbmc_LTL_info.]

  Description        [Associates each subformula node of ltlspec with
  a sbmc_LTL_info. Returns a hash from node_ptr to sbmc_LTL_info*.
  The new state vars are inserted in state_vars_formula_??? appropriately.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_init\_state\_vector(const BeEnc\_ptr be\_enc, const node\_ptr ltlspec, const hash\_ptr info\_map, const unsigned int i\_real, const node\_ptr LastState\_var, const be\_ptr be\_LoopExists)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initialize trans_bes[i][d] for each sub-formula.]

  Description        [ Initialize trans_bes[i][d], 0<=d<=pd, to
  <ul>
    <li> the formula [[f]]_i^d for definitionally translated subformulae</li>
    <li> the [[f]]_i^d be variable for variable translated subformulae</li>
  </ul> ]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr sbmc\_build\_InLoop\_i(const BeEnc\_ptr be\_enc, const state\_vars\_struct * state\_vars, array\_t *InLoop\_array, const unsigned int i\_model)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Build InLoop_i]

  Description        [Build InLoop_i stuff
  Define InLoop_i = (InLoop_{i-1} || l_i)<br>
  Returns the BE constraint InLoop_{i-1} => !l_i  (or 0 when i=0)]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_SimplePaths(const BeEnc\_ptr be\_enc, const state\_vars\_struct *state\_vars, array\_t *InLoop\_array, const unsigned int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Build SimplePath_{i,k} for each 0<=i<k]

  Description        [Build SimplePath_{i,k} for each 0<=i<k]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcTableauIncLTLformula.c}
		
	\texttt{lsList sbmc\_unroll\_base(const BeEnc\_ptr be\_enc, const node\_ptr ltlspec, const hash\_ptr info\_map, const be\_ptr be\_LoopExists, const int do\_optimization)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates the BASE constraints.]

  Description        [Create the BASE constraints.<br>
  Return a list of be_ptr for the created constraints.<br>
  Create the following constraints:<br>
  <ul>
    <li> !LoopExists => ([[f]]_L^d == FALSE) </li> 
    <li> LoopExists => ([[Ff]]_E^pd(Gf) => <<Ff>>_E) </li> 
    <li> LoopExists => ([[Gf]]_E^pd(Gf) <= <<Gf>>_E) </li> 
    <li> LoopExists => ([[fUg]]_E^pd(Gf) => <<Fg>>_E) </li> 
    <li> LoopExists => ([[fRg]]_E^pd(Gf) <= <<Gg>>_E) </li> 
  </ul>
  If do_optimization is true, then create the following constraints:
  <ul>
    <li> [[p]]_E^d <=> p_E </li> 
    <li> [[TRUE]]_E^0 <=> TRUE </li> 
    <li> [[FALSE]]_E^0 <=> FALSE </li> 
    <li> [[f | g]]_E^d <=> [[f]]_E^d | [[g]]_E^d </li> 
    <li> [[f & g]]_E^d <=> [[f]]_E^d & [[g]]_E^d </li> 
    <li> [[!f]]_E^d <=> ![[f]]_E^d </li> 
    <li> [[Ff]]_E^d <=> [[f]]_E^d | [[Ff]]_L^min(d+1,pd(f)) </li> 
    <li> [[Ff]]_E^d+1 => [[Ff]]_E^d </li> 
    <li> <<Ff>>_E => [[Ff]]_E^pd(Ff) </li> 
    <li> [[Gf]]_E^d <=> [[f]]_E^d & [[Gf]]_L^min(d+1,pd(f)) </li> 
    <li> [[Gf]]_E^d => [[Gf]]_E^d+1 </li> 
    <li> [[Gf]]_E^pd(Gf) => <<Gf>>_E </li> 
    <li> [[fUg]]_E^d <=> [[g]]_E^d | ([[f]]_E^d  & [[fUg]]_L^min(d+1,pd(fUg))) </li> 
    <li> [[fRg]]_E^d <=> [[g]]_E^d & ([[f]]_E^d  | [[fRg]]_L^min(d+1,pd(fUg))) </li> 
    <li> [[Xf]]_E^d <=> [[f]]_L^min(d+1,pd(f)) </li> 
    <li> [[Hf]]_E^d+1 => [[Hf]]_E^d </li> 
    <li> [[Of]]_E^d => [[Of]]_E^d+1 </li> 
  </ul>
  ]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_unroll\_invariant\_propositional(const BeEnc\_ptr be\_enc, const node\_ptr ltlspec, const unsigned int i\_model, const hash\_ptr info\_map, const be\_ptr be\_InLoop\_i, const be\_ptr be\_l\_i, const int do\_optimization)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create the k-invariant constraints for
  propositional operators at time i.]

  Description        [Create the k-invariant constraints for
  propositional operators at time i. Return a list of be_ptrs for the
  created constraints.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static lsList sbmc\_unroll\_invariant\_f(const BeEnc\_ptr be\_enc, const node\_ptr ltlspec, const unsigned int i\_model, const hash\_ptr info\_map, const be\_ptr be\_InLoop\_i, const be\_ptr be\_l\_i, const be\_ptr be\_LastState\_i, const be\_ptr be\_LoopExists, const int do\_optimization)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create the k-invariant constraints for propositional and
  future temporal operators at time i.]

  Description        [Create the k-invariant constraints for propositional and
  future temporal operators at time i. Return a list of be_ptrs for the
  created constraints.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static lsList sbmc\_unroll\_invariant\_p(const BeEnc\_ptr be\_enc, const node\_ptr ltlspec, const unsigned int i\_model, const hash\_ptr info\_map, const be\_ptr be\_InLoop\_i, const be\_ptr be\_l\_i, const int do\_optimization)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create the k-invariant constraints at time i.]

  Description        [Create the k-invariant constraints at time
  i. Return a list of be_ptrs for the created constraints.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_formula\_dependent(const BeEnc\_ptr be\_enc, const node\_ptr ltlspec, const unsigned int k\_model, const hash\_ptr info\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create the formula specific k-dependent constraints.]

  Description        [Create the formula specific k-dependent constraints.
  Return a list of be_ptrs for the created constraints. ]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_unroll\_invariant(const BeEnc\_ptr be\_enc, const node\_ptr bltlspec, const int previous\_k, const int new\_k, const state\_vars\_struct *state\_vars, array\_t * InLoop\_array, const hash\_ptr info\_map, const be\_ptr be\_LoopExists, const int opt\_do\_optimization)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Unroll future and past fragment from
  previous_k+1 upto and including new_k.]

  Description        [Unroll future and past fragment from previous_k+1 
  upto and including new_k. Return a list of constraints.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_dependent(const BeEnc\_ptr be\_enc, const node\_ptr bltlspec, const int k, const state\_vars\_struct *state\_vars, array\_t *InLoop\_array, const be\_ptr be\_LoopExists, const hash\_ptr info\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description        [Creates several constraints:
  <ul>
  <li>Create the constraint l_{k+1} <=> FALSE</li>
  <li>Create the constraint s_E = s_k</li>
  <li>Create the constraint LoopExists <=> InLoop_k</li>
  <li>Create the formula specific k-dependent constraints</li>
  </ul>]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcTableauLTLformula.c}
		
	\texttt{be\_ptr BmcInt\_SBMCTableau\_GetAtTime(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int time, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given a wff expressed in ltl builds the model-independent
  tableau at 'time' of a path formula bounded by \[k, l\]]

  Description [The function generates the necessary auxilliary
               predicates (loop, atmostonce) and calls on
               get_f_at_time to generate the tableau for the ltl
               formula.]

  SideEffects        []

  SeeAlso            [AtMostOnce, Loop, get_f_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmcSBMC\_tableau\_GF\_FG\_last(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int k, const int l, const unsigned pastdepth, hashPtr table, hash\_ptr memoiz)}
	\begin{verbatimtab}
		
/**Function********************************************************************
   
Synopsis           [Construct f(k) att full pastdepth for the GF-,F-,FG-, or G-operator]

Description        [Checks if the il-optimisation is enabled and generates
f(k) accordingly] 

SideEffects        []

SeeAlso            [bmc_tableau_GetEventuallyIL_opt,
                    bmc_tableau_GetGloballyIL_opt]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr last\_g(const BeEnc\_ptr be\_enc, node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int l, const int k, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generate the last f(k) for operators that use the 
  auxillary encoding g.] 

  Description        [The function checks which loop setting is active 
                      and genrates f(k) accordingly.]
  
  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr last\_f(const BeEnc\_ptr be\_enc, node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int l, const int k, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Generate f(k,pastdepth) when pastdepth is less than
  maximum pastdepth, except for OP_NEXT where pastdepth can also
  be the maximum.]

  Description        [The function checks which loop setting is active 
                      and genrates f(k) accordingly.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int formulaMap(hashPtr table, const node\_ptr ltl\_wff, unsigned TLcount)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Map temporal subformulas to an integer, returns the
                      number subformulas with temporal connectives]

  Description        [Stores the nodes of the ltl expression in a table and
                      maps each formula to an integer. Temporal
                      subformulas are numbered from 0...N while all
                      other subformulas are mapped to -2]
                     
  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_f\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Genrates a boolean expression which is true iff the ltl
                      formula ltl_wff is true at time]

  Description        [The function recursively traverses the formula and genrates
                      the needed boolean expression.]

  SideEffects        []

  SeeAlso            [get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_Globally\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates a boolean expression which is true iff the ltl
                      formula ltl_wff is true at time, handles the GLOBALLY 
                      operator]

  Description        [The function recursively traverses the formula and
                      generates the needed boolean expression.]

  SideEffects        []

  SeeAlso            [get_f_at_time, get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_Eventually\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Genrates a boolean expression which is true iff the ltl
formula ltl_wff is true at time, handles the FINALLY 
operator]

Description        [The function recursively traverses the formula and genrates
the needed boolean expression.]

SideEffects        []

SeeAlso            [get_f_at_time, get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_Until\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Genrates a boolean expression which is true iff the ltl
                      formula ltl_wff is true at time, handles the UNTIL 
                      operator]

  Description        [The function recursively traverses the formula and genrates
                      the needed boolean expression.]

  SideEffects        []

  SeeAlso            [get_f_at_time, get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_V\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Genrates a boolean expression which is true iff the ltl
                      formula ltl_wff is true at time, handles the RELEASE 
                      operator]

  Description        [The function recursively traverses the formula and
                      genrates the needed boolean expression.]

  SideEffects        []

  SeeAlso            [get_f_at_time, get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_Since\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Genrates a boolean expression which is true iff the ltl
                      formula ltl_wff is true at time, handles the SINCE 
                      operator]

  Description        [The function recursively traverses the formula and
                      genrates the needed boolean expression.]

  SideEffects        []

  SeeAlso            [get_f_at_time, get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_Trigger\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Genrates a boolean expression which is true iff the ltl
                      formula ltl_wff is true at time, handles the TRIGGER 
                      operator]

  Description        [The function recursively traverses the formula and
                      genrates the needed boolean expression.]

  SideEffects        []

  SeeAlso            [get_f_at_time, get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_Historically\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Genrates a boolean expression which is true iff the ltl
                      formula ltl_wff is true at time, handles the HISTORICALLY
                      operator]

  Description        [The function recursively traverses the formula and genrates
                      the needed boolean expression.]

  SideEffects        []

  SeeAlso            [get_f_at_time, get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_Once\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Genrates a boolean expression which is true iff the ltl
                      formula ltl_wff is true at time, handles the ONCE 
                      operator]

  Description        [The function recursively traverses the formula and genrates
                      the needed boolean expression.]

  SideEffects        []

  SeeAlso            [get_f_at_time, get_g_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_g\_at\_time(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, hashPtr table, hash\_ptr memoiz, const int time, const int k, const int l, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        [Returns a pointer to the g_i(time) variable]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_el\_at\_time(const BeEnc\_ptr be\_enc, const int time, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a pointer to the el(time) variable]

  Description        [The variables el(time) describe if the state s_time 
                      should be equivalent with s_k]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr AtMostOnce(const BeEnc\_ptr be\_enc, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an expression which allows at most one el_i to
                      be true]

  Description        []

  SideEffects        []

  SeeAlso            [get_el_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Loop(const BeEnc\_ptr be\_enc, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates the expression: \wedge_{i=0}^{k-1} el_i =>
                      (s_i <=> s_k)]

  Description        [The expression when coupled with AtMostOnce forces
                      state i to be equivalent with state k, if el_i
                      is true.

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_il\_at\_time(const BeEnc\_ptr be\_enc, const int time, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a pointer to the il(time) variable]

  Description        [The il(i) variable describes if the state 'i' is a 
                      a state of the loop.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr get\_loop\_exists(const BeEnc\_ptr be\_enc, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a pointer to the le variable]

  Description        [The le variable is true if a loop exists.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmc\_tableauGetEventuallyIL\_opt(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int k, const int l, const unsigned pastdepth, hashPtr table, hash\_ptr memoiz)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an expression which initialises f(k+1) for 
                      an F or an GF formula when we use the il-optimisation.]

  Description       [Creates the expression f(k+1):=\vee_{i=1}^k il(i)\wedge
                     f1(i)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmc\_tableauGetGloballyIL\_opt(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int k, const int l, const unsigned pastdepth, hashPtr table, hash\_ptr memoiz)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an expression which initialises f(k+1) for 
                      a 'globally' or an FG formula when we use the il-optimisation.]

  Description        [Creates the expression f(k+1):=le\wedge \wedge_{i=1}^k \neg il(i)\vee f1(i)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_cache\_init(const int count, const int k, const unsigned pastdepth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initialises the chache used to store f_i(time) and g_(time) 
                      values.]

  Description        [The function allocates an array of size (k+1)*count for
                      both f and g. The array is used to cache values
                      of f_i(time) and g_i(time). Only values for
                      temporal formulas are stored.]

  SideEffects        []

  SeeAlso            [bmc_delete_cache]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_cache\_delete()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees the arrays used by the cache]

  Description        []

  SideEffects        []

  SeeAlso            [bmc_init_cache]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static unsigned bmc\_past\_depth(const node\_ptr ltl\_wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the maximum nesting depth of past operators in PLTL formula]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{sbmcUtils.c}
		
	\texttt{void sbmc\_print\_node(FILE * out, const char * prefix, node\_ptr node, const char * postfix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Print a node_ptr expression by prefixing and
  suffixing it.]

  Description        [Prints a node_ptr expression in a file stream by
  prefixing and suffixing it with a string. If the prefix and suffix
  strings are NULL they are not printed out.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_print\_node\_list(FILE *out, lsList l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a lsList of node_ptr]

  Description        [Prints a lsList of node_ptr in a file stream.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr sbmc\_add\_new\_state\_variable(SymbLayer\_ptr layer, char *name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declare a new boolean state variable in the layer.]

  Description        [Declare a new boolean state variable in the
  layer. The name is specified as a string. If the variable already
  exists, then an error is generated.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList sbmc\_find\_formula\_vars(node\_ptr ltlspec)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compute the variables that occur in the formula ltlspec.]

  Description        [Compute the variables that occur in the formula ltlspec.
  The formula ltlspec must  be in NNF.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_print\_varmap(FILE *out, node\_ptr node, sbmc\_node\_info *info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints some of the information associated to a
  subformula]

  Description        [Prints some of the information associated to a
  subformula.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_print\_Gvarmap(FILE *out, node\_ptr var, node\_ptr formula)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints some of the information associated to a G
  formula]

  Description        [Prints some of the information associated to a G
  formula.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_print\_Fvarmap(FILE *out, node\_ptr var, node\_ptr formula)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints some of the information associated to a F
  formula]

  Description        [Prints some of the information associated to a F
  formula.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr sbmc\_1\_fresh\_state\_var(SymbLayer\_ptr layer, unsigned int *index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new fresh state variable.]

  Description        [Creates a new fresh state variable. The name is
  index is incremented by one.]

  SideEffects        [index is incremented by one.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t * sbmc\_n\_fresh\_state\_vars(SymbLayer\_ptr layer, const unsigned int n, unsigned int *index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates N new fresh state variables.]

  Description        [Creates N new fresh state variables. The name is
  index is incremented by N. The new variables are stroed into an
  array of node_ptr]

  SideEffects        [index is incremented by N.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_allocate\_trans\_vars(sbmc\_node\_info *info, SymbLayer\_ptr layer, lsList state\_vars\_formula\_pd0, lsList state\_vars\_formula\_pdx, unsigned int* new\_var\_index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates info->pastdepth+1 new state variables
  for the main translation in info->trans_vars.]

  Description        [Creates info->pastdepth+1 new state variables
  for the main translation in info->trans_vars. state_vars_formula_pd0,
  state_vars_formula_pdx and new_var_index are updated accordingly.]

  SideEffects        [new_var_index is incremented accordingly to the
  number of variables created. state_vars_formula_pd0,
  state_vars_formula_pdx and new_var_index are updated accordingly.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr sbmc\_make\_boolean\_formula(Prop\_ptr ltlprop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Takes a property and return the negation of the
  property conjoined with the big and of fairness conditions.]

  Description        [Takes a property and return the negation of the
  property conjoined with the big and of fairness conditions.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_find\_relevant\_vars(state\_vars\_struct *svs, BeFsm\_ptr be\_fsm, node\_ptr bltlspec)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Find state and input variables that occurr in the formula.]

  Description        [Find state and input variables that occurr in the formula.
  Build the list of system variables for simple path constraints.

  <ul>
  <li> state_vars->formula_state_vars will have the state vars occurring
    in the formula bltlspec</li>
  <li> state_vars->formula_input_vars will have the input vars occurring
    in the formula bltlspec</li>
  <li> state_vars->simple_path_system_vars will be the union of
    state_vars->transition_state_vars,
    state_vars->formula_state_vars, and
    state_vars->formula_input_vars </li>
   </ul>

   Note: frozen variables are not collected since they do no
   paticipate in state equality formulas.]

  SideEffects        [svs is modified to store retrieved information.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Sbmc\_Utils\_generate\_and\_print\_cntexample(BeEnc\_ptr be\_enc, sbmc\_MetaSolver * solver, node\_ptr l\_var, const int k, const char * trace\_name, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Extracts a trace from a sat assignment, and prints it.]

  Description        [Extracts a trace from a sat assignment, registers it in
                      the TraceManager and prints it using the default plugin.]

  SideEffects        [None]

  SeeAlso            [Bmc_Utils_generate_and_print_cntexample
                      Sbmc_Utils_generate_cntexample
                      Sbmc_Utils_fill_cntexample]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Sbmc\_Utils\_generate\_cntexample(BeEnc\_ptr be\_enc, sbmc\_MetaSolver * solver, node\_ptr l\_var, const int k, const char * trace\_name, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Extracts a trace from a sat assignment.]

  Description        [Extracts a trace from a sat assignment.
                      The generated trace is non-volatile]

  SideEffects        [None]

  SeeAlso            [Bmc_Utils_generate_cntexample
                      Sbmc_Utils_fill_cntexample]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Sbmc\_Utils\_fill\_cntexample(BeEnc\_ptr be\_enc, sbmc\_MetaSolver * solver, node\_ptr l\_var, const int k, Trace\_ptr res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Fills the given trace using the given sat assignment.]

  Description        [Fills the given trace using the given sat assignment.]

  SideEffects        [The \"res\" trace is filled]

  SeeAlso            [Bmc_Utils_generate_cntexample]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sbmc\_L\_state(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Routines for the state indexing scheme]

  Description        [State 0 is the L state]

  SideEffects        [None]

  SeeAlso            [sbmc_E_state sbmc_real_k sbmc_model_k sbmc_real_k_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sbmc\_E\_state(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Routines for the state indexing scheme]

  Description        [State 1 is the E state]

  SideEffects        [None]

  SeeAlso            [sbmc_L_state sbmc_real_k sbmc_model_k sbmc_real_k_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sbmc\_real\_k(int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Routines for the state indexing scheme]

  Description        [The first real state is 2]

  SideEffects        [None]

  SeeAlso            [sbmc_L_state sbmc_E_state sbmc_model_k sbmc_real_k_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned int sbmc\_model\_k(int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Routines for the state indexing scheme]

  Description        [Given a real k return the corresponding model k (real - 2)]

  SideEffects        [None]

  SeeAlso            [sbmc_L_state sbmc_E_state sbmc_real_k sbmc_real_k_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* sbmc\_real\_k\_string(const unsigned int k\_real)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Routines for the state indexing scheme]

  Description        [Returns a string correspondingg to the state considered. E, L, Real]

  SideEffects        [The returned value must be freed]

  SeeAlso            [sbmc_L_state sbmc_E_state sbmc_real_k sbmc_model_k]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{sbmc\_MetaSolver * sbmc\_MS\_create(BeEnc\_ptr be\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a meta solver wrapper]

  Description        [Creates a meta solver wrapper]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_destroy(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destroy a meta solver wrapper]

  Description        [Destroy a meta solver wrapper]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_create\_volatile\_group(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create the volatile group in the meta solver wrapper]

  Description        [Create the volatile group in the meta solver wrapper. Use
  of the volatile group is not forced]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_destroy\_volatile\_group(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destroy the volatile group of the meta solver wrapper and
  force use of the permanent one]

  Description        [Destroy the volatile group of the meta solver wrapper and
  force use of the permanent one]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_switch\_to\_permanent\_group(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Force use of the permanent group of
  the meta solver wrapper]

  Description        [Force use of the permanent group of
  the meta solver wrapper. Volatile group is left in place, if existing]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_switch\_to\_volatile\_group(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Force use of the volatile group of
  the meta solver wrapper]

  Description        [Force use of the volatile group of
  the meta solver wrapper. The volatile group must have been previously
  created]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_goto\_permanent\_group(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destroy the volatile group of the meta solver wrapper]

  Description        [Destroy the volatile group of the meta solver
  wrapper, thus only considering the permanent group.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_goto\_volatile\_group(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create and force use of the volatile group of
  the meta solver wrapper]

  Description        [Create and force use of the volatile group of
  the meta solver wrapper.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_force\_true(sbmc\_MetaSolver *ms, be\_ptr be\_constraint)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Forces a BE to be true in the solver.]

  Description        [Forces a BE to be true in the solver. The BE
  converted to CNF, the CNF is then forced in the group in use,
  i.e. in the permanent or in the volatile group.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_MS\_force\_constraint\_list(sbmc\_MetaSolver *ms, lsList constraints)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Forces a list of BEs to be true in the solver.]

  Description        [Forces a list of BEs to be true in the
  solver. Each is converted to CNF, the CNF is then forced in the
  group in use, i.e. in the permanent or in the volatile group.]

  SideEffects        [None]

  SeeAlso            [sbmc_MS_force_true]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sbmc\_MS\_solve(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Solves all groups belonging to the solver and
  returns the flag.]

  Description        [Solves all groups belonging to the solver and
  returns the flag.]

  SideEffects        [None]

  SeeAlso            [SatSolver_solve_all_groups]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sbmc\_MS\_solve\_assume(sbmc\_MetaSolver *ms, Slist\_ptr assumptions)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Solves all groups belonging to the solver assuming
  the CNF assumptions and returns the flag.]

  Description        [Solves all groups belonging to the solver assuming
  the CNF assumptions and returns the flag.]

  SideEffects        [None]

  SeeAlso            [SatSolver_solve_all_groups_assume]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolver\_ptr sbmc\_MS\_get\_solver(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the underlying solver]

  Description [Returns the solver]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sbmc\_MS\_get\_conflicts(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the underlying solver]

  Description [Returns the solver]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sbmc\_MS\_get\_model(sbmc\_MetaSolver *ms)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the model (of previous solving)]

  Description [ The previous solving call should have returned SATISFIABLE.
  The returned list is a list of values in dimac form (positive literal
  is included as the variable index, negative literal as the negative
  variable index, if a literal has not been set its value is not included).

  Returned list must be NOT destroyed.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_add\_loop\_variable(BeFsm\_ptr be\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Declares a new layer to contain the loop variable.]

  Description [Declares a new layer to contain the loop variable.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_remove\_loop\_variable(BeFsm\_ptr be\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Remove the new layer to contain the loop variable.]

  Description [Remove the new layer to contain the loop variable.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sbmc\_loop\_var\_name\_set(node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the name of the loop variable.]

  Description [Sets the name of the loop variable.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr sbmc\_loop\_var\_name\_get(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the name of the loop variable.]

  Description [Gets the name of the loop variable.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcBmcInc.c}
		
	\texttt{int Bmc\_GenSolveLtlInc(Prop\_ptr ltlprop, const int k, const int relative\_loop, const boolean must\_inc\_length)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Solves LTL problem the same way as the original
  Bmc_GenSolveLtl but just adds BE representing the path incrementaly.]

  Description        []

  SideEffects        []

  SeeAlso            [Bmc_GenSolve_Action]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_GenSolveInvarZigzag(Prop\_ptr invarprop, const int max\_k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Solve an INVARSPEC problems with algorithm
  ZigZag]

  Description        [The function will run not more then max_k transitions,
  then if the problem is not proved the function just returns 0]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_GenSolveInvarDual(Prop\_ptr invarprop, const int max\_k, bmc\_invar\_closure\_strategy strategy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Solve an INVARSPEC problems wiht algorithm Dual]

  Description        [The function tries to solve the problem
  with not more then max_k transitions. If the problem is not
  solved after max_k transition then the function returns 0.

  If the no_closure flag is true, only the \"base\" encoding is used
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_GenSolveInvarFalsification(Prop\_ptr invarprop, const int max\_k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Solve an INVARSPEC problems wiht algorithm Fasification]

  Description        [The function tries to solve the problem
  with not more then max_k transitions. If the problem is not
  solved after max_k transition then the function returns 0.

  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{inline static Be\_Cnf\_ptr bmc\_add\_be\_into\_solver(SatSolver\_ptr solver, SatSolverGroup group, be\_ptr prob, int polarity, BeEnc\_ptr be\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Converts Be into CNF, and adds it into a group of a solver.]

  Description        [Outputs into nusmv_stdout the total time
  of conversion and adding BE to solver. It is resposibility of the invoker
  to destroy returned CNF (with Be_Cnf_Delete)]

  SideEffects        [creates an instance of CNF formula. (do not forget to
  delete it)]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{inline static void bmc\_add\_be\_into\_solver\_positively(SatSolver\_ptr solver, SatSolverGroup group, be\_ptr prob, BeEnc\_ptr be\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Converts Be into CNF, and adds it into a group of a solver,
  sets polarity to 1, and then destroys the CNF.]

  Description        [Outputs into nusmv_stdout the total time
  of conversion, adding, setting polarity and destroying BE. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmc\_build\_uniqueness(const BeFsm\_ptr be\_fsm, const lsList state\_vars, const int init\_state, const int last\_state)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the uniqueness contraint for dual and zigzag
                      algorithms]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcBmcNonInc.c}
		
	\texttt{int Bmc\_GenSolveLtl(Prop\_ptr ltlprop, const int k, const int relative\_loop, const boolean must\_inc\_length, const boolean must\_solve, const Bmc\_DumpType dump\_type, const char* dump\_fname\_template)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a LTL property generates and solve the problems
   for all Ki (k_min<=i<=k_max). If bIncreaseK is 0 then k_min==k_max==k and
   only one problem is generated. If bIncreaseK is 1 then k_min == 0 and
   k_max == k.
   Each problem Ki takes into account of all possible loops from k_min to Ki
   if loopback is '*' (BMC_ALL_LOOPS). <BR>
   Also see the Bmc_GenSolve_Action possible values. Returns 1 if solver could
   not be created, 0 if everything went smooth]

   Description [Returns 1 if solver could not be created, 0 if
   everything went smooth]

   SideEffects        []

   SeeAlso            [Bmc_GenSolve_Action]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_GenSolveInvar(Prop\_ptr invarprop, const boolean must\_solve, const Bmc\_DumpType dump\_type, const char* dump\_fname\_template)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Generates DIMACS version and/or solve and INVARSPEC
   problems]

   Description [Returns 1 if solver could not be created, 0 if
   everything went smooth]

   SideEffects        []

   SeeAlso            [Bmc_GenSolvePbs]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Bmc\_result Bmc\_induction\_algorithm(BeFsm\_ptr be\_fsm, node\_ptr binvarspec, Trace\_ptr* trace, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Apply Induction algorithm on th given FSM to
                       check the given NNFd invarspec]

   Description        [Returns BMC_TRUE if the property is true, BMC_UNKNOWN
                       if the induction failed, if the induction fails and the
                       counter example option is activated, then a trace is
                       registered in the global trace manager and its index is
                       stored in trace_index parameter.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_GenSolveInvar\_EenSorensson(Prop\_ptr invarprop, const int max\_k, const Bmc\_DumpType dump\_type, const char* dump\_fname\_template, boolean use\_extra\_step)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Solve and INVARSPEC problems by using
   Een/Sorensson method non-incrementally]

   Description        [Returns 1 if solver could not be created, 0 if
   everything went smooth]

   SideEffects        []

   SeeAlso            [Bmc_GenSolvePbs]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Bmc\_result Bmc\_een\_sorensson\_algorithm\_without\_dump(BeFsm\_ptr be\_fsm, BoolSexpFsm\_ptr bool\_fsm, node\_ptr binvarspec, int max\_k, boolean use\_extra\_step, Trace\_ptr* trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Solve and INVARSPEC problems by using
   Een/Sorensson method non-incrementally and without dumping the problem]

   Description        [Returns a Bmc_result according to the result of the
                       checking]

   SideEffects        []

   SeeAlso            [Bmc_GenSolvePbs]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Bmc\_result Bmc\_een\_sorensson\_algorithm(BeFsm\_ptr be\_fsm, BoolSexpFsm\_ptr bool\_fsm, node\_ptr binvarspec, int max\_k, const Bmc\_DumpType dump\_type, const char* dump\_fname\_template, Prop\_ptr pp, boolean print\_steps, boolean use\_extra\_step, Trace\_ptr* trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Solve and INVARSPEC problems by using
   Een/Sorensson method non-incrementally]

   Description        [Returns a Bmc_result according to the result of the
                       checking]

   SideEffects        []

   SeeAlso            [Bmc_GenSolvePbs]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcCheck.c}
		
	\texttt{node\_ptr Bmc\_CheckFairnessListForPropositionalFormulae(node\_ptr wffList)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Helper function to simplify calling to 
  'bmc_check_wff_list' for searching of propositional wff only.  
  Returns a new list of wffs which contains legal wffs only]

  Description        []
  SideEffects        []

  SeeAlso            [bmc_check_wff_list]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_WffListMatchProperty(node\_ptr wffList, BMC\_PF\_MATCH pCheck, void* pCheckOptArgument, int iMaxMatches, unsigned int* aiMatchedIndexes, BMC\_PF\_MATCH\_ANSWER pAnswer, void* pAnswerOptArgument)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [For each element belonging to a given list of wffs,
  calls the given matching function. If function matches, calls given
  answering function]

  Description        [This is a generic searching function for a property
  across a list of wffs. <i>Please note that searching is specific for a list
  of wffs, but the searching semantic and behaviour are generic and
  customizable.</i><br>
  Searching may be stopped after the Nth match, or can be continued till all
  list elements have been checked (specify <B>-1</B> in this case).
  In any case searching cannot be carried out over the <I>MAX_MATCHES</I>
  value.<br><br>
  <TABLE BORDER>
  <CAPTION> <B>Arguments:</B> </CAPTION>
  <TR> <TH> Parameter name </TH>  <TH> Description </TH> </TR>
  <TR> <TD> wffList </TD>         <TD> A list of wffs to iterate in </TD> </TR>
  <TR> <TD> pCheck  </TD>         <TD> Pointer to matching function.
   The checking function type is <B>BMC_PF_MATCH</B>, and has three
   parameters: <BR>
   <B> wff </B> the formula to check for <BR>
   <B> index </B> index of wff into list <BR>
   <B> pOpt </B> generic pointer to custom structure (optional) </TD> </TR>

  <TR> <TD> pCheckOptArgument </TD> <TD> Argument passed to pCheck
  (specify <B>NULL</B> if you do not use it.) </TD> </TR>

  <TR> <TD> iMaxMatches </TD>       <TD> Maximum number of matching to be
  found before return. This must be less of <I>MAX_MATCHES</I>.<BR>
  Specify <B>-1</B> to iterate across the entire list. </TD> </TR>

  <TR> <TD> aiMatchedIndexes </TD>  <TD> Optional <B>int</B> array which
  will contain all match indexes. <BR>
  Specify <B>NULL</B> if you do not need this functionality.
  Array size must be less of <I>MAX_MATCHES</I>. </TD> </TR>

  <TR> <TD> pAnswer </TD>           <TD> Pointer to answer function
  of type <B>BMC_PF_MATCH_ANSWER</B>. This function is called everytime
  a match is found. <BR>
  Specify <B>NULL</B> if you do not need for this functionality.
  The answer function has the following prototype: <BR>
  <I>void answer(node_ptr wff, int index, void* pOpt)</I> <BR>
  where:<BR>

  <B> wff </B> the formula that matches the criteria <BR>
  <B> index </B> is the index of wff into the list
  <B> pOpt  </B> pointer to generic & customizable structure
  (see <I>pAnswerOptArgument</I> below)

  <B> pAnswerOptArgument </B> optional parameter for pAnswer function,
  in order to ensure more flexibility. Specify <B>NULL</B> if you do not need
  for this functionality.) </TD> </TR>
  </TABLE>]

  SideEffects        [Given aiMatchedIndexes array changes if at least one
  match has found out]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Bmc\_IsPropositionalFormula(node\_ptr wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a wff returns 1 if wff is a propositional formula,
  zero (0) otherwise.]

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bmc\_is\_propositional\_formula\_aux(node\_ptr wff, int index, void* pOpt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Useful wrapper for
  Bmc_CheckFairnessListForPropositionalFormulae]

  Description        [Wrapper that makes
  Bmc_CheckFairnessListForPropositionalFormulae able to call
  Bmc_IsPropositionalFormula with a mode generic interface.
  Arguments 2 and 3 are practically unused, supplied to respect the generic
  interface only.]

  SideEffects        []

  SeeAlso            [Bmc_CheckFairnessListForPropositionalFormulae]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bmc\_check\_if\_wff\_is\_valid(node\_ptr wff, int index, void* \_aiIndexes)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [private service for
  Bmc_CheckFairnessListForPropositionalFormulae]

  Description        []

  SideEffects        []

  SeeAlso            [Bmc_CheckFairnessListForPropositionalFormulae]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_add\_valid\_wff\_to\_list(node\_ptr wff, int index, void* \_pList)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [private service for
  Bmc_CheckFairnessListForPropositionalFormulae]

  Description        []

  SideEffects        []

  SeeAlso            [Bmc_CheckFairnessListForPropositionalFormulae]
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcCmd.c}
		
	\texttt{int Bmc\_CommandBmcSetup(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the bmc sub-system, and builds the model in
  a Boolean Expression format]

  Description        []

  SideEffects        [Overall the bmc system]

  SeeAlso            []

  CommandName        [bmc_setup]

  CommandSynopsis    [Builds the model in a Boolean Epression format.]

  CommandArguments   [\[-h\] | \[-f\]]

  CommandDescription [You must call this command before use any other
  bmc-related command. Only one call per session is required.<BR>
  Command options:<p>
  <dl>
    <dt> <tt>-f </tt>
    <dd> Forces the BMC model to be built.
  </dl>]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcSetup (void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for Bmc_CommandBmcSetup]

  Description        []

  SideEffects        []

  SeeAlso            [Bmc_CommandBmcSetup]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandBmcSimulate(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Bmc_CommandBmcSimulate generates a trace of the problem
  represented from the simple path from 0 (zero) to k]

  Description        [Bmc_CommandBmcSimulate does not require a specification
  to build the problem, because only the model is used to build it.]

  SideEffects        [None]

  SeeAlso            []

  CommandName        [bmc_simulate]

  CommandSynopsis    [Generates a trace of the model from 0 (zero) to k]

  CommandArguments   [\[-h\] \[-p | -v\] \[-r\]
  [\[-c "constraints"\] | \[-t "constraints"\] ] \[-k steps\]
  ]

  CommandDescription [bmc_simulate does not require a specification
  to build the problem, because only the model is used to build it.
  The problem length is represented by the <i>-k</i> command parameter,
  or by its default value stored in the environment variable
  <i>bmc_length</i>.<BR>
  Command Options:<p>
  <dl>
    <dt> <tt>-p</tt>
       <dd> Prints current generated trace (only those variables whose value
       changed from the previous state).
    <dt> <tt>-v</tt>
       <dd> Verbosely prints current generated trace (changed and unchanged
       state variables).
    <dt> <tt>-r</tt>
       <dd> Picks a state from a set of possible future states in a random way.
    <dt> <tt>-c "constraints"</tt>
       <dd> Performs a simulation in which computation is restricted
       to states satisfying those <tt>constraints</tt>. The desired
       sequence of states could not exist if such constraints were too
       strong or it may happen that at some point of the simulation a
       future state satisfying those constraints doesn't exist: in
       that case a trace with a number of states less than
       <tt>steps</tt> trace is obtained. The expression cannot contain
       next operators, and is automatically shifted by one state in
       order to constraint only the next steps
    <dt> <tt>-t "constraints"</tt>
       <dd> Performs a simulation in which computation is restricted
       to states satisfying those <tt>constraints</tt>. The desired
       sequence of states could not exist if such constraints were too
       strong or it may happen that at some point of the simulation a
       future state satisfying those constraints doesn't exist: in
       that case a trace with a number of states less than
       <tt>steps</tt> trace is obtained.  The expression can contain
       next operators, and is NOT automatically shifted by one state
       as done with option -c
    <dt> <tt>-k steps</tt>
       <dd> Maximum length of the path according to the constraints.
       The length of a trace could contain less than <tt>steps</tt> states:
       this is the case in which simulation stops in an intermediate
       step because it may not exist any future state satisfying those
       constraints.
    </dl>
  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcSimulate (void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for UsageBmcSimulate]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandBmcSimulate]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandBmcIncSimulate(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Bmc_CommandBmcIncSimulate does incremental
  simulation of the model starting from an initial state.]

  Description        [Bmc_CommandBmcIncSimulate does incremental
  simulation of the model starting from an initial state.]

  SideEffects        [None]

  SeeAlso            []

  CommandName        [bmc_inc_simulate]

  CommandSynopsis    [Incrementally generates a trace of the model
  performing a given number of steps.]

  CommandArguments   [\[-h\] \[-p | -v\] \[-r\]
  [\[-c "constraints"\] | \[-t "constraints"\] ] \[-k steps\]
  ]

  CommandDescription [bmc_inc_simulate performs incremental simulation
  of the model. If no length is specified with <i>-k</i> command
  parameter, then the number of steps of simulation to perform is
  taken from the value stored in the environment variable
  <i>bmc_length</i>.<BR>
  Command Options:<p>
  <dl>
    <dt> <tt>-p</tt>
       <dd> Prints current generated trace (only those variables whose value
       changed from the previous state).
    <dt> <tt>-v</tt>
       <dd> Verbosely prints current generated trace (changed and unchanged
       state variables).
    <dt> <tt>-r</tt>
       <dd> Picks a state from a set of possible future states in a random way.
    <dt> <tt>-i</tt>
       <dd> Enters simulation's interactive mode.
    <dt> <tt>-a</tt>
       <dd> Displays all the state variables (changed and unchanged)
            in the interactive session
    <dt> <tt>-c "constraints"</tt>
       <dd> Performs a simulation in which computation is restricted
       to states satisfying those <tt>constraints</tt>. The desired
       sequence of states could not exist if such constraints were too
       strong or it may happen that at some point of the simulation a
       future state satisfying those constraints doesn't exist: in
       that case a trace with a number of states less than
       <tt>steps</tt> trace is obtained. The expression cannot contain
       next operators, and is automatically shifted by one state in
       order to constraint only the next steps
    <dt> <tt>-t "constraints"</tt>
       <dd> Performs a simulation in which computation is restricted
       to states satisfying those <tt>constraints</tt>. The desired
       sequence of states could not exist if such constraints were too
       strong or it may happen that at some point of the simulation a
       future state satisfying those constraints doesn't exist: in
       that case a trace with a number of states less than
       <tt>steps</tt> trace is obtained.  The expression can contain
       next operators, and is NOT automatically shifted by one state
       as done with option -c
    <dt> <tt>-k steps</tt>
       <dd> Maximum length of the path according to the constraints.
       The length of a trace could contain less than <tt>steps</tt> states:
       this is the case in which simulation stops in an intermediate
       step because it may not exist any future state satisfying those
       constraints.
    </dl>
  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcIncSimulate (void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for UsageBmcIncSimulate]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandBmcIncSimulate]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandBmcPickState(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Picks a state from the set of initial states]

  CommandName        [bmc_pick_state]

  CommandSynopsis    [Picks a state from the set of initial states]

  CommandArguments   [\[-h\] \[-v\] \] \ [-c "constraint" | -s trace.state\] \[-r\] \[-a \[-i\]\]]

  CommandDescription [

  Chooses an element from the set of initial states, and makes it the
  <tt>current state</tt> (replacing the old one). The chosen state is
  stored as the first state of a new trace ready to be lengthened by
  <tt>steps</tt> states by the <tt>bmc_simulate</tt> or
  <tt>bmc_inc_simulate</tt> commands. A constraint can be provided to
  restrict the set of candidate states. <p>

  Command Options:<p>
  <dl>
    <dt> <tt>-v</tt>
       <dd> Verbosely prints out chosen state (all state variables, otherwise
       it prints out only the label <tt>t.1</tt> of the state chosen, where
       <tt>t</tt> is the number of the new trace, that is the number of
       traces so far generated plus one).
    <dt> <tt>-r</tt>
       <dd> Randomly picks a state from the set of initial states.
    <dt> <tt>-i</tt>
       <dd> Enters simulation's interactive mode.
    <dt> <tt>-a</tt>
       <dd> Displays all the state variables (changed and unchanged)
            in the interactive session
    <dt> <tt>-c "constraint"</tt>
       <dd> Uses <tt>constraint</tt> to restrict the set of initial states
       in which the state has to be picked.
    <dt> <tt>-s trace.state</tt>
       <dd> Picks state from trace.state label. A new simulation trace will
       be created by copying prefix of the source trace up to specified state.
  </dl> ]

  SideEffects [The state chosen is stored in the traces_hash table as
  the first state of a new trace]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcPickState(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for UsageBmcPickState]

  Description        []

  SideEffects        [None]

  SeeAlso            [CommandBmcPickState]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandBmcSimulateCheckFeasibleConstraints(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks feasibility of a list of constraints for the
  simulation]

  CommandName        [bmc_simulate_check_feasible_constraints]

  CommandSynopsis [Performs a feasibility check on the list of given
  constraints. Constraints that are found to be feasible can be safely
  assumed not to cause deadlocks if used in the following step of
  incremental simulation.]

  CommandArguments   [\[-h | -q\] \[-c "formula"\]* ]

  CommandDescription [This command generates feasibility problems for
  each constraint. Every constraint is checked against current state
  and FSM's transition relation, in order to exclude the possibility
  of deadlocks. Constraints found to be feasible can be safely assumed
  not to cause deadlocks if used in the following step of incremental
  simulation.<BR>
  <p>
    Command options:<p>
    <dl>
    <dt> <tt>-q</tt>
       <dd> Enables quiet mode. For each analyzed constraint "0" is
       printed if the constraint is found to be unfeasible, "1" is
       printed otherwise. <BR>
    <dt> <tt>-c "formula"</tt>
       <dd> Provide a constraint as a <tt>formula</tt> specified on
            the command-line. This option can be specified multiple
            times, in order to analyze a list of constraints.<BR>
  </dl>
  ]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcSimulateCheckFeasibleConstraints(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for
                      UsageBmcSimulateCheckFeasibleConstraints]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandSimulateCheckFeasibleConstraints]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandGenLtlSpecBmc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates length_max+1 problems iterating the problem
  bound from zero to length_max, and dumps each problem to a dimacs file]

  Description        [Each problem is dumped for the given LTL specification,
  or for all LTL specifications if no formula is given.
  Generation parameters are the maximum bound and the loopback values. <BR>
  After command line processing it calls the function Bmc_GenSolveLtl
  to generate and dump all problems from zero to k.]

  SideEffects        [Property database may change]

  SeeAlso            [Bmc_CommandGenLtlSpecBmcOnePb, Bmc_GenSolveLtl]

  CommandName        [gen_ltlspec_bmc]

  CommandSynopsis    [Dumps into one or more dimacs files the given LTL
  specification, or all LTL specifications if no formula is given.
  Generation and dumping parameters are the maximum bound and the loopback
  values]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\]
  \[-k max_length\] \[-l loopback\] \[-o filename\]]

  CommandDescription [  This command generates one or more problems, and
  dumps each problem into a dimacs file. Each problem is related to a specific
  problem bound, which increases from zero (0) to the given maximum problem
  bound. In this short description "<i>length</i>" is the bound of the
  problem that system is going to dump out. <BR>
  In this context the maximum problem bound is represented by the
  <i>max_length</i> parameter, or by its default value stored in the
  environment variable <i>bmc_length</i>.<BR>
  Each dumped problem also depends on the loopback you can explicitly
  specify by the <i>-l</i> option, or by its default value stored in the
  environment variable <i>bmc_loopback</i>. <BR>
  The property to be checked may be specified using the <i>-n idx</i>,
  the <i>-p "formula"</i> or the <i>-P "name"</i> options. <BR>
  You may specify dimacs file name by using the option <i>-o "filename"</i>,
  otherwise the default value stored in the environment variable
  <i>bmc_dimacs_filename</i> will be considered.<BR>
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid LTL specification
       formula actually located in the properties database. <BR>
       The validity of <i>index</i> value is checked out by the system.
    <dt> <tt>-p "formula \[IN context\]"</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTLSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>max_length</i></tt>
       <dd> <i>max_length</i> is the maximum problem bound used when
       increasing problem bound starting from zero. Only natural number are
       valid values for this option. If no value is given the environment
       variable <i>bmc_length</i> value is considered instead.
    <dt> <tt>-l <i>loopback</i></tt>
       <dd> <i>loopback</i> value may be: <BR>
       - a natural number in (0, <i>max_length-1</i>). Positive sign ('+') can
       be also used as prefix of the number. Any invalid combination of bound
       and loopback will be skipped during the generation and
       dumping process.<BR>
       - a negative number in (-1, -<i>bmc_length</i>). In this case
       <i>loopback</i> is considered a value relative to <i>max_length</i>.
       Any invalid combination of bound and loopback will be skipped during
       the generation process.<BR>
       - the symbol 'X', which means "no loopback" <BR>
       - the symbol '*', which means "all possible loopback from zero to
       <i>length-1</i>"
    <dt> <tt>-o <i>filename</i></tt>
       <dd> <i>filename</i> is the name of dumped dimacs files, without
       extension. <BR>
       If this options is not specified, variable <i>bmc_dimacs_filename</i>
       will be considered. The file name string may contain special symbols
       which will be macro-expanded to form the real file name.
       Possible symbols are: <BR>
       - @F: model name with path part <BR>
       - @f: model name without path part <BR>
       - @k: current problem bound <BR>
       - @l: current loopback value <BR>
       - @n: index of the currently processed formula in the properties
       database <BR>
       - @@: the '@' character
  </dl>]


******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcGenLtlSpec(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for command gen_ltlspec_bmc]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandGenLtlSpecBmc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandGenLtlSpecBmcOnePb(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates only one problem with fixed bound and
  loopback, and dumps the problem to a dimacs file. The single problem
  is dumped for the given LTL specification, or for all LTL
  specifications if no formula is given]

  Description        [After command line processing it calls
  the function Bmc_GenSolveLtl to generate and dump the single problem.]

  SideEffects        [Property database may change]

  SeeAlso            [Bmc_CommandGenLtlSpecBmc, Bmc_GenSolveLtl]

  CommandName        [gen_ltlspec_bmc_onepb]

  CommandSynopsis    [Dumps into one dimacs file the problem generated for
  the given LTL specification, or for all LTL specifications if no formula
  is explicitly given.
  Generation and dumping parameters are the problem bound and the loopback
  values]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\] \[-k length\]
  \[-l loopback\] \[-o filename\]]

  CommandDescription [ As the <i>gen_ltlspec_bmc</i> command, but it generates
  and dumps only one problem given its bound and loopback. <BR>
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid LTL specification
       formula actually located in the properties database. <BR>
       The validity of <i>index</i> value is checked out by the system.
    <dt> <tt>-p "formula \[IN context\]"</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTLSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>length</i></tt>
       <dd> <i>length</i> is the single problem bound used to generate and
       dump it. Only natural number are valid values for this option.
       If no value is given the environment variable <i>bmc_length</i>
       is considered instead.
    <dt> <tt>-l <i>loopback</i></tt>
       <dd> <i>loopback</i> value may be: <BR>
       - a natural number in (0, <i>length-1</i>). Positive sign ('+') can
       be also used as prefix of the number. Any invalid combination of length
       and loopback will be skipped during the generation and dumping
       process.<BR>
       - a negative number in (-1, -<i>length</i>).
       Any invalid combination of length and loopback will be skipped during
       the generation process.<BR>
       - the symbol 'X', which means "no loopback" <BR>
       - the symbol '*', which means "all possible loopback from zero to
       <i>length-1</i>"
    <dt> <tt>-o <i>filename</i></tt>
       <dd> <i>filename</i> is the name of the dumped dimacs file, without
       extension. <BR>
       If this
       options is not specified, variable <i>bmc_dimacs_filename</i> will be
       considered. The file name string may contain special symbols which
       will be macro-expanded to form the real file name.
       Possible symbols are: <BR>
       - @F: model name with path part <BR>
       - @f: model name without path part <BR>
       - @k: current problem bound <BR>
       - @l: current loopback value <BR>
       - @n: index of the currently processed formula in the properties
       database <BR>
       - @@: the '@' character
  </dl>]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcGenLtlSpecOnePb(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for command gen_ltlspec_bmc_onepb]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandGenLtlSpecBmcOnePb]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandCheckLtlSpecBmc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks the given LTL specification, or all LTL
  specifications in the properties database if no formula is given]

  Description        [After command line processing this function calls
  the Bmc_GenSolveLtl to generate and solve all problems from 0 to k.
  Parameters are the maximum length and the loopback values.]

  SideEffects        [Properties database may change]

  SeeAlso            [Bmc_CommandCheckLtlSpecBmcOnePb, Bmc_GenSolveLtl]

  CommandName        [check_ltlspec_bmc]

  CommandSynopsis    [Checks the given LTL specification, or all LTL
  specifications if no formula is given. Checking parameters are the maximum
  length and the loopback values]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\]
  \[-k max_length\] \[-l loopback\] \[-o filename\]]

  CommandDescription [
  This command generates one or more problems, and calls
  SAT solver for each one. Each problem is related to a specific problem
  bound, which increases from zero (0) to the given maximum problem
  length. Here "<i>length</i>" is the bound of the problem that system
  is going to generate and/or solve. <BR>
  In this context the maximum problem bound is represented by the
  <i>-k</i> command parameter, or by its default value stored in the
  environment variable <i>bmc_length</i>.<BR>
  The single generated problem also depends on the "<i>loopback</i>"
  parameter you can explicitly specify by the <i>-l</i> option, or by its
  default value stored in the environment variable <i>bmc_loopback</i>. <BR>
  The property to be checked may be specified using the <i>-n idx</i>,
  the <i>-p "formula"</i> or the <i>-P "name"</i> options. <BR>
  If you need to generate a dimacs dump file of all generated problems, you
  must use the option <i>-o "filename"</i>. <BR>
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid LTL specification
       formula actually located in the properties database. <BR>
    <dt> <tt>-p "formula" \[IN context\]</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTLSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>max_length</i></tt>
       <dd> <i>max_length</i> is the maximum problem bound must be reached.
       Only natural number are valid values for this option. If no value
       is given the environment variable <i>bmc_length</i> is considered
       instead.
    <dt> <tt>-l <i>loopback</i></tt>
       <dd> <i>loopback</i> value may be: <BR>
       - a natural number in (0, <i>max_length-1</i>). Positive sign ('+') can
       be also used as prefix of the number. Any invalid combination of length
       and loopback will be skipped during the generation/solving process.<BR>
       - a negative number in (-1, -<i>bmc_length</i>). In this case
       <i>loopback</i> is considered a value relative to <i>max_length</i>.
       Any invalid combination of length and loopback will be skipped
       during the generation/solving process.<BR>
       - the symbol 'X', which means "no loopback" <BR>
       - the symbol '*', which means "all possible loopback from zero to
       <i>length-1</i>"
    <dt> <tt>-o <i>filename</i></tt>
       <dd> <i>filename</i> is the name of the dumped dimacs file, without
       extension. <BR>
       It may contain special symbols which will be macro-expanded to form
       the real file name. Possible symbols are: <BR>
       - @F: model name with path part <BR>
       - @f: model name without path part <BR>
       - @k: current problem bound <BR>
       - @l: current loopback value <BR>
       - @n: index of the currently processed formula in the properties
       database <BR>
       - @@: the '@' character
  </dl>
  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcCheckLtlSpec(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for command check_ltlspec_bmc]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandCheckLtlSpecBmc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandCheckLtlSpecBmcOnePb(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks the given LTL specification, or all LTL
  specifications if no formula is given. Checking parameters are the problem
  bound and the loopback values]

  Description        [After command line processing this function calls
  the Bmc_GenSolveLtl which generates and solve the singleton
  problem with bound k and loopback l. <BR>
  ]

  SideEffects        [Property database may change]

  SeeAlso            [Bmc_CommandCheckLtlSpecBmc, Bmc_GenSolveLtl]

  CommandName        [check_ltlspec_bmc_onepb]

  CommandSynopsis    [Checks the given LTL specification, or all LTL
  specifications if no formula is given. Checking parameters are the single
  problem bound and the loopback values]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\]
  \[-k length\] \[-l loopback\] \[-o filename\]]

  CommandDescription [As command check_ltlspec_bmc but it produces only one
  single problem with fixed bound and loopback values, with no iteration
  of the problem bound from zero to max_length. <BR>
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid LTL specification
       formula actually located in the properties database. <BR>
       The validity of <i>index</i> value is checked out by the system.
    <dt> <tt>-p "formula \[IN context\]"</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTLSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>length</i></tt>
       <dd> <i>length</i> is the problem bound used when generating the
       single problem. Only natural number are valid values for this option.
       If no value is given the environment variable <i>bmc_length</i> is
       considered instead.
    <dt> <tt>-l <i>loopback</i></tt>
       <dd> <i>loopback</i> value may be: <BR>
       - a natural number in (0, <i>max_length-1</i>). Positive sign ('+') can
       be also used as prefix of the number. Any invalid combination of length
       and loopback will be skipped during the generation/solving process.<BR>
       - a negative number in (-1, -<i>bmc_length</i>). In this case
       <i>loopback</i> is considered a value relative to <i>length</i>.
       Any invalid combination of length and loopback will be skipped
       during the generation/solving process.<BR>
       - the symbol 'X', which means "no loopback" <BR>
       - the symbol '*', which means "all possible loopback from zero to
       <i>length-1</i>"
    <dt> <tt>-o <i>filename</i></tt>
       <dd> <i>filename</i> is the name of the dumped dimacs file, without
       extension.<BR>
       It may contain special symbols which will be macro-expanded to form
       the real file name. Possible symbols are: <BR>
       - @F: model name with path part <BR>
       - @f: model name without path part <BR>
       - @k: current problem bound <BR>
       - @l: current loopback value <BR>
       - @n: index of the currently processed formula in the properties
       database <BR>
       - @@: the '@' character
  </dl>]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcCheckLtlSpecOnePb(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for command check_ltlspec_bmc_onepb]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandCheckLtlSpecBmcOnePb]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandCheckLtlSpecBmcInc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Checks the given LTL specification, or all LTL
  specifications in the properties database if no formula is given,
  using incremental algorithms]

  Description        [Parameters are the maximum length and the loopback
  values. The function is compiled only if there is at least
  one incremental SAT solver]

  SideEffects        [Properties database may change]

  SeeAlso            [Bmc_CommandCheckLtlSpecBmcOnePb, Bmc_CommandCheckLtlSpecBmc]

  CommandName        [check_ltlspec_bmc_inc]

  CommandSynopsis    [Checks the given LTL specification, or all LTL
  specifications if no formula is given, using incremental algorithms.
  Checking parameters are the maximum length and the loopback values]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\]
  \[-k max_length\] \[-l loopback\] ]

  CommandDescription [
  This command generates one or more problems, and calls (incremental)
  SAT solver for each one. Each problem is related to a specific problem
  bound, which increases from zero (0) to the given maximum problem
  length. Here "<i>length</i>" is the bound of the problem that system
  is going to generate and/or solve. <BR>
  In this context the maximum problem bound is represented by the
  <i>-k</i> command parameter, or by its default value stored in the
  environment variable <i>bmc_length</i>.<BR>
  The single generated problem also depends on the "<i>loopback</i>"
  parameter you can explicitly specify by the <i>-l</i> option, or by its
  default value stored in the environment variable <i>bmc_loopback</i>. <BR>
  The property to be checked may be specified using the <i>-n idx</i>,
  the <i>-p "formula"</i> or the <i>-P "name"</i> options. <BR>
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid LTL specification
       formula actually located in the properties database. <BR>
    <dt> <tt>-p "formula" \[IN context\]</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTLSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>max_length</i></tt>
       <dd> <i>max_length</i> is the maximum problem bound must be reached.
       Only natural number are valid values for this option. If no value
       is given the environment variable <i>bmc_length</i> is considered
       instead.
    <dt> <tt>-l <i>loopback</i></tt>
       <dd> <i>loopback</i> value may be: <BR>
       - a natural number in (0, <i>max_length-1</i>). Positive sign ('+') can
       be also used as prefix of the number. Any invalid combination of length
       and loopback will be skipped during the generation/solving process.<BR>
       - a negative number in (-1, -<i>bmc_length</i>). In this case
       <i>loopback</i> is considered a value relative to <i>max_length</i>.
       Any invalid combination of length and loopback will be skipped
       during the generation/solving process.<BR>
       - the symbol 'X', which means "no loopback" <BR>
       - the symbol '*', which means "all possible loopback from zero to
       <i>length-1</i>"
  </dl>
  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcCheckLtlSpecInc(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for command check_ltlspec_bmc_inc]

  Description        [The function is compiled only if there is at least
  one incremental SAT solver.]

  SideEffects        [None]

  SeeAlso            [Bmc_CommandCheckLtlSpecBmc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandGenInvarBmc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates and dumps the problem for the given
  invariant or for all invariants if no formula is given. SAT solver is not
  invoked.]

  Description        [After command line processing calls Bmc_GenSolveInvar
  to dump the generated invariant problem.
  If you specify the <i>-o "filename"</i> option a dimacs file named
  "filename" will be created, otherwise the environment variable
  <i>bmc_invar_dimacs_filename</i> value will be considered.]

  SideEffects        [Property database may change]

  SeeAlso            [Bmc_GenSolveInvar]

  CommandName        [gen_invar_bmc]

  CommandSynopsis    [Generates the given invariant, or all
  invariants if no formula is given]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\]
  \[-o filename\]]

  CommandDescription [<p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid INVAR specification
       formula actually located in the properties database. <BR>
       The validity of <i>index</i> value is checked out by the system.
    <dt> <tt>-p "formula" \[IN context\]</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P "name"</tt>
       <dd> Checks the invariant property stored in the properties
       database with name "name"
    <dt> <tt>-o <i>filename</i></tt>
       <dd> <i>filename</i> is the name of the dumped dimacs file,
       without extension. <BR>
       If you
       do not use this option the dimacs file name is taken from the
       environment variable <i>bmc_invar_dimacs_filename</i>. <BR>
       File name may contain special symbols which will be macro-expanded
       to form the real dimacs file name. Possible symbols are: <BR>
       - @F: model name with path part <BR>
       - @f: model name without path part <BR>
       - @n: index of the currently processed formula in the properties
       database <BR>
       - @@: the '@' character
  </dl>]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcGenInvar(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for command gen_invar_bmc]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandGenInvarBmc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandCheckInvarBmc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates and solve the given invariant, or all
  invariants if no formula is given]

  Description        [After command line processing calls Bmc_GenSolveInvar
  to solve and eventually dump the generated invariant problem. If you specify
  the <i>-o "filename"</i> option a dimacs file will be generated, otherwise
  no dimacs dump will be performed]

  SideEffects        [Property database may change]

  SeeAlso            [Bmc_GenSolveInvar]

  CommandName        [check_invar_bmc]

  CommandSynopsis    [Generates and solve the given invariant, or all
  invariants if no formula is given]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\]
  \[-k max_length\] \[-a algorithm\] \[-o filename\] ]

  CommandDescription [<p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid INVAR specification
       formula actually located in the properties database. <BR>
       The validity of <i>index</i> value is checked out by the system.
    <dt> <tt>-p "formula \[IN context\]"</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the INVARSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>max_length</i></tt>
       <dd> (Use only when selected algorithm is een-sorensson).
            Use to specify the maximal deepth to be reached by the een-sorensson
            invariant checking algorithm. If not specified, the value assigned
            to the system variable <i>bmc_length</i> is taken.
    <dt> <tt>-a <i>algorithm</i></tt>
       <dd> Uses the specified algorithm to solve the invariant. If used, this
            option will override system variable <i>bmc_invar_alg</i>.
            At the moment, possible values are: "classic", "een-sorensson".
    <dt> <tt>-e</i></tt>
       <dd> Uses an additional step clause for algorithm "een-sorensson".</tt>
       <dd> <i>filename</i> is the name of the dumped dimacs file, without
       extension. <BR>
       It may contain special symbols which will be macro-expanded to form
       the real file name. Possible symbols are: <BR>
       - @F: model name with path part <BR>
       - @f: model name without path part <BR>
       - @n: index of the currently processed formula in the properties
       database <BR>
       - @@: the '@' character
  </dl>]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcCheckInvar(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for command check_invar_bmc]

  Description        []

  SideEffects        [None]

  SeeAlso            [Bmc_CommandCheckInvarBmc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_CommandCheckInvarBmcInc(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Solve the given invariant, or all
  invariants if no formula is given, using incremental algorithms.]

  Description        [The function is compiled only if there is at least
  one incremental SAT solver]

  SideEffects        [Property database may change]

  SeeAlso            [Bmc_CommandCheckInvarBmc]

  CommandName        [check_invar_bmc_inc]

  CommandSynopsis    [Generates and solve the given invariant, or all
  invariants if no formula is given]

  CommandArguments   [\[-h | -n idx | -p "formula" \[IN context\] | -P "name"\]
  \[-k max_length\] \[-a algorithm\] \[-s strategy\] ]

  CommandDescription [<p>
  Command options:<p>
  <dl>
    <dt> <tt>-n <i>index</i></tt>
       <dd> <i>index</i> is the numeric index of a valid INVAR specification
       formula actually located in the properties database. <BR>
       The validity of <i>index</i> value is checked out by the system.
    <dt> <tt>-p "formula \[IN context\]"</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the INVARSPEC property with name <tt>name</tt> in the property
            database.
    <dt> <tt>-k <i>max_length</i></tt>
       <dd> Use to specify the maximal depth to be reached by the incremental
            invariant checking algorithm. If not specified, the value assigned
            to the system variable <i>bmc_length</i> is taken.
    <dt> <tt>-a <i>algorithm</i></tt>
       <dd> Use to specify incremental invariant checking algorithm. Currently
            this can be one of the following values: dual, zigzag,
            falsification.
    <dt> <tt>-s <i>strategy</i></tt>
       <dd> Use to specify closure strategy (this currenly applies to dual
       algorithm only). This can be one of the following values: backward,
       forward.
  </dl>]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcCheckInvarInc(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for command check_invar_bmc_inc]

  Description        [The function is compiled only if there is at least
  one incremental SAT solver]

  SideEffects        [None]

  SeeAlso            [Bmc_CommandCheckInvarBmcInc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_check\_psl\_property(Prop\_ptr prop, boolean dump\_prob, boolean inc\_sat, boolean single\_prob, int k, int rel\_loop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Top-level function for bmc of PSL properties]

  Description        [The parameters are:
  - prop is the PSL property to be checked
  - dump_prob is true if the problem must be dumped as DIMACS file (default filename
  from system corresponding variable)
  - inc_sat is true if incremental sat must be used. If there is no
  support for inc sat, an internal error will occur.
  - single_prob is true if k must be not incremented from 0 to k_max
    (single problem)
  - k and rel_loop are the bmc parameters.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Outcome Bmc\_cmd\_options\_handling(int argc, char** argv, Prop\_Type prop\_type, /* output parameters: */ Prop\_ptr* res\_prop, int* res\_k, int* res\_l, char** res\_a, char** res\_s, char** res\_o, boolean* res\_e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Bmc commands options handling for commands (optionally)
  acceping options -k -l -o -a -n -p -P -e]

  Description [ Output variables called res_* are pointers to
  variables that will be changed if the user specified a value for the
  corresponding option. For example if the user specified "-k 2", then
  *res_k will be assigned to 2. The caller can selectively choose which
  options can be specified by the user, by passing either a valid pointer
  as output parameter, or NULL to disable the corresponding option.
  For example by passing NULL as actual parameter of res_l, option -l will
  be not accepted.

  If both specified, k and l will be checked for mutual consistency.
  Loop will contain a relative value, like the one the user specified.

  prop_type is the expected property type, if specified.

  All integers values will not be changed if the corresponding options
  had not be specified by the user, so the caller might assign them to
  default values before calling this function.

  All strings will be allocated by the function if the corresponding
  options had been used by the user. In this case it is responsability
  of the caller to free them. Strings will be assigned to NULL if the
  user had not specified any corresponding option.

  Returns OUTCOME_GENERIC_ERROR if an error has occurred;
  Returns OUTCOME_SUCCESS_REQUIRED_HELP if -h options had been specified;
  Returns OUTCOME_SUCCESS in all other cases.
  ]

  SideEffects        [Result parameters might change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_build\_master\_be\_fsm()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description [Creates the BE fsm from the Sexpr FSM. Currently the be
  enc is a singleton global private variable which is shared between
  all the BE FSMs. If not previoulsy committed (because a boolean
  encoder was not available at the time due to the use of coi) the
  determinization layer will be committed to the be encoder]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_check\_if\_model\_was\_built(FILE* err, boolean forced)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [A service for commands, to check if bmc
  has been built]

  Description [If coi is not enabled than bmc must be set up,
  otherwise it is only required bmc to have initialized. Returns 1 if
  the execution should be stopped, and prints an error message if it
  is the case (to the given optional file). If everything is fine,
  returns 0 and prints nothing. If 'forced' is true, than the model is
  required to be built even if coi is enabled, and a message is
  printed accordingly (used by the commands that always require that
  the model is built (e.g. bmc_simulate).]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcConv.c}
		
	\texttt{node\_ptr Bmc\_Conv\_Be2Bexp(BeEnc\_ptr be\_enc, be\_ptr be)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a be, constructs the corresponding boolean
  expression]

  Description        [Descends the structure of the BE with dag-level
  primitives. Uses the be encoding to perform all time-related operations. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Conv\_Bexp2Be(BeEnc\_ptr be\_enc, node\_ptr bexp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [<b>Converts</b> given <b>boolean expression</b> into
  correspondent <b>reduced boolean circuit</b>]

  Description        [Uses the be encoding to perform all
  time-related operations.]

  SideEffects        [be hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Bmc\_Conv\_BexpList2BeList(BeEnc\_ptr be\_enc, node\_ptr bexp\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [<b>Converts</b> given <b>boolean expressions list </b>
  into correspondent <b>reduced boolean circuits list</b>]

  Description        []

  SideEffects        [be hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Conv\_cleanup\_cached\_entries\_about(BeEnc\_ptr be\_enc, NodeList\_ptr symbs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes from the cache those entries that depend on
  the given symbol]

  Description [Called by the BeEnc when removing a layer, to make safe
  later declaration of symbols with the same name but different
  semantics.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Conv\_get\_BeModel2SymbModel(const BeEnc\_ptr be\_enc, const Slist\_ptr be\_model, int k, boolean convert\_to\_scalars, node\_ptr* frozen, array\_t** states, array\_t** inputs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function converts a BE model (i.e. a list of BE
  literals) to symbolic expressions.]

  Description [

  be_model is the model which will be transformed, i.e llList of
  BE literal.

  k is the number of steps (i.e. times+1) in the model.

  The returned results will be provided in:
  *frozen will point to expression over frozen variables,
  *states will point to an array of size k+1 to expressions over state vars.
  *inputs will point to an array of size k+1 to expressions over input vars.

  In arrays every index corresponds to the corresponding time,
  beginning from 0 for initial state.

  Every expressions is a list with AND used as connection and Nil at
  the end, i.e. it can be used as a list and as an expression.
  Every element of the list can have form:
  1) "var" or "!var" (if parameter convert_to_scalars is false)
  2) "var=const" (if parameter convert_to_scalar is true).

  By default BE literals are converted to bits of symbolic
  variables. With parameter convert_to_scalars set up the bits are
  converted to actual symbolic variables and scalar/word/etc
  values. Note however that if BE model does not provide a value for
  particular BE index then the corresponding bit may not be presented
  in the result expressions or may be given some random value
  (sometimes with convert_to_scalars set up). Note that in both cases
  the returned assignments may be incomplete.

  It is the responsibility of the invoker to free all arrays and the
  lists of expressions (i.e. run free_list on *frozen and every
  element of arrays returned).  EQUAL nodes (when convert_to_scalars
  is set up) are created with find_nodes, i.e. no freeing is need.

  No caching or other side-effect are applied ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Conv\_init\_cache()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes module Conv]

  Description        [This package function is called by bmcPkg module]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Conv\_quit\_cache()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [De-initializes module Conv]

  Description        [This package function is called by bmcPkg module]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void Be2bexpDfsData\_push(Be2bexpDfsData* data, node\_ptr value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets a node into the stack]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr Be2bexpDfsData\_head(Be2bexpDfsData* data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Be2bexpDfsData_head]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr Be2bexpDfsData\_pop(Be2bexpDfsData* data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Be2bexpDfsData_pop]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int Be2bexp\_Set(be\_ptr be, char* Be2bexpData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Be2bexpSet]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void Be2bexp\_First(be\_ptr be, char* Be2bexpData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Be2bexpFirst]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void Be2bexp\_Back(be\_ptr be, char* Be2bexpData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Be2bexp_Back]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void Be2bexp\_Last(be\_ptr be, char* Be2bexpData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Be2bexp_Last]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_conv\_set\_cache(node\_ptr bexp, be\_ptr be)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Update the bexpr -> be cache]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmc\_conv\_query\_cache(node\_ptr bexp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Queries the bexpr->be cache]

  Description        [Return NULL if association not found]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmc\_conv\_bexp2be\_recur(BeEnc\_ptr be\_enc, node\_ptr bexp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service for Bmc_Conv_Bexp2Be]

  Description        [Recursive service for Bmc_Conv_Bexp2Be, with caching of
  results]

  SideEffects        []

  SeeAlso            [Bmc_Conv_Bexp2Be]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcDump.c}
		
	\texttt{void Bmc\_Dump\_WriteProblem(const BeEnc\_ptr be\_enc, const Be\_Cnf\_ptr cnf, Prop\_ptr prop, const int k, const int loop, const Bmc\_DumpType dump\_type, const char* dump\_fname\_template)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps a cnf in different formats]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_Dump\_DimacsInvarProblemFilename(const BeEnc\_ptr be\_enc, const Be\_Cnf\_ptr cnf, const char* filename)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Opens a new file named filename, than dumps the given
  invar problem in DIMACS format]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_Dump\_DimacsProblemFilename(const BeEnc\_ptr be\_enc, const Be\_Cnf\_ptr cnf, const char* filename, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Opens a new file named filename, than dumps the given
  LTL problem in DIMACS format]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Dump\_DimacsInvarProblem(const BeEnc\_ptr be\_enc, const Be\_Cnf\_ptr cnf, FILE* dimacsfile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the given invar problem in the given file]

  Description        [dimacsfile must be writable]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Dump\_DimacsProblem(const BeEnc\_ptr be\_enc, const Be\_Cnf\_ptr cnf, const int k, FILE* dimacsfile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the given LTL problem in the given file]

  Description        [dimacsfile must be writable]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bmc\_dump\_openDimacsFile(const char* filename, FILE** file\_ref)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Open a file named filename and returns its descriptor]

  Description        [The file is opened with the writable attribute. The
  file descriptor is returned via the file_ref parameter. Returns 0 if the
  function succedeed, otherwise the function prints out a warning in the
  standard output and returns 1.]

  SideEffects        [file_ref will change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_dump\_expandFilename(const int k, const int l, const int prop\_idx, const char* filename\_to\_be\_expanded, char* filename\_expanded, const size\_t filename\_expanded\_maxlen)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This is only a useful wrapper for easily call
  Bmc_Utils_ExpandMacrosInFilename]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcGen.c}
		
	\texttt{be\_ptr Bmc\_Gen\_InvarProblem(const BeFsm\_ptr be\_fsm, const node\_ptr wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds and returns the invariant problem of the
  given propositional formula]

  Description        [Builds the negation of
                     (I0 imp P0) and ((P0 and R01) imp P1)
                     that must be unsatisfiable.]

  SideEffects        []

  SeeAlso            [Bmc_Gen_InvarBaseStep, Bmc_Gen_InvarInductStep]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Gen\_LtlProblem(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the LTL problem at length k with loopback l
  (single loop, no loop and all loopbacks are allowed)]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Gen\_InvarBaseStep(const BeFsm\_ptr be\_fsm, const node\_ptr wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the base step of the invariant construction]

  Description        [Returns I0 -> P0, where I0 is the init and
  invar at time 0, and P0 is the given formula at time 0]

  SideEffects        []

  SeeAlso            [Bmc_Gen_InvarInductStep]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Gen\_InvarInductStep(const BeFsm\_ptr be\_fsm, const node\_ptr wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the induction step of the invariant construction]

  Description        [Returns (P0 and R01) -> P1, where P0 is the formula
  at time 0, R01 is the transition (without init) from time 0 to 1,
  and P1 is the formula at time 1]

  SideEffects        []

  SeeAlso            [Bmc_Gen_InvarBaseStep]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Gen\_UnrollingFragment(BeFsm\_ptr be\_fsm, const int i)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates i-th fragment of BMC unrolling]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcInt.c}
		
	\texttt{be\_ptr Bmc\_GetTestTableau (const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []
  Description        []
  SideEffects        []
  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Prop\_ptr Bmc\_rewrite\_invar(const Prop\_ptr prop, const BddEnc\_ptr bdd\_enc, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [ Rewrites an invariant specification containing input 
   variables or next with an observer state variable ]

   Description        [ Returns a rewrited property ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_rewrite\_cleanup(Prop\_ptr rewritten\_prop, const BddEnc\_ptr bdd\_enc, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [ Crean up the memory after the rewritten property check ]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcModel.c}
		
	\texttt{be\_ptr Bmc\_Model\_GetInit0(const BeFsm\_ptr be\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the init states from the given fsm, and
  compiles them into a BE at time 0]

  Description        [Use this function instead of explicitly get the init
  from the fsm and shift them at time 0 using the vars manager layer.]

  SideEffects        []

  SeeAlso            [Bmc_Model_GetInvarAtTime]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Model\_GetInitI(const BeFsm\_ptr be\_fsm, const int i)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the init states from the given fsm, and
  compiles them into a BE at time i]

  Description        [Use this function instead of explicitly get the init
  from the fsm and shift them at time i using the vars manager layer.]

  SideEffects        []

  SeeAlso            [Bmc_Model_GetInvarAtTime]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Model\_GetInvarAtTime(const BeFsm\_ptr be\_fsm, const int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the invars from the given fsm, and
  compiles them into a BE at the given time]

  Description        [Use this function instead of explicitly get the invar
  from the fsm and shift them at the requested time using the vars
  manager layer.]

  SideEffects        []

  SeeAlso            [Bmc_Model_GetInit0]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Model\_GetTransAtTime(const BeFsm\_ptr be\_fsm, const int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the trans from the given fsm, and compiles
                      it into a MSatEnc at the given time]

  Description        [Use this function instead of explicitly get the trans
                      from the fsm and shift it at the requested
                      time using the vars manager layer]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Model\_GetUnrolling(const BeFsm\_ptr be\_fsm, const int j, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Unrolls the transition relation from j to k, taking
  into account of invars]

  Description        [Using of invars over next variables instead of the
  previuos variables is a specific implementation aspect]

  SideEffects        []

  SeeAlso            [Bmc_Model_GetPathWithInit, Bmc_Model_GetPathNoInit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Model\_Invar\_Dual\_forward\_unrolling(const BeFsm\_ptr be\_fsm, const be\_ptr invarspec, int i)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Unrolls the transition relation from j to k, taking
                      into account of invars]

  Description        [Using of invars over previous variables instead of the
                      next variables is a specific implementation aspect]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Model\_GetPathNoInit(const BeFsm\_ptr be\_fsm, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the path for the model from 0 to k,
  taking into account the invariants (and no init)]

  Description        []

  SideEffects        []

  SeeAlso            [Bmc_Model_GetPathWithInit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Model\_GetPathWithInit(const BeFsm\_ptr be\_fsm, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the path for the model from 0 to k,
  taking into account initial conditions and invariants]

  Description        []

  SideEffects        []

  SeeAlso            [Bmc_Model_GetPathNoInit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Model\_GetFairness(const BeFsm\_ptr be\_fsm, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates and returns an expression representing
  all fairnesses in a conjunctioned form]

  Description        [Uses bmc_model_getFairness_aux which recursively calls
  itself to conjuctive all fairnesses by constructing a top-level 'and'
  operation.
  Moreover bmc_model_getFairness_aux calls the recursive function
  bmc_model_getSingleFairness, which resolves a single fairness as
  a disjunctioned expression in which each ORed element is a shifting of
  the single fairness across \[l, k\] if a loop exists.
  If no loop exists, nothing can be issued, so a falsity value is returned]

  SideEffects        []

  SeeAlso            [bmc_model_getFairness_aux, bmc_model_getSingleFairness]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcOpt.c}
		
	\texttt{static boolean opt\_check\_bmc\_pb\_length(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check function for the bmc_pb_lenght option]

   Description [Check function for the bmc_pb_lenght option]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_check\_bmc\_pb\_loop(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check function for the bmc_pb_loop option]

   Description [Check function for the bmc_pb_loop option]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_check\_bmc\_invar\_alg(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check function for the bmc_invar_alg option]

   Description [Check function for the bmc_invar_alg option]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* opt\_get\_bmc\_invar\_alg(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Get function for the bmc_invar_alg function]

   Description [Get function for the bmc_invar_alg function]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_check\_bmc\_inc\_invar\_alg(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check function for the bmc_inc_invar_alg function]

   Description [Check function for the bmc_inc_invar_alg function]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* opt\_get\_bmc\_inc\_invar\_alg(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Get function for the bmc_inc_invar_alg function]

   Description [Get function for the bmc_inc_invar_alg function]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void * opt\_get\_integer(OptsHandler\_ptr opts, const char *value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Get the integer representation of the given string]

   Description        [Get the integer representation of the given string]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* opt\_get\_string(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Get function for simple strings]

   Description [Get function for simple strings]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcPkg.c}
		
	\texttt{void Bmc\_Init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the BMC structure]

  Description [It builds the vars manager, initializes the package and
  all sub packages, but only if not previously called.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees all resources allocated for the BMC model manager]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_InitData()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Initializes the BMC internal structures, but not all
  dependencies. Call Bmc_Init to initialize everything it is is what
  you need instead.]

  Description []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_QuitData()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [De0Initializes the BMC internal structures, but not all
  dependencies. Call Bmc_Quit to deinitialize everything it is is what
  you need instead.]

  Description []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_AddCmd()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds all bmc-related commands to the interactive shell]

  Description        []

  SideEffects        []

  SeeAlso            [CInit_Init]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcSimulate.c}
		
	\texttt{int Bmc\_Simulate(const BeFsm\_ptr be\_fsm, BddEnc\_ptr bdd\_enc, be\_ptr be\_constraints, boolean time\_shift, const int k, const boolean print\_trace, const boolean changes\_only, const Simulation\_Mode mode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Performs simulation]

   Description [Generate a problem with no property, and search for a
   solution, appending it to the current simulation trace.
   Returns 1 if solver could not be created, 0 if everything went smooth]

   SideEffects        [None]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_StepWiseSimulation(BeFsm\_ptr be\_fsm, BddEnc\_ptr bdd\_enc, TraceManager\_ptr trace\_manager, int target\_steps, be\_ptr constraints, boolean time\_shift, boolean print\_trace, boolean changes\_only, Simulation\_Mode mode, boolean display\_all)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [SAT Based Incremental simulation]

  Description        [This function performs incremental sat based
  simulation up to <tt>target_steps</tt>.

  Simulation starts from an initial state internally selected.

  It accepts a constraint to direct the simulation to paths satisfying
  such constraints. The constraints is assumed to be over state, input
  and next state variables. Thus, please carefully consider this
  information while providing constraints to this routine.

  The simulation stops if either the <tt>target_steps</tt> steps of
  simulation have been performed, or the simulation bumped in a
  deadlock (that might be due to the constraints that are too strong).

  Parameters:

  'print_trace'  : shows the generated trace
  'changes_only' : shows only variables that actually change value
  between one step and it's next one]

  SideEffects        [The possibly partial generated simulaiton trace
  is added to the trace manager for possible reuse.]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Olist\_ptr Bmc\_simulate\_check\_feasible\_constraints(BeFsm\_ptr be\_fsm, BddEnc\_ptr bdd\_enc, Olist\_ptr constraints, be\_ptr from\_state)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks the truth value of a list of constraints on the
                      current state, transitions and next states,
                      from given starting state. This can be used
                      in guided interactive simulation to propose
                      the set of transitions which are allowed to
                      occur in the interactive simulation.]

  Description        [Given a list of constraints (next-expressions as be_ptr),
                      checks which (flattened) constraints are
                      satisfiable from a given state. Iff
                      from_state is NULL (and not TRUE), the
                      initial state of the fsm is
                      considered. Returned list contains values in
                      {0,1}, and has to be freed.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_pick\_state\_from\_constr(BeFsm\_ptr fsm, BddEnc\_ptr bdd\_enc, be\_ptr constr, Simulation\_Mode mode, boolean display\_all)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Picks a state from the initial state, creates a trace
                     from it.]

  Description       [The trace is added into the trace manager.
                     Returns the index of the added trace, or -1 if
                     no trace was created.]

  SideEffects       [A new trace possibly created into the trace manager]

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bmc\_simulate\_set\_curr\_sim\_trace(Trace\_ptr trace, int idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Internal function used during the simulation to set the
  current simulation trace]

  Description   []

  SideEffects   []

  SeeAlso       []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_simulate\_add\_be\_into\_inc\_solver\_positively(SatIncSolver\_ptr solver, SatSolverGroup group, be\_ptr prob, BeEnc\_ptr be\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Converts Be into CNF, and adds it into a group of a
                 incremental solver, sets polarity to 1, and then destroys
                 the CNF.]

  Description   [Outputs into nusmv_stdout the total time of conversion,
                 adding, setting polarity and destroying BE. ]

  SideEffects   []

  SeeAlso       []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_simulate\_add\_be\_into\_non\_inc\_solver\_positively(SatSolver\_ptr solver, be\_ptr prob, BeEnc\_ptr be\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Converts Be into CNF, and adds it into a group of a
                 non-incremental solver, sets polarity to 1, and
                 then destroys the CNF.]

  Description   [Outputs into nusmv_stdout the total time of conversion,
                 adding, setting polarity and destroying BE. ]

  SideEffects   []

  SeeAlso       []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_simulate\_enable\_random\_mode(SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Enables random mode in the given sat solver]

  Description   [Enables random mode in the given sat solver.
                 Seed used in random]

  SideEffects   []

  SeeAlso       []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr bmc\_simulate\_interactive\_step(SatSolver\_ptr solver, BeEnc\_ptr be\_enc, BddEnc\_ptr bdd\_enc, NodeList\_ptr symbols, boolean in\_simulation, boolean display\_all)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Performs a step of interactive simulation]

   Description        [Performs a step of interactive simulation.

                       Finds all alternative assignments of the
                       current model in the given sat solver. For this
                       reason, the function must be called only after
                       a call to SatSolver_solve_all_groups that
                       returned SAT. "in_simulation" determines
                       whether the interactive step should be done for
                       extending a trace (i.e. simulate) or when
                       creating a new one (i.e. pick_state). Returns a
                       trace that represents the new choosen state,
                       which can be used as starting point for
                       pick_state and can be concatenated to the
                       previously existing one when simulating]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_simulate\_print\_state(Trace\_ptr trace, TraceIter step, int state\_num, boolean show\_inputs, hash\_ptr shown\_assignments)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Aux function for interactive simulation.
                       Prints the given set of assignments]

   Description        [Prints all variable assignments of trace "trace", in
                       step "step"]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_simulate\_trace\_step\_print(const Trace\_ptr trace, const TraceIter step, TraceIteratorType it\_type, hash\_ptr shown\_assignments)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Aux function for interactive simulation.
                       Prints the given set of assignments]

   Description        [Prints all variable assignments of trace "trace", in
                       step "step" and of type "it_type"]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bmc\_simulate\_ask\_for\_state(int max\_choice)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Aux function for interactive simulation.
                       Asks the user for a number from 0 to max_choice.]

   Description        [Asks the user for a number from 0 to max_choice. Input
                       is taken from nusmv_stdin. Returns the selected number]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcTableau.c}
		
	\texttt{be\_ptr Bmc\_Tableau\_GetNoLoop(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau without loop at time zero, taking into
  account of fairness]

  Description        [Fairness evaluate to true if there are not fairness
  in the model, otherwise them evaluate to false because of no loop]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Tableau\_GetSingleLoop (const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau for all possible loops in \[l, k\], in
  the particular case in which depth is 1. This function takes into account
  of fairness]

  Description        [Builds the tableau in the case depth==1 as suggested
  by R. Sebastiani]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Tableau\_GetAllLoops(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau for all possible loops in \[l, k\[,
  taking into account of fairness]

  Description        [Each tableau takes into account of fairnesses relative
  to its step. All tableau are collected together into a disjunctive form.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Tableau\_GetAllLoopsDepth1(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau for all possible loops in \[l, k\], in
  the particular case in which depth is 1. This function takes into account
  of fairness]

  Description        [Builds the tableau in the case depth==1 as suggested
  by R. Sebastiani]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Tableau\_GetLtlTableau(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a tableau for the LTL at length k with loopback l
  (single loop, no loop and all loopbacks are allowed)]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauLTL\_GetSingleLoopWithFairness(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the tableau at time zero. Loop is allowed,
  fairness are taken into account]

  Description        []

  SideEffects        []

  SeeAlso            [BmcInt_Tableau_GetAtTime]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauLTL\_GetSingleLoop (const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the tableau at time zero. Loop is allowed,
  fairness are taken into account]

  Description        []

  SideEffects        []

  SeeAlso            [BmcInt_Tableau_GetAtTime]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauLTL\_GetNoLoop(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau without loop at time zero, taking into
  account of fairness]

  Description        [Fairness evaluate to true if there are not fairness
  in the model, otherwise them evaluate to false because of no loop]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauLTL\_GetAllLoops(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau for all possible loops in \[l, k\[,
  taking into account of fairness]

  Description        [Each tableau takes into account of fairnesses relative
  to its step. All tableau are collected together into a disjunctive form.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauLTL\_GetAllLoopsDepth1(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau for all possible loops in \[l, k\], in
  the particular case in which depth is 1. This function takes into account
  of fairness]

  Description        [Builds the tableau in the case depth==1 as suggested
  by R. Sebastiani]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauPLTL\_GetNoLoop(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the tableau for a PLTL formula on a bounded path
                      of length k, reasoning on fairness conditions as well.  ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauPLTL\_GetSingleLoop (const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the tableau for a PLTL formula on a (k,l)-loop,
                      conjuncted with both fairness conditions and the loop
                      condition on time steps k and l.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauPLTL\_GetAllLoops(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_wff, const int k, const int startFromL)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the conjunction of the single-loop tableaux for
                      all possible (k,l)-loops for a fixed k. Each single-loop
                      tableau takes into account of both fairness constraints
                      and loop condition.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_TableauPLTL\_GetAllLoopsDepth1(const BeFsm\_ptr be\_fsm, const node\_ptr pltl\_wff, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds tableau for all possible (k,l)-loops for a
                      fixed k, in the particular case depth==1.
                      This function takes into account of fairness.]

  Description        [Builds the tableau in the case depth==1 as suggested
                      by R. Sebastiani.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_Tableau\_GetLoopCondition(const BeEnc\_ptr be\_enc, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a tableau that constraints state k to be equal to
                      state l. This is the condition for a path of length (k+1)
                      to represent a (k-l)loop (new semantics).]

  Description        [State l and state k are forced to represent the same
                      state by conjuncting the if-and-only-if conditions
                      {Vil<->Vik} between Vil (variable i at time l) and Vik
                      (variable i at time k) for each state variable Vi.
                      Note:frozen vars do not participate in this conjunct,
                      since they are implicitly keep their valus over all states]

  SideEffects        []

  SeeAlso            [Bmc_Tableau_GetAllLoopsDisjunction]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr Bmc\_Tableau\_GetAllLoopsDisjunction(const BeEnc\_ptr be\_enc, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the disjunction of all the loops conditions
                      for (k-l)-loops with l in \[0, k\[]

  Description        [Builds a formula which is a disjunction over all the
                      loop conditions on k-loops, with l=0,1,...,k-1.]

  SideEffects        []

  SeeAlso            [Bmc_Tableau_GetLoopCondition]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean isPureFuture(const node\_ptr pltl\_wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Checks wether a formula contains only future operators ]

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean isPureFuture\_aux(const node\_ptr pltl\_wff, hash\_ptr memoiz)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Memoized private service of isPureFuture]

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcTableauLTLformula.c}
		
	\texttt{be\_ptr BmcInt\_Tableau\_GetAtTime(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int time, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a wff expressed in ltl builds the model-independent
  tableau at 'time' of a path formula bounded by \[k, l\]]

  Description        [This function is the entry point of a mutual recursive
  calling stack. All logical connectives are resolved, excepted for NOT, which
  closes the recursive calling stack. Also variables and falsity/truth
  constants close the recursion.]

  SideEffects        []

  SeeAlso            [bmc_tableauGetNextAtTime,
  bmc_tableauGetGloballyAtTime, bmc_tableauGetEventuallyAtTime,
  bmc_tableauGetUntilAtTime, bmc_tableauGetReleasesAtTime]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr bmc\_tableauGetNextAtTime(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int time, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Resolves the NEXT operator, building the tableau for
  its argument]

  Description        [Returns a falsity constants if the next operator leads
  out of \[l, k\] and there is no loop]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr bmc\_tableauGetEventuallyAtTime(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int intime, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Resolves the future operator, and builds a conjunctive
  expression of tableaus, by iterating intime up to k in a different manner
  depending on the \[l, k\] interval form]

  Description        [ltl_wff is the 'p' part in 'F p'.
  If intime<=k is out of \[l, k\] or if there is no loop,
  iterates from intime to k, otherwise iterates from l to k]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr bmc\_tableauGetGloballyAtTime(const BeEnc\_ptr be\_enc, const node\_ptr ltl\_wff, const int intime, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [As bmc_tableauGetEventuallyAtTime, but builds a
  conjunctioned expression in order to be able to assure a global constraint]

  Description        [ltl_wff is the 'p' part in 'G p']

  SideEffects        []

  SeeAlso            [bmc_tableauGetEventuallyAtTime]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr bmc\_tableauGetUntilAtTime(const BeEnc\_ptr be\_enc, const node\_ptr p, const node\_ptr q, const int time, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds an expression which evaluates the until operator]

  Description        [Carries out the steps number to be performed, depending
  on l,k and time, then calls bmc_tableauGetUntilAtTime_aux]

  SideEffects        []

  SeeAlso            [bmc_tableauGetUntilAtTime_aux]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr bmc\_tableauGetReleasesAtTime(const BeEnc\_ptr be\_enc, const node\_ptr p, const node\_ptr q, const int time, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds an expression which evaluates the release
  operator]

  Description        [Carries out the steps number to be performed, depending
  on l,k and time, then calls bmc_tableauGetReleasesAtTime_aux]

  SideEffects        []

  SeeAlso            [bmc_tableauGetReleasesAtTime_aux]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmc\_tableauGetUntilAtTime\_aux(const BeEnc\_ptr be\_enc, const node\_ptr p, const node\_ptr q, const int time, const int k, const int l, const int steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [auxiliary part of bmc_tableauGetUntilAtTime]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmc\_tableauGetReleasesAtTime\_aux(const BeEnc\_ptr be\_enc, const node\_ptr p, const node\_ptr q, const int time, const int k, const int l, const int steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [auxiliary part of bmc_tableauGetReleasesAtTime]

  Description        [Builds the release operator expression]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcTableauPLTLformula.c}
		
	\texttt{be\_ptr Bmc\_TableauPLTL\_GetTableau(const BeEnc\_ptr be\_enc, const node\_ptr pltl\_wff, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Builds the tableau for a PLTL formula.]

  Description  [Builds both the bounded-tableau and the loop-tableau for a PLTL
                formula "pltl_wff" (depending on the value of l). The time
                the tableau refers to is (implicitly) time zero.]

  SideEffects  []

  SeeAlso      [getTableauAtTime]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_TableauPLTL\_GetAllTimeTableau(const BeEnc\_ptr be\_enc, const node\_ptr pltl\_wff, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Builds the conjunction of the tableaux for a PLTL formula
                computed on every time instant along a (k,l)-loop.]

  Description  [This function is a special case of "evaluateOn", thus it
                computes its answer by calling "evaluateOn" with some specifc
                arguments. The only use of this function is in constructing
                optimized tableaux for those depth-one formulas where
                "RELEASES" is the unique operator.]

  SideEffects  []

  SeeAlso      [evaluateOn]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr getTableauAtTime(const BeEnc\_ptr be\_enc, const node\_ptr pltl\_wff, const int time, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [ Builds the tableau for a PLTL formula "pltl_wff" at time
                 "time".]

  Description  [ Tableaux for constant expressions and (negated) literals are
                 built immediately, while complex formulas are evaluated in a
                 compositional way. In particular, propositional operators are
                 evaluated throught recursive calls to the procedure
                 "getTableauAtTime" itself (no split on time instants is
                 necessary in this case). Time operators are evaluated (in a
                 uniform way) by means of a doubly recursive call, which
                 involves the "evaluateOn" procedure as a counterpart.
                 A concise representation of the set of time instants each time
                 operator refers to (together with its argument(s))
                 is passed to the "evaluateOn" procedure, which is then
                 responsible for recursively evaluating these arguments on the
                 proper set of integer time instants by calling
                 "getTableauAtTime" in turn.]

  SideEffects  []

  SeeAlso      [evaluateOn]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr evaluateOn(const BeEnc\_ptr be\_enc, const node\_ptr pltl\_f, const node\_ptr pltl\_g, const int fromTime, const int toTime, const int k, const int l, const int evalType, const int evalDir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [ Evaluates (either disjunctively or conjunctively) a PLTL
                 formula over an interval of time. ]

  Description  [ When only one argument is passed in (pltl_g==NULL), the
                 tableaux at the proper time instants for that argument are
                 computed (throught recursive calls to "getTableauAtTime")
                 and either disjunctively or conjunctively put together
                 (depending on the value of the "evalType" parameter).
                 When two arguments are given, the second one is evaluated
                 according to the following scheme (here we represent the
                 disjunctive case; "and" and "or" have to be exchanged to
                 obtain the conjunctive case):
                          (Aj or (Bi and Bi+1 and ... and Bj-1))

                 where A is the first argument, B is the second one, j is the
                 time the first argument is currently being evaluated on, and
                 i is the starting time for the whole evaluation (this
                 evaluation scheme is adopted as it is shared by all the
                 binary time operators in the PLTL logic).
                 In both cases, the proper evaluation set is computed
                 by calling the "projectOntoMainDomain" function, which deals
                 with both bounded and loop paths. ]

  SideEffects  []

  SeeAlso      [getTableauAtTime, projectOntoMainDomain]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static EvalSet projectOntoMainDomain(const node\_ptr pltl\_wff, int a, int b, const int k, const int l, const int interval\_type, const int eval\_dir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [ Projects a (possibly open) interval [a,b] of integers
                 (time instants) onto the main domain of the PLTL formula
                 pltl_wff. The result of the projection can be either an
                 interval or the conjunction of two intervals. In both cases,
                 the resulting set is returned as an "EvalSet" structure. ]

  Description  [ For bounded paths, the projection of the interval [a,b] is
                 the interval [a,b] itself, except for the possibly infinite
                 right bound (symbolically represented by the constant "INF")
                 which is substituted by the integer bound k.
                 For infinite paths which are (k,l)-loops, this function
                 explicitly computes the set implicitly defined as
                 EvalSet={rho(i) such that i is in [a,b]}. The function
                 "projectOntoMainDomain" thus extends to intervals the
                 transformation previously defined by "rho" with respect
                 to single time point. ]

  SideEffects  []

  SeeAlso      [rho, evaluateOn]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int tau(const node\_ptr pltl\_wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Gives an upper bound on the past temporal horizon of a
                PLTL formula.]

  Description  [Recursively computes the (maximum) nesting depth of past
                operators in the formula, which is an upper bound on its past
                temporal horizon.]

  SideEffects  []

  SeeAlso      [projectOntoMainDomain]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcTest.c}
		
	\texttt{void Bmc\_TestReset()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this function to reset the test sub-package (into
  the reset command for example)]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_TestTableau(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The first time Bmc_TestTableau is called in the current
  session this function creates a smv file with a model and generates a random
  ltl spec to test tableau. The following times it is called it appends a new
  formula to the file.]

  Description        [If you call this command with a loopback set to
  BMC_ALL_LOOPS you command execution is aborted.]

  SideEffects        []

  SeeAlso            []

  CommandName        [_bmc_test_tableau]

  CommandSynopsis    [Generates a random formula to logically test the
  equivalent tableau]

  CommandArguments   [\[-h\] | \[-n property_index\] | \[\[ -d max_depth\] \[-c max_conns\] \[-o operator\]\]
  ]

  CommandDescription [Use this hidden command to generate random formulae and
  to test the equivalent tableau. The first time this command is called in the
  current NuSMV session it creates a new smv file with a model and generates a
  random ltl spec to test tableau.
  The following times it is called it appends a new formula to the file.
  The generated model contains the same number of non-deterministic variables
  the currently model loaded into NuSMV contains. <BR>
  You cannot call this command if the bmc_loopback is set to '*' (all loops).
  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageBmcTestTableau(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Usage string for Bmc_TestTableau]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bmc\_test\_mk\_loopback\_ltl(const BeEnc\_ptr be\_enc, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [For each variable p in the set of state variables,
  generates the global equivalence of p and X^(loop length), starting from
  the loop start]

  Description [ In the following example we suppose the loop starts
  from 2 and finishes to 6 (the bound).

  <PRE>
        ,-----------.
        V           |
  o--o--o--o--o--o--o--o--o--o--o--o--o- (...continues indefinitely)
  0  1  2  3  4  5  6  7  8  9  10 11 12

  </PRE>


  In general all state variables in time 2 must be forced to be equivalent
  to the corresponding variables timed in 6, the variables in 3 to 7,
  and so on up to the variables in 6 (equivalent to variables in
  10). Then variables in 7 (or 3 again) must be forced to be equivalent
  to the varaibles in 11, and so on indefinitely.
  <BR><BR>
  In formula (let suppose we have only one boolean variable):
  <BR>
  (p2 <-> p6) && (p6 <-> p10) ...
  <BR><BR>
  In a more compact (and finite!) form, related to this example:
  XX(G (p <-> XXXX(p)))

  The first two neXtes force the formula to be effective only from the loop
  starting point.
  The generic formula implemented in the code is the following one:
  <PRE>
  X^(l) (G ((p0 <-> X^(k-l)(p0)) &&
            (p1 <-> X^(k-l)(p1)) &&
	                .
                        .
                        .
            (pn <-> X^(k-l)(pn)))
        )
  </PRE>
 where:
   p0..pn are all boolean variables into the model
   X^(n) is expanded to XXX..X n-times.
 Note that frozen vars can be ignored since they are always equal to their previous
 values]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bmc\_test\_gen\_tableau(const BeFsm\_ptr be\_fsm, const node\_ptr ltl\_nnf\_wff, const int k, const int l, boolean usePastOperators)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a WFF in NNF, converts it into a tableau
  formula, then back to WFF_(k,l) and returns WFF -> WFF_(k,l)]

  Description        [This function is used to test tableau formulae]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bmc\_test\_gen\_wff(const BeEnc\_ptr be\_enc, int max\_depth, int max\_conns, boolean usePastOperators)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds a <b>random LTL WFF</b> with specified
  <tt>max</tt> depth and <tt>max</tt> connectives.]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bmc\_test\_bexpr\_output(const BeEnc\_ptr be\_enc, FILE* f, const node\_ptr bexp, const int output\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [<b>Write</b> to specified FILE stream given node_ptr
  <b>formula</b> with specified <tt>output_type</tt> format. There are
  follow formats: <tt>BMC_BEXP_OUTPUT_SMV, BMC_BEXP_OUTPUT_LB</tt>]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcTrace.c}
		
	\texttt{Trace\_ptr Bmc\_create\_trace\_from\_cnf\_model(const BeEnc\_ptr be\_enc, const NodeList\_ptr symbols, const char* desc, const TraceType type, const Slist\_ptr cnf\_model, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Creates a trace out of a cnf model]

  Description  [Creates a complete, k steps long trace in the language
                of \"symbols\" out a cnf model from a sat solver.
                The returned trace is non-volatile.

                For more control over the built trace, please see
                Bmc_fill_trace_from_cnf_model]

  SideEffects  [none]

  SeeAlso      [Trace_create, Mc_create_trace_from_bdd_input_list,
               Bmc_fill_trace_from_cnf_model]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Bmc\_fill\_trace\_from\_cnf\_model(const BeEnc\_ptr be\_enc, const Slist\_ptr cnf\_model, int k, Trace\_ptr trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Fills the given trace out of a cnf model]

  Description  [Fills the trace. The trace will be a complete, k steps
                long trace in the language of \"symbols\" out a cnf
                model from a sat solver.]

  SideEffects  [none]

  SeeAlso      [Trace_create, Mc_fill_trace_from_bdd_input_list]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bmc\_trace\_utils\_complete\_trace(Trace\_ptr trace, const BoolEnc\_ptr bool\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Populates trace with valid defaults assignments]

  Description [Populates trace with valid defaults assignments.

               The trace can be safely considered complete when this
               function returns.  Existing assignments will not be
               affected.]

  SideEffects [Trace is populated with default values]

  SeeAlso     []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bmc\_trace\_utils\_append\_input\_state(Trace\_ptr trace, BeEnc\_ptr be\_enc, const Slist\_ptr cnf\_model)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Appends a _complete_ (i,S') pair to existing trace]

  Description   [This is a private service of BmcStepWise_Simulation]

  SideEffects   []

  SeeAlso       []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bmcUtils.c}
		
	\texttt{int Bmc\_Utils\_ConvertLoopFromString(const char* strValue, Outcome* result)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Given a string representing a loopback possible value,
               returns the corresponding integer.  The (optional)
               parameter result will be assigned to OUTCOME_SUCCESS if the
               conversion has been successfully performed, otherwise
               to OUTCOME_GENERIC_ERROR is the conversion failed. If result is
               NULL, OUTCOME_SUCCESS is the aspected value, and an assertion
               is implicitly performed to check the conversion
               outcome.]

  Description [Use this function to correctly convert a string
               containing a loopback user-side value to the internal
               representation of the same loopback value]

  SideEffects [result will change if supplied]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Utils\_ConvertLoopFromInteger(const int iLoopback, char* szLoopback, const int \_bufsize)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Given an integer containing the inner representation of
               the loopback value, returns as parameter the
               corresponding user-side value as string]

  Description [Inverse semantic of
               Bmc_Utils_ConvertLoopFromString. bufsize is the maximum
               buffer size]

  SideEffects [String buffer passed as argument will change]

  SeeAlso     [Bmc_Utils_ConvertLoopFromString]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Bmc\_Utils\_IsNoLoopback(const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if l has the internally encoded "no loop"
               value]

  Description [This is supplied in order to hide the internal value of
               loopback which corresponds to the "no loop" semantic.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Bmc\_Utils\_IsNoLoopbackString(const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if the given string represents the no
               loopback value]

  Description [This is supplied in order to hide the internal value of
               loopback which corresponds to the "no loop" semantic.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Bmc\_Utils\_IsSingleLoopback(const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if the given loop value represents a single
               (relative or absolute) loopback]

  Description [Both cases "no loop" and "all loops" make this function
               returning false, since these values are not single
               loops.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Bmc\_Utils\_IsAllLoopbacks(const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if the given loop value represents the "all
               possible loopbacks" semantic]

  Description [This is supplied in order to hide the internal value of
               loopback which corresponds to the "all loops"
               semantic.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Bmc\_Utils\_IsAllLoopbacksString(const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if the given string represents the "all
               possible loops" value.]

  Description [This is supplied in order to hide the internal value of
               loopback which corresponds to the "all loops"
               semantic.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_Utils\_GetNoLoopback()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the integer value which represents the "no loop"
               semantic]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_Utils\_GetAllLoopbacks()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the integer value which represents the "all loops"
               semantic]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Bmc\_Utils\_GetAllLoopbacksString()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a constant string which represents the "all loops"
               semantic.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_Utils\_RelLoop2AbsLoop(const int upov\_loop, const int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a relative loop value (wich can also be an
               absolute loop value) to an absolute loop value]

  Description [For example the -4 value when k is 10 is the value 6,
               but the value 4 (absolute loop value) is still 4]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Outcome Bmc\_Utils\_Check\_k\_l(const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Checks the (k,l) couple. l must be absolute.]

  Description [Returns OUTCOME_SUCCESS if k and l are compatible, otherwise
               return OUTCOME_GENERIC_ERROR]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Bmc\_Utils\_GetSuccTime(const int time, const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Given time<=k and a \[l, k\] interval, returns next time,
               or BMC_NO_LOOP if time is equal to k and there is no
               loop]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bmc\_Utils\_ExpandMacrosInFilename(const char* filename\_to\_be\_expanded, const SubstString* table\_ptr, const size\_t table\_len, char* filename\_expanded, size\_t buf\_len)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Search into a given string any symbol which belongs to a
               determined set of symbols, and expand each found
               symbol, finally returning the resulting string]

  Description [This function is used in order to perform the macro
               expansion of filenames. table_ptr is the pointer to a
               previously prepared table which fixes any
               corrispondence from symbol to strings to be
               substituited from.  table_len is the number of rows in
               the table (i.e. the number of symbols to search for.)]

  SideEffects [filename_expanded string data will change]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Bmc\_Utils\_generate\_and\_print\_cntexample(BeEnc\_ptr be\_enc, SatSolver\_ptr solver, be\_ptr be\_prob, const int k, const char* trace\_name, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Given a problem, and a solver containing a model for that
               problem, generates and prints a counter-example]

  Description [A trace is generated and printed using the currently
               selected plugin. Generated trace is returned, in order
               to make possible for the caller to do some other
               operation, like association with the checked
               property. Returned trace object *cannot* be destroyed
               by the caller.]

  SideEffects []

  SeeAlso     [Bmc_Utils_generate_cntexample Bmc_Utils_fill_cntexample]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Bmc\_Utils\_generate\_cntexample(BeEnc\_ptr be\_enc, SatSolver\_ptr solver, be\_ptr be\_prob, const int k, const char* trace\_name, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis   [Given a problem, and a solver containing a model for that
              problem, generates a counter-example]

  Description [Generated trace is returned, in order to make possible
               for the caller to do some other operation, like
               association with the checked property. Returned trace
               is non-volatile]

  SideEffects  []

  SeeAlso      [Bmc_Utils_generate_and_print_cntexample]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Bmc\_Utils\_fill\_cntexample(BeEnc\_ptr be\_enc, SatSolver\_ptr solver, const int k, Trace\_ptr trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis   [Given a solver containing a model for a
              problem, fills the given counter-example correspondingly]

  Description [The filled trace is returned. The given trace must be empty]

  SideEffects  []

  SeeAlso      [Bmc_fill_trace_from_cnf_model Bmc_Utils_generate_cntexample]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList Bmc\_Utils\_get\_vars\_list\_for\_uniqueness(BeEnc\_ptr be\_enc, Prop\_ptr invarprop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a list of BE variables that are intended to be
               used by the routine that makes the state unique in
               invariant checking.]

  Description [If coi is enabled, than the returned list will contain
               only those boolean state variable the given property
               actually depends on.  Otherwise the full set of state
               boolean vars will occur in the list.  Frozen variables
               are not required, since they do not change from state
               to state, thus, cannot make a state distinguishable
               from other states.

               Returned list must be destroyed by the called.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList Bmc\_Utils\_get\_vars\_list\_for\_uniqueness\_fsm(BeEnc\_ptr be\_enc, SexpFsm\_ptr bool\_sexp\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a list of BE variables that are intended to be
               used by the routine that makes the state unique in
               invariant checking.]

  Description [If coi is enabled, than the returned list will contain
               only those boolean state variable the given property
               actually depends on.  Otherwise the full set of state
               boolean vars will occur in the list.  Frozen variables
               are not required, since they do not change from state
               to state, thus, cannot make a state distinguishable
               from other states.

               Returned list must be destroyed by the called.]

  SideEffects  []

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Utils\_apply\_inlining(Be\_Manager\_ptr be\_mgr, be\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies inlining taking into account of current user
               settings]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Utils\_apply\_inlining4inc(Be\_Manager\_ptr be\_mgr, be\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies inlining forcing inclusion of the conjunct
               set. Useful in the incremental SAT applications to
               guarantee soundness]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Utils\_simple\_costraint\_from\_string(BeEnc\_ptr be\_enc, BddEnc\_ptr bdd\_enc, const char* str, Expr\_ptr* node\_expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Reads a simple expression and builds the corresponding BE
               formula.]

  Description [Reads a simple expression and builds the corresponding
               BE formula. Exceptions are raised if the expression
               cannot be parsed or has type errors.]

  SideEffects [None]

  SeeAlso     [Bmc_Utils_next_costraint_from_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr Bmc\_Utils\_next\_costraint\_from\_string(BeEnc\_ptr be\_enc, BddEnc\_ptr bdd\_enc, const char* str, Expr\_ptr* node\_expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Reads a next expression and builds the corresponding BE
               formula.]

  Description [Reads a next expression and builds the corresponding BE
               formula. Exceptions are raised if the expression cannot
               be parsed or has type errors. If node_expr is not NULL,
               it will be set to the parsed expression.]

  SideEffects [None]

  SeeAlso     [Bmc_Utils_simple_costraint_from_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr bmc\_utils\_costraint\_from\_string(BeEnc\_ptr be\_enc, BddEnc\_ptr bdd\_enc, const char* str, boolean accept\_next\_expr, Expr\_ptr* node\_expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Reads an expression and builds the corresponding BE
               formula. If accept_next_expr is true, then a next
               expression is parsed, otherwise a simple expression is
               parsed. ]

  Description [Reads a either simple or next expression and builds the
               corresponding BE formula. Exceptions are raised if the
               expression cannot be parsed or has type
               errors. Internal service.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{cinit}
		
	\subsection{cinitCmd.c}
		
	\texttt{int CommandCmdReset(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the reset command.]

  CommandName        [reset]

  CommandSynopsis    [Resets the whole system.]

  CommandArguments   [\[-h\]]

  CommandDescription [Resets the whole system, in order to read in
  another model and to perform verification on it.
  <p>
  Command options:<p>
  <dl>
    <dt> -h
       <dd> Prints the command usage.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandPrintUsage(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the print_usage command.]

  CommandName        [print_usage]

  CommandSynopsis    [Prints processor and BDD statistics.]

  CommandArguments   [\[-h\]]

  CommandDescription [Prints a formatted dump of processor-specific
  usage statistics, and BDD usage statistics. For Berkeley Unix, this
  includes all of the information in the <tt>getrusage()</tt> structure.
  <p>
  Command options:<p>
  <dl>
    <dt> -h
       <dd> Prints the command usage.
  </dl>]

  SideEffects        [required]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{cinitData.c}
		
	\texttt{void NuSMVCore\_init\_data()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Initializes the NuSMVCore data. This  function has to be called
   _BEFORE_ doing anything else with the library]

   Description [Initializes the NuSMVCore data. The following operations are
   performed:

   1) Initialize the internal class
   2) Sets all fields to default for NuSMV
   ]

   SideEffects []

   SeeAlso     [Package_init_cmd_options Package_init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_init(FP\_V\_V funs[][2], int num\_funs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Initializes the system]

   Description        [Initializes the system. First calls the
                       NuSMVCore initialization function, and then
                       calls each initialization function that is in
                       the given list. The order of the list is
                       followed.
                       The list must be declared as follows:

                       FP_V_V funs[][2] = {{Init_1, Quit_1},
                                           {Init_2, Quit_2},
                                            ...
                                           {Init_n, Quit_n}
                                           }]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_reset_first_fun NuSMVCore_set_reset_last_fun]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_init\_cmd\_options()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Initializes all NuSMV library command line options]

   Description [Initializes all NuSMV library command line options.
   All command line options are registered within the
   library.  If standard command line options are needed,
   this function has to be called before NuSMVCore_main and
   after NuSMVCore_init]

   SideEffects []

   SeeAlso     [Package_init Package_main]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean NuSMVCore\_main(int argc, char ** argv, int* status)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Executes the main program.]

   Description        [Executes the main program.]

   SideEffects        []

   SeeAlso            [NuSMVCore_init NuSMVCore_quit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Shuts down the system]

   Description        [Shuts down the system. First all quit functions
                       in the list given to NuSMVCore_init are
                       called. Then all complex structures that have a
                       dependency among some internal packages are
                       deinitialized. After that, the Core is shut
                       down and finally all simple internal structures
                       are freed]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_reset_first_fun NuSMVCore_set_reset_last_fun]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_reset()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Shuts down and restarts the system]

   Description        [Shuts down and restarts the system. 4 steps are done:
   1) Call the reset_first function (if any).
   2) Call the NuSMV package reset_first function
   3) Call the NuSMV package reset_last function
   4) Call the reset_last function (if any)
   ]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_reset_first_fun NuSMVCore_set_reset_last_fun]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_add\_env\_command\_line\_option(char* name, char* usage, char* parameter, char* env\_var, boolean public, boolean deprecated, char* dependency, char* conflict)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds a command line option to the system.]

   Description        [Adds a command line option to the system. The command
   line option MUST have an environment option
   associated. When the command line option is
   specified, the environment option is
   automatically set to the correct value (In case
   of boolean options, the current value is
   negated, in any other case, the cmd option
   requires an argument which is set to the
   associated option

   Function arguments:
   1) name -> The name of the cmd line option (e.g. -int)
   2) usage -> The usage string that will be
   printed in the help (i.e. -help)
   3) parameter -> NULL if none, a string value if any.
   e.g: "k" for bmc_length
   4) env_var  -> The associated environment variable name
   5) public -> Tells whether the cmd line option
   is public or not. If not, the usage
   is not printed when invoking the
   tool with -h.
   6) deprecated -> Tells whether the cmd line
   options is deprecated or not
   7) dependency -> The possibly option name on which this
   one dependens on. NULL if none.
   e.g. -bmc_length depends on -bmc
   8) conflict -> The list of option names that
   conflict with this one.
   e.g. -mono conflicts with
   "-thresh -iwls95"
   ]

   SideEffects        []

   SeeAlso            [NuSMVCore_add_command_line_option]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_add\_command\_line\_option(char* name, char* usage, char* parameter, boolean (*check\_and\_apply)(OptsHandler\_ptr, char*), boolean public, boolean deprecated, char* dependency, char* conflict)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds a command line option to the system.]

   Description        [Adds a command line option to the system.

   When the command line option is specified, the
   check_and_apply function is called, which should
   first check that the (possible) parameter is
   valid, and then perform an action on it.

   Function arguments:
   1) name -> The name of the cmd line option (e.g. -int)
   2) usage -> The usage string that will be
   printed in the help (i.e. -help)
   3) parameter -> NULL if none, a string value if any.
   e.g: "k" for bmc_length
   4) check_and_apply -> The function that checks
   the (possible) parameter
   value and performs an
   action
   5) public -> Tells whether the cmd line option
   is public or not. If not, the usage
   is not printed when invoking the
   tool with -h.
   6) deprecated -> Tells whether the cmd line
   options is deprecated or not
   7) dependency -> The possibly option name on which this
   one dependens on. NULL if none.
   e.g. -bmc_length depends on -bmc
   8) conflict -> The list of option names that
   conflict with this one.
   e.g. -mono conflicts with
   "-thresh -iwls95"
   ]

   SideEffects        []

   SeeAlso            [NuSMVCore_add_env_command_line_option]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_tool\_name()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm tool_name field getter]

   Description        [The Sm tool_name field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_tool_name]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_tool\_rc\_file\_name()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm tool rc file name field getter]

   Description        [The Sm tool rc file name field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_tool_name]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_tool\_name(char* tool\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm tool_name field setter]

   Description        [The Sm tool_name field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_tool_name]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_tool\_version()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm tool_version field getter]

   Description        [The Sm tool_version field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_tool_version]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_tool\_version(char* tool\_version)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm tool_version field setter]

   Description        [The Sm tool_version field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_tool_version]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_build\_date()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm build_date field getter]

   Description        [The Sm build_date field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_build_date]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_build\_date(char* build\_date)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm build_date field setter]

   Description        [The Sm build_date field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_build_date]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_prompt\_string()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm prompt_string field getter]

   Description        [The Sm prompt_string field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_prompt_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_prompt\_string(char* prompt\_string)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm prompt_string field setter]

   Description        [The Sm prompt_string field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_prompt_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_email()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm email field getter]

   Description        [The Sm email field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_email]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_email(char* email)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm email field setter]

   Description        [The Sm email field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_email]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_website()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm website field getter]

   Description        [The Sm website field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_website]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_website(char* website)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm website field setter]

   Description        [The Sm website field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_website]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_bug\_report\_message()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm bug_report_message field getter]

   Description        [The Sm bug_report_message field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_bug_report_message]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_bug\_report\_message(char* bug\_report\_message)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm bug_report_message field setter]

   Description        [The Sm bug_report_message field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_bug_report_message]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_linked\_addons()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm linked_addons field getter]

   Description        [The Sm linked_addons field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_set_linked_addons]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_linked\_addons(char* linked\_addons)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm linked_addons field setter]

   Description        [The Sm linked_addons field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_linked_addons]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_library\_name()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm library_name field getter]

   Description        [The Sm library_name field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_tool_name]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_library\_version()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm library_version field getter]

   Description        [The Sm library_version field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_tool_version]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_library\_build\_date()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm library_build_date field getter]

   Description        [The Sm library_build_date field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_build_date]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_library\_email()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm library_email field getter]

   Description        [The Sm library_email field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_email]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_library\_website()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm library_website field getter]

   Description        [The Sm library_website field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_website]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* NuSMVCore\_get\_library\_bug\_report\_message()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm library_bug_report_message field getter]

   Description        [The Sm library_bug_report_message field getter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_bug_report_message]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_banner\_print\_fun(void (*banner\_print\_fun)(FILE *))}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm banner_print_fun field setter]

   Description        [The Sm banner_print_fun field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_banner_print_fun]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NuSMVCore\_set\_batch\_fun(void (*batch\_fun)(void))}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The Sm batch fun field setter]

   Description        [The Sm batch fun field setter]

   SideEffects        []

   SeeAlso            [NuSMVCore_get_batch_fun]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static CoreData\_ptr nusmv\_core\_get\_instance()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Initializes (once) the internal core_data variable]

   Description        [Initializes (once) the internal core_data variable]

   SideEffects        []

   SeeAlso            [nusmv_core_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void nusmv\_core\_deinit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Deinitializes and frees the internal variable
   core_data]

   Description        [Deinitializes and frees the internal variable
   core_data. This function should be called
   only when terminating the program]

   SideEffects        []

   SeeAlso            [nusmv_core_get_instance]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static CmdLineOpt\_ptr nusmv\_core\_init\_opt()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Initializes the internal representation structure
   of a command line option]

   Description        [Initializes the internal representation structure
   of a command line option]

   SideEffects        []

   SeeAlso            [nusmv_core_deinit_opt]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void nusmv\_core\_deinit\_opt(CmdLineOpt\_ptr opt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Deinitializes the internal representation structure
   of a command line option]

   Description        [Deinitializes and frees the internal representation
   structure of a command line option]

   SideEffects        []

   SeeAlso            [nusmv_core_init_opt]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void nusmv\_core\_print\_usage(boolean print\_banner)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the command line option usages]

   Description        [Prints the command line option usages.
   If print_banner is true, also the banner is
   printed out. Printed command line options are
   taken from the list of registered ones.]

   SideEffects        []

   SeeAlso            [NuSMVCore_add_command_line_option
   NuSMVCore_add_env_command_line_option]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void nusmv\_core\_print\_string(FILE* out, char* str, int padding)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the given string on the given stream, padded by
   the given number.]

   Description        [Prints the given string on the given stream, padded by
   the given number. If the given string is longer
   than MAX_PRINT_WIDTH, then a new-line is added
   and the remaining part of the string is prinded
   (padded as the previous one). The string is
   divided in such way that no words are
   truncated.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int nusmv\_core\_parse\_line\_options(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Parses the given command line options.]

   Description        [Parses the given command line options.
   -h, -help and input-file are hardcoded options,
   all other options should be registered using
   NuSMVCore_add_env_command_line_option or
   NuSMVCore_add_command_line_option]

   SideEffects        []

   SeeAlso            [NuSMVCore_add_env_command_line_option
   NuSMVCore_add_command_line_option]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char* nusmv\_core\_merge(Olist\_ptr set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a set of unique strings, returns a string
   representing the set of strings, separated by a
   white space]

   Description        [Given a set of unique strings, returns a string
   representing the set of strings, separated by a
   white space]

   SideEffects        []

   SeeAlso            [nusmv_core_split]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int nusmv\_core\_get\_next\_word\_length(char* string)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Aux function for the nusmv_core_split function]

   Description        [Aux function for the nusmv_core_split function]

   SideEffects        []

   SeeAlso            [nusmv_core_split]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Olist\_ptr nusmv\_core\_split(char* string)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a string of white-space separated strings,
   splits the string and builds a set of unique strings]

   Description        [Given a string of white-space separated strings,
   splits the string and builds a set of unique strings]

   SideEffects        []

   SeeAlso            [nusmv_core_merge]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char* nusmv\_core\_tolower(char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Lowercases a string]

   Description        [Lowercases a string]

   SideEffects        []

   SeeAlso            [nusmv_core_merge]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean nusmv\_core\_check\_sin\_fun(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -sin cmd line opt]

   Description        [Check and apply function for the -sin cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean nusmv\_core\_check\_rbc\_fun(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -rbc cmd line opt]

   Description        [Check and apply function for the -rbc cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean nusmv\_core\_set\_mono\_partition(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -mono cmd line opt]

   Description        [Check and apply function for the -mono cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean nusmv\_core\_set\_iwls95\_partition(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -iwls95 cmd line opt]

   Description        [Check and apply function for the -iwls95 cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean nusmv\_core\_set\_thresh\_partition(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -thresh cmd line opt]

   Description        [Check and apply function for the -thresh cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean nusmv\_core\_set\_cpp(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -cpp cmd line opt]

   Description        [Check and apply function for the -cpp cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean nusmv\_core\_set\_pre(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -pre cmd line opt]

   Description        [Check and apply function for the -pre cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean nusmv\_core\_set\_dp(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -dp cmd line opt]

   Description        [Check and apply function for the -dp cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean core\_data\_set\_fs(OptsHandler\_ptr opt, char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check and apply function for the -f cmd line opt]

   Description        [Check and apply function for the -f cmd line opt]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Olist\_ptr nusmv\_core\_olist\_intersection(Olist\_ptr a, Olist\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Calculates the intersection list between a and b]

   Description        [Calculates the intersection list between a and b.
                       The returned list must be freed by the caller]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void nusmv\_core\_olist\_union(Olist\_ptr a, Olist\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds all elements in b to a, if a does
                       not contain it already]

   Description        [Adds all elements in b to a, if a does
                       not contain it already]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void nusmv\_core\_free\_line\_options(CoreData\_ptr core\_data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Frees the line_options hash and all it's contents]

   Description        [Frees the line_options hash and all it's contents]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{cinitDummyMac.c}
		
	\subsection{cinitInit.c}
		
	\texttt{void CInit\_reset\_first()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Shuts down and restarts the system, shut down part]

  Description [Shuts down and restarts the system, shut down part]

  SideEffects []

  SeeAlso     [CInit_reset_last]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_reset\_last()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Shuts down and restarts the system, restart part]

  Description [Shuts down and restarts the system, restart part]

  SideEffects []

  SeeAlso     [CInit_reset_first]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Calls the initialization routines of all the packages.]

  SideEffects [Sets the global variables nusmv_stdout, nusmv_stderr,
  nusmv_historyFile.]

  SeeAlso     [SmEnd]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_end()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Calls the end routines of all the packages.]

  SideEffects [Closes the output files if not the standard ones.]

  SeeAlso     [CInit_Init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void init\_preprocessors()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes information about the pre-processors avaliable.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char* get\_executable\_name(const char* command)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given a command, returns the executable file name (with
  extension if required)]

  SideEffects [If not already specified, extension suffix is appended
  to the returned string. Returned string must be freed.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void quit\_preprocessors(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes information regarding the avaliable pre-processors.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* get\_preprocessor\_call(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the command line call for the specified pre-processor
  name. Returns NULL if given name is not available, or a string that must be
  NOT freed]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* get\_preprocessor\_filename(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the actual program name of the specified pre-processor.
  Returns NULL if given name is not available, or a string that must be
  freed]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int get\_preprocessors\_num()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the number of available proprocessors]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* get\_preprocessor\_names()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the names of the avaliable pre-processors. Returned
  string must be freed]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{cinitMisc.c}
		
	\texttt{void cinitBatchMain()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The batch main.]

  Description [The batch main. It first read the input file, than
  flatten the hierarchy. Aftre this preliminar phase it creates the
  boolean variables necessary for the encoding and then start
  compiling the read model into BDD. Now computes the reachable states
  depending if the flag has been set. before starting verifying if the
  properties specified in the model hold or not it computes the
  fairness constraints. You can also activate the reordering and
  also choose to avoid the verification of the properties.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CInit\_NusmvrcSource()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sources the .nusmvrc file.]

  Description [Sources the .nusmvrc file.  Always sources the .nusmvrc from
  library.  Then source the .nusmvrc from the home directory.  If there is none
  in the home directory, then execute the one in the current directory if one
  is present.  Returns 1 if scripts were successfully executed, else return 0.]

  SideEffects []

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void print\_usage(FILE * file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints usage statistic.]

  Description        [Prints on <code>nusmv_stdout</code> usage
  statistics, i.e. the amount of memory used, the amount of time
  spent, the number of BDD nodes allocated and the size of the model
  in BDD.]

  SideEffects        []

  SeeAlso            [compilePrintBddModelStatistic]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void save\_nusmv\_stdout()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Saves internally the current FILE used for stdout]

  Description [Saves internally the current FILE used for stdout, for
  later restoring with restore_nusmv_stdout. The saved values are not
  stacked, only the current value is saved.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void restore\_nusmv\_stdout()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Restores a previously saved file.]

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void set\_nusmv\_stdout(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Opens and sets the current nusmv_stdout]

  Description [This function does not close the previously set
  nusmv_stdout.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FILE* get\_nusmv\_stdout()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the previously set internal nusmv_stdout]

  Description [Use this function only as input of the nusmv's library
  functions. Do NOT use it in CRTs different from the CRT the library
  was compiled with (e.g. in MSVC CRT when the library was compiled
  with mingw), or the application will crash. For example, do not call
  fprintf on the returned FILE*, if the CRT is not the same.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void print\_nusmv\_stdout(const char* fmt, ...)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the given string to stdout]

  Description        [Use this function to print on stdout from a different
  CRT.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void close\_nusmv\_stdout()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Closes the current nusmv_stdout]

  Description        [To use stdout, you will have to set a different value
  or restore it after calling this function. Do NOT close the default stdout.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void save\_nusmv\_stderr()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Saves internally the current FILE used for stderr]

  Description [Saves internally the current FILE used for stderr, for
  later restoring with restore_nusmv_stderr. The saved values are not
  stacked, only the current value is saved.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void restore\_nusmv\_stderr()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Restores a previously saved file.]

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void set\_nusmv\_stderr(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Opens and sets the current nusmv_stderr]

  Description [This function does not close the previously set
  nusmv_stderr.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FILE* get\_nusmv\_stderr()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the previously set internal nusmv_stderr]

  Description [Use this function only as input of the nusmv's library
  functions. Do NOT use it in CRTs different from the CRT the library
  was compiled with (e.g. in MSVC CRT when the library was compiled
  with mingw), or the application will crash. For example, do not call
  fprintf on the returned FILE*, if the CRT is not the same.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void print\_nusmv\_stderr(const char* fmt, ...)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the given string to stderr]

  Description        [Use this function to print on stderr from a different
  CRT.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void close\_nusmv\_stderr()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Closes the current nusmv_stderr]

  Description        [To use stderr, you will have to set a different value
  or restore it after calling this function. Do NOT close the default stderr.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void nusmv\_FREE(void* ptr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees the memory pointed by ptr]

  Description [Use this function like FREE(), to free all memory
  allocated by the core (with ALLOC), and returned to the user
  which is responsible for its disposal. 

  WARNING! This function *must* be used instead of FREE() when the
  memory disposal has to be done from within an environment which
  uses a memory allocator different from the one used by the
  core. For example, this is the case when using nusmv as a library
  compiled with a compiler, from external software compiled with a
  _different_ compiler which uses a different CRT.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{cinitVers.c}
		
	\texttt{char* CInit\_NuSMVReadVersion()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the current NuSMV version.]

  Description [Returns a static string giving the NuSMV version and compilation
  timestamp.  The user should not free this string.]

  SideEffects []

  SeeAlso     [CInit_NuSMVObtainLibrary]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* CInit\_NuSMVObtainLibrary()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the NuSMV library path.]

  Description [Returns a string giving the directory which contains
               the standard NuSMV library.  Used to find things like
               the default .nusmvrc, the on-line help files, etc. It
               is the responsibility of the user to free the returned
               string.]

  SideEffects []

  SeeAlso     [CInit_NuSMVReadVersion]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_NuSMVInitPrintMore()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Start piping stdout through the "more" command]

  Description        [This function is  called to initialize piping
                      stdout through "more". It is important to call
                      CInit_NuSMVEndPrintMore before returning from
                      your function and after calling
                      CInit_NuSMVInitPrintMore (preferably at the end
                      of your printing; failing to do so will cause
                      the stdin lines not to appear).]

  SideEffects        []

  SeeAlso            [ CInit_NuSMVEndPrintMore]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CInit\_NuSMVEndPrintMore()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Stop piping stdout through the "more" command]

  Description        [This function is  called to terminate piping
                      stdout through "more". It is important to call
                      CInit_NuSMVEndPrintMore before exiting your
                      function (preferably at the end of your
                      printing; failing to do so will cause the stdin
                      lines not to appear). The function returns a 0
                      if it fails.]

  SideEffects        []

  SeeAlso            [ CInit_NuSMVInitPrintMore]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_BannerPrint(FILE * file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints the banner of NuSMV.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_BannerPrintLibrary(FILE * file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints the COMPLETE banner of the NuSMV library.]

  Description [To be used by addons linking against the NuSMV library.
               You can use this as banner print function if you don't
               need a special banner print function and you are
               linking against NuSMV]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_BannerPrint\_nusmv\_library(FILE * file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints the banner of the NuSMV library.]

  Description [To be used by tools linking against the NuSMV library
               and using custom banner function]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_BannerPrint\_cudd(FILE * file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints the banner of cudd.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_BannerPrint\_minisat(FILE * file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints the banner of minisat.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CInit\_BannerPrint\_zchaff(FILE * file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints the banner of zchaff.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cinit\_banner\_print(FILE* file, boolean is\_linked)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints the banner of NuSMV. ]

  Description [Prints the banner of NuSMV. If is_linked is true,
               also the NuSMV library banner is output]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char * DateReadFromDateString( char * datestr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the date in a brief format assuming its coming from
  the program `date'.]

  Description [optional]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\section{cmd}
		
	\subsection{cmdCmd.c}
		
	\texttt{void Cmd\_CommandAdd(char* name, PFI funcFp, int changes, boolean reentrant)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Adds a command to the command table.]

  Description [Adds a command to the command table.  If name already defines
  an existing command, its definition is replaced.  FuncFp is a function
  pointer to code of the form: <p>

                int <br>
		CommandTest(argc, argv)<br>
                  int argc;<br>
                  char **argv;<br>
                {<br>
		    return 0;<br>
		}<p>

  argv\[0\] will generally
  be the command name, and argv\[1\] ... argv\[argc-1\] are the arguments for the
  command.  util_getopt() can be used to parse the arguments, but
  util_getopt_reset() must be used before calling util_getopt().  The command
  function should return 0 for normal operation, 1 for any error.  The changes
  flag is used to automatically save the hmgr before executing the command (in
  order to support undo).
  The flag reentrant is true if the command execution can be interrupted without
  leaving the internal status inconsistent.
  ]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Cmd\_CommandRemove(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes given command from the command table.]

  Description [Returns true if command was found and removed,
  false if not found]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Cmd\_CommandDefined(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [True iff a command named 'name' is defined.]

  Description []

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{CommandDescr\_t *Cmd\_CommandGet(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the command stored under 'name' in the command table.]

  Description [Returned value does not belong to caller.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Cmd\_CommandExecute(char* command)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Executes a command line.]

  Description [Executes a command line.  This is the top-level of the command
  interpreter, and supports multiple commands (separated by ;), alias
  substitution, etc.  For many simple operations, Cmd_CommandExecute() is the
  easiest way to accomplish a given task. For example, to set a variable, use
  the code: Cmd_CommandExecute("set color blue").]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Cmd\_SecureCommandExecute(char* command)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Secure layer for Cmd_CommandExecute]

  Description [This version is securly callable from scripting languages. 
  Do not call Cmd_CommandExecute directly from a scripting language, otherwise
  the script execution could be aborted without any warning.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CmdCommandFree( char * value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{CommandDescr\_t * CmdCommandCopy( CommandDescr\_t * value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Copies value.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int com\_dispatch( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int apply\_alias( int * argcp, char *** argvp, int * loop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies alias.]

  Description [Applies alias.  If perform a history substitution in expanding
  an alias, remove all the orginal trailing arguments.  For example:<p>

    > alias t rl \!:1<br>
    > t lion.blif  would otherwise expand to   rl lion.blif lion.blif <br>]

  SideEffects []

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void variableInterpolation(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Allows interpolation of variables]

  Description [Allows interpolation of variables. Here it is implemented by
  allowing variables to be referred to with the prefix of '$'. The variables
  are set using the "set" command. So for example, the following can be done <p>

  <code>
  NuSMV> set foo bar <br>
  NuSMV> echo $foo <br>
  bar <br>
  </code>
  
  The last line "bar" will the output produced by NuSMV.

  The following can also be done: <p>
  
  <code>
  NuSMV> set foo $foo:foobar <br>
  NuSMV> echo $foobar <br>
  bar:foobar <br>
  </code>
  The last line will be the output produced by NuSMV. <p>

  These variables can
  be used in recursive definitions. The following termination characters are

  Although the set command allows the usage of the some of the
  above termination characters between quotes, 
  the variable interpolation procedure has the restriction
  that the two characters ':' and '/' may not be used with quotes.
  A variable with spaces in it may be used only if it is enclosed
  within quotes. ]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char * variableInterpolationRecur(char *str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Recursive procedure that expands the interpolation variables]

  Description [Recursive procedure that expands the interpolation variables.
  This procedure is designed to handle multiple occurrences of variables
  in a string and recursive definitions. If the expanded variable has another
  variable, then the procedure is called recursively. The existence of a
  variable is identified by the $ sign in the string. But since this may be
  an environment variable too, the variable is untouched if not found in
  this table. A sophisticated check can be made to see if this variable
  exists in the environment, but it is NOT done here. Therefore, detection
  of bogus values cannot be done. The procedure steps through the string
  to see if any variables are present. If a termination character (one of
  :, /) is found after the '$', then the variable
  is identified and looked up in the flag table. If the returned string again
  has a dollar, then the procedure is called recursively. If not, the returned
  value replaces the variable and the stepping through continues. If the
  variable is not found, then it might be an environment variable.So the
  procedure leaves the variable there. ]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char * split\_line( char * command, int * argc, char *** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int check\_shell\_escape(char* p, int* status)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sigterm(int sig)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Signal handler.]

  SideEffects []

  SeeAlso     [com_dispatch]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void arm\_signal\_andler()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Enable signal trapping depending on the interactive/batch
  mode.]

  SideEffects []

  SeeAlso     [com_dispatch]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void disarm\_signal\_andler()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Enable signal trapping depending on the interactive/batch
  mode.]

  SideEffects []

  SeeAlso     [com_dispatch]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{cmdFile.c}
		
	\texttt{FILE * Cmd\_FileOpen( char * fileName, char * mode, char ** realFileName\_p, int silent)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Opens the file with the given mode.]

  Description [Opens the file with the given mode (see fopen()).  Tilde
  expansion (~user/ or ~/) is performed on the fileName, and "-" is allowed as
  a synonym for stdin (or stdout, depending on the mode).  If the file cannot
  be opened, a message is reported using perror(); the silent flag, if true,
  suppresses this error action.  In either case, A NULL file pointer is
  returned if any error occurs.  The fileName (after tilde expansion) is
  returned in the pointer realFileName, if realFileName is non-empty.  This
  is a pointer which should be free'd when you are done with it.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* CmdFgetsFilec(char* buf, int size, FILE* stream, char* prompt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Duplicates the function of fgets, but also provides file
  completion in the same style as csh]

  Description [ Input is read from `stream' and returned in `buf'.  Up to
  `size' bytes will be placed into `buf'.  If `stream' is not stdin, is
  equivalent to calling fgets(buf, size, stream).

  `prompt' is the prompt you want to appear at the beginning of the line.  The
  caller does not have to print the prompt string before calling this routine.
  The prompt has to be reprinted if the user hits ^D.

  The file completion routines are derived from the source code for csh, which
  is copyrighted by the Regents of the University of California.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* CmdFgetsFilec(char* buf, int size, FILE* stream, char* prompt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int cmp( char ** s1, char ** s2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int match( char * newmatch, char * lastmatch, char * actual)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char * CmdHistorySubstitution( char * line, int * changed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Simple history substitution routine.]

  Description [Simple history substitution routine. Not, repeat NOT, the
  complete csh history substitution mechanism.

  In the following ^ is the SUBST character and ! is the HIST character.
  Deals with:
        !!                      last command
        !stuff                  last command that began with "stuff"
        !*                      all but 0'th argument of last command
        !$                      last argument of last command
        !:n                     n'th argument of last command
        !n                      repeat the n'th command
        !-n                     repeat n'th previous command
        ^old^new                replace "old" w/ "new" in previous command


  Trailing spaces are significant. Removes all initial spaces.

  Returns `line' if no changes were made.  Returns pointer to a static buffer
  if any changes were made.  Sets `changed' to 1 if a history substitution
  took place, o/w set to 0.  Returns NULL if error occurred.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int getnum( char ** linep)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char * getarg( char * line, int num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char * bad\_event( int n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char * do\_subst( char * dest, char * new)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void print\_prompt(char* prompt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char * removeWhiteSpaces( char *string)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Removes tabs and spaces from the beginning and end of string.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{cmdMisc.c}
		
	\texttt{void Cmd\_Init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes the command package.]

  SideEffects [Commands are added to the command table.]

  SeeAlso     [Cmd_End]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Cmd\_End()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Ends the command package.]

  Description [Ends the command package. Tables are freed.]

  SideEffects []

  SeeAlso     [Cmd_Init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FILE* CmdOpenPipe(int useMore)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Opens a pipe with a pager]

  Description [Returns NULL if an error occurs]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CmdClosePipe(FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Closes a previously opened pipe]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FILE* CmdOpenFile(const char* filename)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Open a file whose name is given]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CmdCloseFile(FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Closes a previously opened file]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CmdFreeArgv(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CmdAliasFree( char * value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandTime(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Implements the time command.]

  CommandName       [time]

  CommandSynopsis   [Provides a simple CPU elapsed time value]

  CommandArguments [\[-h\]]

  CommandDescription [Prints the processor time used since the last invocation
  of the \"time\" command, and the total processor time used since NuSMV
  was started.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandEcho(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the echo command.]

  CommandName        [echo]

  CommandSynopsis    [Merely echoes the arguments. File redirection is allowed.]

  CommandArguments   [\[-h\] \[-2\] \[-n\] \[-o filename \[-a\]\] &lt;args&gt;]

  CommandDescription [Echoes its arguments to standard output.
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-2</tt>
     <dd> Redirects output to the standard error instead of the
     standard output. This cannot be used in combination with -o.
    <dt> <tt>-n</tt>
     <dd> Does not output the trailing newline.
    <dt> <tt>-o filename</tt>
     <dd> Echoes on the specified file instead of on the standard output.
    <dt> <tt>-a</tt>
     <dd> When used with option -o, appends the output to the specified file
          instead of overwriting it.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandMemoryProfile( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Implements the _memory_profile command.]

  CommandName [_memory_profile]

  CommandSynopsis [It shows the amount of memory used by every package.]

  CommandArguments [\[-f &lt;filename&gt;\] \[-h\] \[-p\] \[-u &lt;units&gt;\]]

  CommandDescription [This command intregrates the output from purify with a
  function map generated by a perlscript plus another perlscript to generate a
  memory profile of NuSMV.<p>

  This command relies on the output of purify to a file to call the script
  "memoryaccount" and produces a summary of how much memory has been allocated
  by each package. Although this command may appear simple it requires the
  interaction of two scripts and three files, so special care should be taken
  when attempting to modify it.<p>

  Here is the way it works. The code in this command is conditionally compiled
  depending on the definition of the symbol <tt>PURIFY</tt>. If the symbol is
  not defined, the program prints a message notifying that the command is not
  operative in this executable. If <tt>PURIFY</tt> has been defined, there are
  certain things that are assumed. The executable has been linked with
  purify. The output of purify is being redirected to a file with name
  <tt>purify.log</tt>. The perl script <tt>memoryaccount</tt> is in
  <tt>$NuSMV_LIBRARY_PATH/common/share</tt> and it is
  executable. There exists a file whose name is <tt>.fmap</tt>, located
  in the same directory which script memoryaccount is located in. This file
  maps function names to packages which contain them.<p>

  The command then calls <tt>purify_all_inuse()</tt> to force purify to dump to
  the file <tt>purify.log</tt> all information about the memory that is
  currently visible to the program. This memory is not the total memory
  allocated by the program since there may be leaked memory that is no longer
  accessible. A temporary file is created and the script <tt>memoryaccount</tt>
  is called to analyze the file <tt>purify.log</tt> and write in the temporary
  file the memory profile obtained from it. Once the script is done, the
  temporary file is dumped to <tt>nusmv_stdout</tt> and deleted.<p>

  Since most of the computation in this command is done by the pearlscript
  <tt>memoryaccount</tt>, for more information please refer to the message
  printed when the script is invoked with the option <tt>-h</tt>.

  Command options:<p>

  <dl>
     <dt> -f &lt;filename&gt;
        <dd> File to read the dump from. The default is
             purify.log. This option should be used if and only if the
             option <tt>-log-file</tt> has been used at the linking
             stage when building the executable.
     <dt> -p
          <dd> Prints also the packages that did not allocated any detectable
          memory
     <dt> -u &lt;units&gt;
         <dd> Units to print the memory usage in. It may be "b" for
               bytes, "k" for kilobytes, "m" for megabytes and "g" for
               gigabytes. The default is bytes.
  </dl>
  ]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandQuit( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Implements the quit command.]

  Description [A return value of -1 indicates a quick quit, -2 return frees
  the memory, -4 an instant quit]

  CommandName       [quit]

  CommandSynopsis   [exits NuSMV]

  CommandArguments  [\[-h\] \[-s\] \[-x\]]

  CommandDescription [Stops the program.  Does not save the current network
  before exiting.<p>

  Command options:<p>
  <dl>
     <dt> -s
     <dd> Frees all the used memory before quitting.
          This is slower, and it is used for finding memory leaks.
     <dt> -x
     <dd> Leave immediately. Skip all the cleanup code, leave it to
          the OS. This can save quite a long time.

  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandUsage( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Implements the usage command.]

  CommandName       [usage]

  CommandSynopsis   [Provides a dump of process statistics]

  CommandArguments  [\[-h\]]

  CommandDescription [Prints a formatted dump of processor-specific usage
  statistics. For Berkeley Unix, this includes all of the information in the
  getrusage() structure.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandWhich( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Implements the which command.]

  CommandName       [which]

  CommandSynopsis   [Looks for a file called \"file_name\"]

  CommandArguments  [\[-h\] &lt;file_name&gt;]

  CommandDescription [Looks for a file in a set of directories
  which includes the current directory as well as those in the NuSMV path.
  If it finds the specified file, it reports the found file's path.
  The searching path is specified through the "<tt>set open_path</tt>" command
  in \"<tt>.nusmvrc</tt>\".<p>

  Command options:<p>
  <dl>
     <dt> &lt;file_name&gt;
         <dd> File to be searched
  </dl>]

  SideEffects       []

  SeeAlso           [set]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandHistory( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Implements the history command.]

  CommandName       [history]

  CommandSynopsis   [list previous commands and their event numbers]

  CommandArguments  [\[-h\] \[&lt;num&gt;\]]

  CommandDescription [Lists previous commands and their event numbers.
  This is a UNIX-like history mechanism inside the NuSMV shell.<p>
  Command options:<p>
  <dl>
     <dt> &lt;num&gt;
         <dd> Lists the last &lt;num&gt; events.  Lists the last 30
              events if &lt;num&gt; is not specified.
  </dl><p>

  History Substitution:<p>

  The history substitution mechanism is a simpler version of the csh history
  substitution mechanism.  It enables you to reuse words from previously typed
  commands.<p>

  The default history substitution character is the `%' (`!' is default for
  using the "set" command. In this description '%' is used as the history_char.
  The `%' can appear anywhere in a line.  A line containing a history
  substitution is echoed to the screen after the substitution takes place.
  `%' can be preceded by a `\\' in order to escape the substitution,
  for example, to enter a `%' into an alias or to set the prompt.<br><p>

  Each valid line typed at the prompt is saved.  If the "history" variable
  is set (see help page for "set"), each line is also echoed to the history
  file.  You can use the "history" command to list the previously typed
  commands. <p>

  Substitutions: <p>

  At any point in a line these history substitutions are
  available.<p>
        <dl><dt>%:0   <dd>  Initial word of last command.</dl>
        <dl><dt>%:n   <dd>   n-th argument of last command.</dl>
        <dl><dt>%$    <dd>   Last argument of last command.</dl>
        <dl><dt>%*    <dd>   All but initial word of last command.</dl>

        <dl><dt>%%    <dd>   Last command.</dl>
        <dl><dt>%stuf <dd>   Last command beginning with "stuf".</dl>
        <dl><dt>%n    <dd>   Repeat the n-th command.</dl>
        <dl><dt>%-n   <dd>   Repeat the n-th previous command.</dl>
        <dl><dt>^old^new  <dd>       Replace "old" with "new" in previous command.
        Trailing spaces are significant during substitution.
        Initial spaces are not significant.</dl>  ]

  SideEffects        []

  SeeAlso            [set]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandAlias( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Implements the alias command.]

  CommandName       [alias]

  CommandSynopsis   [Provides an alias for a command]

  CommandArguments  [\[-h\] \[&lt;name&gt; \[&lt;string&gt;\]\]]

  CommandDescription [The "alias" command, if given no arguments, will print
  the definition of all current aliases.  <p>

  Given a single argument, it will print the definition of that alias (if any).

  Given two arguments, the keyword <tt>&lt;name&gt;</tt> becomes an alias for
  the command string <tt>&lt;string&gt;</tt>, replacing any other alias with
  the same name.<p>

  Command options:
  <dl>
     <dt> &lt;name&gt;
        <dd> Alias
     <dt> &lt;string&gt;
        <dd> Command string
  </dl>

  It is possible to create aliases that take arguments by using the history
  substitution mechanism. To protect the history substitution
  character `<tt>%</tt>' from immediate expansion, it must be preceded
  by a `<tt>\\</tt>' when entering the alias.<p>

  For example:<p>
  <code>
   NuSMV> alias read "read_model -i \\%:1.smv ; set input_order_file \\%:1.ord"
   NuSMV> read short
  </code><p>
  will create an alias `read', execute "read_model -i short.smv;
    set input_order_file short.ord".<p>

  And again:<p>
  <code>
  NuSMV> alias echo2 "echo Hi ; echo \\%* !" <br>
  NuSMV> echo2 happy birthday
  </code><p>

  will print:<p>

  <code>
  Hi<br>
  happy birthday !
  </code><br>

  CAVEAT: Currently there is no check to see if there is a circular
  dependency in the alias definition. e.g.<p>

  <code>
  NuSMV> alias foo "echo print_bdd_stats; foo"
  </code><br>

  creates an alias which refers to itself. Executing the command <tt>foo</tt>
  will result an infinite loop during which the command
  <tt>print_bdd_stats</tt> will be executed.
  ]

  SideEffects        []

  SeeAlso            [unalias]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandUnalias( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the unalias command.]

  CommandName        [unalias]

  CommandSynopsis    [Removes the definition of an alias.]

  CommandArguments   [\[-h\] &lt;alias-names&gt;]

  CommandDescription [Removes the definition of an alias specified via the
  alias command.<p>

  Command options:<p>
  <dl>
     <dt> &lt;alias-names&gt;
     <dd> Aliases to be removed
  </dl>]

  SideEffects        []

  SeeAlso            [alias]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandHelp(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the help command.]

  CommandName        [help]

  CommandSynopsis    [Provides on-line information on commands]

  CommandArguments   [\[-a\] \[-h\] \[&lt;command&gt;\]]

  CommandDescription [If invoked with no arguments "help" prints the list of
  all commands known to the command interpreter.
  If a command name is given, detailed information for that command will be
  provided.<p>

  Command options:<p>
  <dl>
      <dt> -a
          <dd> Provides a list of all internal commands, whose names begin
          with the underscore character ('_') by convention.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandSource( int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Implements the source command.]

  CommandName       [source]

  CommandSynopsis   [Executes a sequence of commands from a file]

  CommandArguments  [\[-h\] \[-p\] \[-s\] \[-x\] &lt;file&gt; \[&lt;args&gt;\]]

  CommandDescription [Reads and executes commands from a file.<p>
  Command options:<p>
  <dl>
    <dt> -p
       <dd> Prints a prompt before reading each command.
    <dt> -s
       <dd> Silently ignores an attempt to execute commands from a nonexistent file.
    <dt> -x
       <dd> Echoes each command before it is executed.
    <dt> &lt;file&gt;
       <dd> File name
  </dl>

  Arguments on the command line after the filename are remembered but not
  evaluated.  Commands in the script file can then refer to these arguments
  using the history substitution mechanism.<p>

  EXAMPLE:<p>

  Contents of test.scr:<p>

  <br><code>
  read_model -i %:2<br>
  flatten_hierarchy<br>
  build_variables<br>
  build_model<br>
  </code><br>

  Typing "source test.scr short.smv" on the command line will execute the
  sequence<p>

  <br><code>
  read_model -i short.smv<br>
  flatten_hierarchy<br>
  build_variables<br>
  build_model<br>
  </code><br>

  (In this case <code>%:0</code> gets "source", <code>%:1</code> gets
  "test.scr", and <code>%:2</code> gets "short.smv".)
  If you type "alias st source test.scr" and then type "st short.smv bozo",
  you will execute<p>

  <br><code>
  read_model -i bozo<br>
  flatten_hierarchy<br>
  build_variables<br>
  build_model<br>
  </code><br>

  because "bozo" was the second argument on the last command line typed.  In
  other words, command substitution in a script file depends on how the script
  file was invoked. Switches passed to a command are also counted as
  positional parameters. Therefore, if you type "st -x short.smv bozo",
  you will execute

  <br><code>
  read_model -i short.smv<br>
  flatten_hierarchy<br>
  build_variables<br>
  build_model<br>
  </code><br>

  To pass the "-x" switch (or any other switch) to "source" when the
  script uses positional parameters, you may define an alias. For
  instance, "alias srcx source -x".<p>

  returns -3 if an error occurs and the flag 'on_failure_script_quits'
  is set.  ]

  SideEffects        []

  SeeAlso            [history]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandShowHelp(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the _show_help command.]

  CommandName        [_show_help]

  CommandSynopsis    [Provides on-line information for all commands]

  CommandArguments   [\[-f\] \[-h\] \[&lt;command&gt;\]]

  CommandDescription [If invoked with no arguments prints the short help
  for all commands known to the command interpreter including
  hidden commands (those whose name starts with _).<p>

  Command options:<p>
  <dl>
      <dt> -f </dt>
          <dd> Prints for each command the long help.</dd>

  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void print\_alias( char * value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char *command\_completion\_generator(const char *text, int state)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Generate completion matches for readline.]

  Description [Based on the partial input and the list of installed commands
                generates the possible completions.]

  SideEffects [none]

  SeeAlso     [Cmd_Completion]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char ** command\_completion(const char *text, int start, int end)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets up command or filename completion on reading user input.]

  Description [We use the regular NuSMV command completion function for the
                first word on the line, and filename completion for the rest.]

  SideEffects [none]

  SeeAlso     [CmdCompletion_Generator]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char * command\_alias\_help( char * command)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void FlushBuffers( int sigtype)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Function to flush nusmv_stdout and nusmv_stderr.]

  Description [This function is the signal handler for the SIGUSR1
  signal. Whenever that signal is received, this function is executed and the
  output channels of NuSMV are flushed.]

  SideEffects        []

  SeeAlso            [Cmd_Init]

******************************************************************************/

	\end{verbatimtab}
	
	\section{compile}
		
	\section{symb\_table}
		
	\subsection{NFunction.c}
		
	\texttt{NFunction\_ptr NFunction\_create\_uninterpreted(int num\_args, SymbType\_ptr* args, SymbType\_ptr ret)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction class constructor]

  Description        [The NFunction class constructor]

  SideEffects        []

  SeeAlso            [NFunction_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NFunction\_ptr NFunction\_create\_interpreted(int num\_args, SymbType\_ptr* args, SymbType\_ptr ret, void* body)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction class constructor]

  Description        [The NFunction class constructor]

  SideEffects        []

  SeeAlso            [NFunction_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NFunction\_destroy(NFunction\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction class destructor]

  Description        [The NFunction class destructor]

  SideEffects        []

  SeeAlso            [NFunction_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int NFunction\_get\_args\_number(NFunction\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction args_number field getter]

  Description        [The NFunction args_number field getter]

  SideEffects        []

  SeeAlso            [NFunction_set_args_number]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr NFunction\_get\_args(NFunction\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction args field getter]

  Description        [The NFunction args field getter]

  SideEffects        []

  SeeAlso            [NFunction_set_args]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr NFunction\_get\_main\_type(NFunction\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction main_type field getter]

  Description        [The NFunction main_type field getter]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean NFunction\_is\_uninterpreted(NFunction\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction is_uninterpreted field getter]

  Description        [The NFunction is_uninterpreted field getter]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* NFunction\_get\_body(NFunction\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction body field getter]

  Description        [The NFunction body field getter]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr NFunction\_get\_return\_type(NFunction\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction return_type field getter]

  Description        [The NFunction return_type field getter]

  SideEffects        []

  SeeAlso            [NFunction_set_return_type]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void n\_function\_init(NFunction\_ptr self, int num\_args, SymbType\_ptr* args, SymbType\_ptr ret, boolean is\_uninterpreted, void* body)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction class private initializer]

  Description        [The NFunction class private initializer]

  SideEffects        []

  SeeAlso            [NFunction_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void n\_function\_deinit(NFunction\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NFunction class private deinitializer]

  Description        [The NFunction class private deinitializer]

  SideEffects        []

  SeeAlso            [NFunction_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ResolveSymbol.c}
		
	\texttt{ResolveSymbol\_ptr ResolveSymbol\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ResolveSymbol class constructor]

  Description        [The ResolveSymbol class constructor]

  SideEffects        []

  SeeAlso            [ResolveSymbol_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ResolveSymbol\_destroy(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ResolveSymbol class destructor]

  Description        [The ResolveSymbol class destructor]

  SideEffects        []

  SeeAlso            [ResolveSymbol_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_undefined(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the resolved symbol is undefined or not.]

  Description        [Checks if the resolved symbol is undefined or not.
                      Returns true if the symbol is undefined. A
                      symbol is undefined if it is not declared within
                      the symbol table (i.e it is not a var, a define,
                      an array define, an array, a parameter or a
                      constant)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_defined(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the resolved symbol is defined or not.]

  Description        [Checks if the resolved symbol is defined or not.
                      Returns true if the symbol is defined. A
                      symbol is defined if it is declared within
                      the symbol table (i.e it is a var or a define,
                      an array define, an array, a parameter or a
                      constant)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_ambiguous(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the symbol is ambiguos or not.]

  Description        [Checks if the symbol is ambiguos or not. A symbol
                      is ambiguos if it is declared more than once
                      (e.g. as a variable and as a constant)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_var(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the symbol is a variable]

  Description        [Checks if the symbol is a variable]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_define(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the symbol is a define]

  Description        [Checks if the symbol is a define]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_function(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the symbol is a function]

  Description        [Checks if the symbol is a function]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_constant(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the symbol is a constant]

  Description        [Checks if the symbol is a constant]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_parameter(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the symbol is a parameter (formal)]

  Description        [Checks if the symbol is a parameter (formal)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_array(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the symbol is an array]

  Description        [Checks if the symbol is an array]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_array\_def(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the symbol is an array define]

  Description        [Checks if the symbol is an array define]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr ResolveSymbol\_get\_resolved\_name(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the resolved name of the symbol]

  Description        [Returns the resolved name of the symbol]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ResolveSymbol\_is\_error(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if there has been some error in the
                      resolution of the symbol]

  Description        [Check if there has been some error in the
                      resolution of the symbol]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* ResolveSymbol\_get\_error\_message(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the error message, if any error occurred.]

  Description        [Get the error message, if any error occurred.
                      The returned message has to be freed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ResolveSymbol\_print\_error\_message(ResolveSymbol\_ptr self, FILE* stream)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the error message, if any error occurred.]

  Description        [Prints the error message on the given stream, 
                      if any error occurred.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ResolveSymbol\_throw\_error(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Throws an internal error if an error occurred.]

  Description        [Throws an internal error if an error occurred.
                      The error MUST exist, so the function should be
                      used in couple with ResolveSymbol_is_error. The
                      printed message is taken using
                      ResolveSymbol_get_error_message, and rpterr is
                      used for throwing the error.]

  SideEffects        []

  SeeAlso            [ResolveSymbol_get_error_message ResolveSymbol_is_error]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr ResolveSymbol\_resolve(ResolveSymbol\_ptr self, SymbTable\_ptr st, node\_ptr name, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Resolves the given symbol in the given context, and 
                      returns it.]

  Description        [Resolves the given symbol in the given context, and
                      returns it.

                      This function has to be called before any other
                      function, since it initializes the internal
                      structure. The internal structure is reset
                      before doing anything else.

                      It is possible to get the resolved name later by calling 
                      get_resolved_name.
                      ]

  SideEffects        []

  SeeAlso            [ResolveSymbol_get_resolved_name]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void resolve\_symbol\_init(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ResolveSymbol class private initializer]

  Description        [The ResolveSymbol class private initializer]

  SideEffects        []

  SeeAlso            [ResolveSymbol_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void resolve\_symbol\_deinit(ResolveSymbol\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ResolveSymbol class private deinitializer]

  Description        [The ResolveSymbol class private deinitializer]

  SideEffects        []

  SeeAlso            [ResolveSymbol_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr resolve\_symbol\_resolve\_name(const SymbTable\_ptr symb\_table, node\_ptr name, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Takes an expression representing an identifier
   and recursively normalizes it.]

   Description [The result of this function is a properly formed
   identifier, find_atom-ed, and suitable to access hash tables such
   as symbol table, etc.

   An input expression may be a simple or complex (with DOT)
   identifier, a bit or an array element.

   Note: identifiers are not expanded, i.e. defines and formal parameters
   are not substituted by the corresponding expressions.

   Nil is returned if the given expression is not syntactically an
   identifier.

   Currently, arrays are additionally flattened to maintain old code.
   See the description of compileFlattenSexpRecur for info about ARRAY.
   ]

   SideEffects        []

   SeeAlso            [resolve_symbol_resolve_name_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr resolve\_symbol\_resolve\_name\_recur(const SymbTable\_ptr symb\_table, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Performs the name "normalization", i.e.
   applies find_node and merges context with the identifier.]

   Description        [
   If name is complex and first ATOM is a parameter then the parameter is
   substituted by its value (in order to pass modules in parameters and
   access their members).
   Returns TYPE_ERROR if not resolvable name is provided]

   SideEffects        []

   SeeAlso            [resolve_symbol_resolve_name]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SymbCache.c}
		
	\texttt{SymbCache\_ptr SymbCache\_create(SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class constructor]

  Description        [Callable only by the SymbTable instance that owns self.
  The caller keeps the ownership of given SymbTable instance]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_destroy(SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class destructor]

  Description        [Callable only by the SymbTable instance that owns self.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_input\_var(SymbCache\_ptr self, node\_ptr var, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares a new input variable.]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_state\_var(SymbCache\_ptr self, node\_ptr var, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares a new state variable.]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_frozen\_var(SymbCache\_ptr self, node\_ptr var, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares a new frozen variable.]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            [SymbCache_redeclare_state_as_frozen_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_redeclare\_state\_as\_frozen\_var(SymbCache\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Redeclare a state variable as a frozen variable]

  Description [A variable is frozen if it is known that its value cannot
  be changed during transitions.
  The given 'name' has to be already declared state variable and not yet
  redeclared as frozen.]

  SideEffects        []

  SeeAlso            [SymbCache_new_frozen_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_remove\_var(SymbCache\_ptr self, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a variable from the cache of symbols, and from
  the flattener module]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_define(SymbCache\_ptr self, node\_ptr name, node\_ptr ctx, node\_ptr definition)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares a new DEFINE.]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_parameter(SymbCache\_ptr self, node\_ptr formal, node\_ptr ctx, node\_ptr actual)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares a new module parameter.]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_array\_define(SymbCache\_ptr self, node\_ptr name, node\_ptr ctx, node\_ptr definition)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares a new define array.]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.
  Internally we use ARRAY_DEF node to recognize a define array.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_variable\_array(SymbCache\_ptr self, node\_ptr name, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Declares a new ARRAY var.]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_remove\_define(SymbCache\_ptr self, node\_ptr define)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a DEFINE from the cache of symbols, and from
  the flattener define hash]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_remove\_function(SymbCache\_ptr self, node\_ptr fun)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes an NFunction from the cache of symbols]

  Description        [This (private) method can be used only by
                      SymbLayer, otherwise the resulting status
                      will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_remove\_parameter(SymbCache\_ptr self, node\_ptr formal)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a parameter from the cache of symbols]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_constant(SymbCache\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares a new constant.]

  Description [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted. Multiple-time
  declared constant are accepted, and a reference count is kept to deal with
  them]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_new\_function(SymbCache\_ptr self, node\_ptr name, node\_ptr ctx, NFunction\_ptr fun)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares a new NFunction.]

  Description        [This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NFunction\_ptr SymbCache\_get\_function(SymbCache\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the NFunction instance of the given
                      function name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_function\_context(SymbCache\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the context of the given NFunction]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_remove\_constant(SymbCache\_ptr self, node\_ptr constant)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Removes a constant from the cache of symbols, and from
  the flattener module]

  Description [Removal is performed taking into account of reference
  counting, as constants can be shared among several layers. This
  (private) method can be used only by SymbLayer, otherwise the
  resulting status will be corrupted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_remove\_symbols(SymbCache\_ptr self, const node\_ptr* symbols, const unsigned int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes all the symbols in the array]

  Description        [Removes all the symbols in the array in
                      linear time]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbCache\_get\_var\_type(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the type of a given variable]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_define\_body(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the body of the given DEFINE name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_actual\_parameter(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the actual param of the given formal parameter]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_array\_define\_body(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the body of the given define array name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbCache\_get\_variable\_array\_type(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the type of array variable, i.e. of variable_array]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_define\_flatten\_body(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the flattenized body of the given DEFINE name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_flatten\_actual\_parameter(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the flattenized actual parameter of the given
  formal parameter]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_define\_context(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the context of the given DEFINE name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_actual\_parameter\_context(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the context of the actual parameter associated
  with the given formal parameter ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_get\_array\_define\_context(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the context of the given define array name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_state\_var(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a state variable.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_frozen\_var(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the variable is frozen]

  Description        [A variable is frozen if it is known that the var cannot
  change its value during transitions.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_state\_frozen\_var(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the variable is a frozen or a state
  variable]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_input\_var(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is an input
  variable.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_var(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is either a state, a frozen or
  an input variable.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_declared(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is declared]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_constant(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is a declared
  constant]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_define(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
  DEFINE]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_function(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
                      NFunction]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_parameter(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is a declared formal
  parameter]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_array\_define(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
  define array]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_symbol\_variable\_array(const SymbCache\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
  array variable, i.e symbol type]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_list\_contains\_input\_var(const SymbCache\_ptr self, const NodeList\_ptr var\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if var_list contains at least one input
  variable]

  Description        [The given list of variables is traversed until an input
  variable is found]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_list\_contains\_state\_frozen\_var(const SymbCache\_ptr self, const NodeList\_ptr var\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if var_list contains at least one state
  or frozen variable]

  Description        [The given list of variables is traversed until
  a state or frozen variable is found]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_list\_contains\_undef\_var(const SymbCache\_ptr self, const NodeList\_ptr var\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbols list contains
  one or more undeclared variable names]

  Description        [Iterates through the elements in var_list
  checking each one to see if it is one undeclared variable.]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_next\_iter(const SymbCache\_ptr self, SymbTableIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Moves the iterator over the next symbol]

  Description        [Moves the iterator over the next symbol,
                      regarding to the mask given when built using
                      SymbCache_gen_iter]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_iter\_set\_filter(const SymbCache\_ptr self, SymbTableIter* iter, SymbTableIterFilterFun filter, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the filter for an interator over the
                      Symbol Cache symbols]

  Description        [Sets the filter for an interator over the
                      Symbol Cache symbols. The iterator will be moved
                      in order to point to a symbol that satisfies
                      both the mask and the filter]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_gen\_iter(const SymbCache\_ptr self, SymbTableIter* iter, const unsigned int mask)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates an interator over the Symbol Cache symbols]

  Description        [Generates an interator over the Symbol Cache symbols.
                      The iterator will ignore all symbols that do not
                      satisfy the mask]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbCache\_is\_iter\_end(const SymbCache\_ptr self, const SymbTableIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the iterator is at it's end]

  Description        [Checks if the iterator is at it's end]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbCache\_iter\_get\_symbol(const SymbCache\_ptr self, const SymbTableIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the symbol pointed by the iterator]

  Description        [Get the symbol pointed by the iterator]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTableType SymbCache\_get\_symbol\_type(const SymbCache\_ptr self, const node\_ptr symbol)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the symbol type]

  Description        [Get the symbol type. The symbol must be declared
                      in the cache]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_constants\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared contants]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_state\_vars\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared state variables.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_frozen\_vars\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared frozen variables.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_input\_vars\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared input variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_defines\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of DEFINEs.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_functions\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of NFunctions.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_parameters\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of parameters.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_array\_defines\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of define arrays.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbCache\_get\_variable\_arrays\_num(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of Symbol Types.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_add\_trigger(const SymbCache\_ptr self, SymbTableTriggerFun trigger, SymbTableTriggerAction action, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a trigger to the symbol cache]

  Description        [Adds a trigger to the symbol cache.
                      "arg" is the argument that will be passed to
                      function "trigger" when invoked.

                      The "action" parameter determines when "trigger"
                      is triggered. The possibilities are:

                      ST_TRIGGER_SYMBOL_ADD: Triggered when a symbol
                        is added. When the trigger is called, all
                        informations about the symbol are already
                        available (e.g. SymbType).

                      ST_TRIGGER_SYMBOL_REMOVE: Triggered when a
                        symbol is removed. All informations about the
                        symbol are still available when the trigger is
                        invoked.

                      ST_TRIGGER_SYMBOL_REDECLARE: Triggered when a
                        symbol that had been removed and later
                        redeclared with the same name. All
                        informations about the new symbol are
                        available, while informations about the old
                        symbol are not]

  SideEffects        []

  SeeAlso            [SymbCache_remove_trigger]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbCache\_remove\_trigger(const SymbCache\_ptr self, SymbTableTriggerFun trigger, SymbTableTriggerAction action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a trigger from the symbol cache]

  Description        [Removes a trigger from the symbol cache]

  SideEffects        []

  SeeAlso            [SymbCache_add_trigger]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_cache\_init(SymbCache\_ptr self, SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private initializer]

  Description        [Private initializer, called by the constructor]

  SideEffects        []

  SeeAlso            [symb_cache_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval sym\_hash\_free\_vars(char *key, char *data, char *arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private destructor used by class destroyer]

  Description        []

  SideEffects        []

  SeeAlso            [symb_table_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_cache\_deinit(SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private deinitializer]

  Description        [Private deinitializer, called by the destructor]

  SideEffects        []

  SeeAlso            [symb_cache_init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_cache\_free\_triggers(NodeList\_ptr triggers)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Aux function for symb_cache_deinit]

  Description        [Clears the given list of triggers]

  SideEffects        []

  SeeAlso            [symb_cache_init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline SymbolInfo* symb\_cache\_alloc\_symb\_info(const SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an instance of a SymbolInfo]

  Description        [The instance is popped from the pool, if available.
                      Otherwise, a new chunk of memory is allocated
                      and the pool is repopulated with
                      SYMBOL_INFO_CHUNK_SIZE instances of SymbolInfo]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void symb\_cache\_free\_symb\_info(const SymbCache\_ptr self, SymbolInfo* si)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees the given SymbolInfo instance]

  Description        [Pushes the given symbol info instance in the
                      SymbolInfo's instances pool, for future re-use]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void symb\_cache\_new\_symbol(SymbCache\_ptr self, const node\_ptr sym, SymbolInfo* symbol\_info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [A new symbols is added in the cache]

  Description        [The given symbol is added in the cache.

                      The given symbol is added in the symbol_hash
                      associated to the relative SymbolInfo, and in
                      the symbols array (which may need a resizing).]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void symb\_cache\_check\_and\_shrink\_symbols(SymbCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Shrinks the symbols array if needed]

  Description        [Shrinks the symbols array if needed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void symb\_cache\_remove\_symbol(SymbCache\_ptr self, const node\_ptr sym, const boolean shrink\_if\_needed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a symbol from the cache]

  Description        [Removes a symbol from the cache.

                      The given symbol is removed from the symbol_hash
                      and from the symbols array. The associated
                      SymbolInfo is freed (i.e. is pushed in the
                      pool). This operation costs O(1), but if
                      shrink_if_needed is true and the symbols array
                      has too many holes, it is shrinked (O(n + h)
                      with n = number of symbols and h = number of
                      holes)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SymbLayer.c}
		
	\texttt{SymbLayer\_ptr SymbLayer\_create(const char* name, const LayerInsertPolicy policy, SymbCache\_ptr cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class SymbLayer constructor]

  Description        [name is copied, the caller keeps ownership of cache.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_destroy(SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class SymbLayer destructor]

  Description        [Use this destructor if the SymbCache will not be
                      destroyed after this call (ie. You are removing
                      a layer from the Symbol Table)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_destroy\_raw(SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class SymbLayer destructor]

  Description        [Use this destructor if the SymbCache will be
                      destroyed after this call (ie. You are
                      destroying the Symbol Table)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_set\_name(SymbLayer\_ptr self, const char* new\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the layer name.]

  Description        [This method is protected (not usable by users, only
  used by the symbol table when renaming a layer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* SymbLayer\_get\_name(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the name self had been registered with.]

  Description        [Returned string must not be freed, it belongs to self]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{LayerInsertPolicy SymbLayer\_get\_insert\_policy(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the policy that must be adopted to stack this
  layer into a layers stack, within a SymbTable instance]

  Description        [This method is thought to be used exclusively by class
  SymbTable]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_must\_insert\_before(const SymbLayer\_ptr self, const SymbLayer\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Compares the insertion policies of self and other, and
 returns true if self must be inserted *before* other]

  Description        [Compares the insertion policies of self and other, and
  returns true if self must be inserted *before* other.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_committed\_to\_enc(SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Called every time an instance is committed within an
  encoding.]

  Description        [This method is part of a private registration protocol
  between encodings and layers, and must be considered as a private
  method.  Every time a layer is registered (committed) within an
  enconding, the layer is notified with a call to this method from the
  encoding instance which the layer is committed to. This mechanism
  helps to detect errors when a layer in use by an encoding is removed
  and destroyed from within a symbol table. The destructor will always
  check that self is not in use by any encoding when it is invoked.]

  SideEffects        []

  SeeAlso            [removed_from_enc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_removed\_from\_enc(SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Called every time an instance is removed from an
  encoding.]

  Description       [This method is part of a private registration protocol
  between encodings and layers, and must be considered as a private
  method.  Every time a layer is removed (uncommitted) from an
  enconding, the layer is notified with a call to this method from the
  encoding instance which the layer is being removed from. This mechanism
  helps to detect errors when a layer in use by an encoding is removed
  and destroyed from within a symbol table. The destructor will always
  check that self is not in use by any encoding when it is invoked.]

  SideEffects        []

  SeeAlso            [commit_to_enc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_can\_declare\_function(const SymbLayer\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to know if a new NFunction can be
  declared within this layer.]

  Description        [Returns true if the given symbol does not exist
  within the symbol table which self belongs to. Returns
  false if the symbol was already declared. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_can\_declare\_constant(const SymbLayer\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to know if a new constant can be
  declared within this layer.]

  Description        [Since more than one layer can declare the same constants,
  this method might return true even if another layer already contain the
  given constant. If the constant had already been declared within self,
  false is returned. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_can\_declare\_var(const SymbLayer\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to know if a new variable can be
  declared within this layer.]

  Description        [Returns true if the given symbol does not exist
  within the symbol table which self belongs to. Returns
  false if the symbol was already declared. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_can\_declare\_define(const SymbLayer\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to know if a new DEFINE can be
  declared within this layer.]

  Description        [Returns true if the given symbol does not exist within
  the symbol table which self belongs to. Returns false if the symbol
  was already declared. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_can\_declare\_parameter(const SymbLayer\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to know if a new parameter can be
                      declared within this layer.]

  Description        [Returns true if the given symbol does not exist within
  the symbol table which self belongs to. Returns false if the symbol
  was already declared. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_can\_declare\_array\_define(const SymbLayer\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to know if a new define array can be
  declared within this layer.]

  Description        [Returns true if the given symbol does not exist within
  the symbol table which self belongs to. Returns false if the symbol
  was already declared. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_can\_declare\_variable\_array(const SymbLayer\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to know if a new variable_array can be
  declared within this layer.]

  Description        [Returns true if the given symbol does not exist within
  the symbol table which self belongs to. Returns false if the symbol
  was already declared. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_function(SymbLayer\_ptr self, node\_ptr name, node\_ptr ctx, NFunction\_ptr fun)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a new NFunction]

  Description        [A new NFunction is declared within the layer.
                      Name must be contestualized, context is provided
                      as a separated information]

  SideEffects        []

  SeeAlso            [SymbLayer_can_declare_function]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_constant(SymbLayer\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a new constant]

  Description        [A new constant is created]

  SideEffects        []

  SeeAlso            [SymbLayer_can_declare_constant]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_input\_var(SymbLayer\_ptr self, node\_ptr var\_name, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a new input variable]

  Description        [A new input variable is created of a given type.
  The variable type can be created with SymbType_create or returned by
  funtions SymbTablePkg_..._type.
  The layer is responsible for destroying the variable's type.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_state\_var(SymbLayer\_ptr self, node\_ptr var\_name, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a new state variable]

  Description        [A new state variable is created of a given type.
  The variable type can be created with SymbType_create or returned by
  funtions SymbTablePkg_..._type.
  The layer is responsible for destroying the variable's type.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_frozen\_var(SymbLayer\_ptr self, node\_ptr var\_name, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a new frozen variable]

  Description        [A new frozen variable is created of a given type.
  The variable type can be created with SymbType_create or returned by
  funtions SymbTablePkg_..._type.
  The layer is responsible for destroying the variable's type.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{EXTERN void SymbLayer\_redeclare\_state\_as\_frozen\_var(SymbLayer\_ptr self, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Redeclare a state variable as a frozen variable]

  Description        [A variable is frozen if it is known then the var's value
  cannot change in transitions.
  'var' must be a state variable already defined and not redeclared as frozen.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_define(SymbLayer\_ptr self, node\_ptr name, node\_ptr context, node\_ptr definition)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a new DEFINE]

  Description        [A new DEFINE of a given value is created. name must be
  contestualized, context is provided as a separated information]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_parameter(SymbLayer\_ptr self, node\_ptr formal, node\_ptr context, node\_ptr actual)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a new formal parameters]

  Description        [A new parameter of a given value is created. name must be
  contestualized, context is provided as a separated information]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_array\_define(SymbLayer\_ptr self, node\_ptr name, node\_ptr context, node\_ptr definition)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a new array define array]

  Description        [A new define array of a given value is created. name must be
  contestualized, context is provided as a separated information]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_declare\_variable\_array(SymbLayer\_ptr self, node\_ptr name, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Insert a new symbol-type association, i.e. array var ]

  Description [The specified name will be associated to the give array type
  in the symbols collection]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_remove\_var(SymbLayer\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a variable previously delcared]

  Description [This method can be called only if self is not
  currently commited to any encoding. It is not allowed to remove
  symbols from layers that are committed to any encoder. This is
  required as caches and other mechanisms may fail to work
  correctly otherwise.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_remove\_define(SymbLayer\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a previously declared DEFINE]

  Description [This method can be called only if self is not
  currently commited to any encoding. It is not allowed to remove
  symbols from layers that are committed to any encoder. This is
  required as caches and other mechanisms may fail to work
  correctly otherwise.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_remove\_function(SymbLayer\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a previously declared NFunction]

  Description [This method can be called only if self is not
  currently commited to any encoding. It is not allowed to remove
  symbols from layers that are committed to any encoder. This is
  required as caches and other mechanisms may fail to work
  correctly otherwise.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_symbols\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared symbols]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_vars\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_constants\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared contants]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_state\_vars\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared state variables.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_bool\_state\_vars\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared boolean state variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_frozen\_vars\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared frozen variables.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_bool\_frozen\_vars\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared boolean frozen variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_input\_vars\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared input variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_bool\_input\_vars\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of declared boolean input variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_defines\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of DEFINEs.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_functions\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of NFunctions.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_parameters\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of parameters.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_array\_defines\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of define arrays.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbLayer\_get\_variable\_arrays\_num(const SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of Symbol Types.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_is\_variable\_in\_layer(SymbLayer\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the variable is defined in the layer.]

  Description        [Returns true if the variable is defined in the layer.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_is\_symbol\_in\_layer(SymbLayer\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the symbol is defined in the layer.]

  Description        [Returns true if the symbol is defined in the layer.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_iter\_next(const SymbLayer\_ptr self, SymbLayerIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Moves the iterator over the next symbol]

  Description        [Moves the iterator over the next symbol,
                      regarding to the mask given when built using
                      SymbCache_gen_iter]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_gen\_iter(const SymbLayer\_ptr self, SymbLayerIter* iter, const unsigned int mask)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates an interator over the Symbol Cache symbols]

  Description        [Generates an interator over the Symbol Cache symbols.
                      The iterator will ignore all symbols that do not
                      satisfy the mask]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbLayer\_iter\_set\_filter(const SymbLayer\_ptr self, SymbLayerIter* iter, SymbLayerIterFilterFun filter, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the filter for an interator over the
                      Symbol Layer symbols]

  Description        [Sets the filter for an interator over the
                      Symbol Layer symbols. The iterator will be moved
                      in order to point to a symbol that satisfies
                      both the mask and the filter]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_iter\_is\_end(const SymbLayer\_ptr self, const SymbLayerIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the iterator is at it's end]

  Description        [Checks if the iterator is at it's end]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbLayer\_iter\_get\_symbol(const SymbLayer\_ptr self, const SymbLayerIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the symbol pointed by the iterator]

  Description        [Get the symbol pointed by the iterator]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t SymbLayer\_iter\_to\_set(const SymbLayer\_ptr self, SymbLayerIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates a set starting from the given iterator.]

  Description        [Generates a set starting from the given iterator.
                      The iter will not be consumed (since passed as
                      copy)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbLayer\_iter\_to\_list(const SymbLayer\_ptr self, SymbLayerIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Generates a list starting from the given iterator.]

  Description        [Generates a list starting from the given iterator.
                      The iter will not be consumed (since passed as
                      copy)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned int SymbLayer\_iter\_count(const SymbLayer\_ptr self, SymbLayerIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Counts the elements of the iterator.]

  Description        [Counts the elements of the iterator.
                      The iter will not be consumed (since passed as
                      copy)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbLayer\_iter\_filter\_bool\_vars(const SymbLayer\_ptr self, const node\_ptr sym, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Boolean Variables filter]

  Description        [SymbLayer built-in filter: Returns true iff the symbol
                      is a boolean variable]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_layer\_init(SymbLayer\_ptr self, const char* name, const LayerInsertPolicy policy, SymbCache\_ptr cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private method called by the constructor]

  Description        [Called by the constructor]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_layer\_deinit(SymbLayer\_ptr self, boolean clean\_cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private method called by the destructor]

  Description        [Called by the destructor]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void symb\_layer\_new\_symbol(SymbLayer\_ptr self, const node\_ptr sym)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds the given symbol from the layer]

  Description        [Adds the given symbol from the layer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void symb\_layer\_remove\_symbol(SymbLayer\_ptr self, const node\_ptr sym)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the given symbol from the layer]

  Description        [Removes the given symbol from the layer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void symb\_layer\_check\_and\_shrink\_symbols(SymbLayer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Shrinks the symbols array if needed]

  Description        [Shrinks the symbols array if needed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SymbTable.c}
		
	\texttt{SymbTable\_ptr SymbTable\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class constructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_destroy(SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class destructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TypeChecker\_ptr SymbTable\_get\_type\_checker(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the internally stored type checker]

  Description        [Returned instance belongs to self]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbLayer\_ptr SymbTable\_create\_layer(SymbTable\_ptr self, const char* layer\_name, const LayerInsertPolicy ins\_policy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates and adds a new layer]

  Description [The created layer is returned. Do not destroy the
  layer, since it belongs to self. if layer name is NULL, then a
  temporary name will be searched and a new layer will be created. To
  retrieve the layer name, query the returned SymbLayer instance. ]

  SideEffects        []

  SeeAlso            [remove_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_remove\_layer(SymbTable\_ptr self, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes and destroys a layer]

  Description [The layer must be not in use by any encoding, so remove
  it from all encodings before calling this method. The removed layer
  will be no longer available after the invocation of this method.

  If given layer belongs to a set of layer classes, the layer will
  be removed from the classes as well (meaning that there is no
  need to remove the layer from the classes it belongs to) ]

  SideEffects        []

  SeeAlso            [create_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbLayer\_ptr SymbTable\_get\_layer(const SymbTable\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Given its name, returns a layer]

  Description [NULL is returned when the layer does not exist within
  self.  Returned SymbLayer instance belongs to self.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_rename\_layer(const SymbTable\_ptr self, const char* layer\_name, const char* new\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Renames an existing layer]

  Description [Use to rename an existing layer. Useful for example to
  substitute an existing layer with another.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbTable\_get\_layers(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of owned layers.]

  Description        [The returned list belongs to self. Do not free or
                      change it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_set\_default\_layers\_class\_name(SymbTable\_ptr self, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the default layers class name that has been
  previously set. The default layers class name is the class of
  layers that is taken when the system needs a default set of
  layers to work with. Typically the default class is the class of
  model layers, that is used for example when dumping the
  hierarchy by command write_bool_model.]

  Description        [Given string is duplicated.]

  SideEffects        []

  SeeAlso            [SymbTable_get_default_layers_class_name]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* SymbTable\_get\_default\_layers\_class\_name(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the default layers class name that has been
  previously set. The default layers class name is the class of
  layers that is taken when the system needs a default set of
  layers to work with. Typically the default class is the class of
  model layers, that is used for example when dumping the
  hierarchy by command write_bool_model.]

  Description        [Returned string belongs to self, and must be NOT
  destroyed or changed. Returned string is NULL if not previously set.]

  SideEffects        []

  SeeAlso            [SymbTable_set_default_layers_class_name]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_create\_layer\_class(SymbTable\_ptr self, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Declares a new class of layers]

  Description [This method creates a new class of layers. The
  class must be not existing. The method can be used to create a
  class of layers that might be empty. It is not required to
  create a class before calling methods that use that class, like
  e.g.  SymbTable_layer_add_to_class that wll create the class
  when not existing. class_name can be NULL to create the default
  class (whose name must have been previously specified with
  SymbTable_set_default_layers_class_name)]

  SideEffects        []

  SeeAlso            [SymbTable_layer_add_to_class]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_layer\_class\_exists(SymbTable\_ptr self, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Checks if a class of layers exists]

  Description [This method checks if class 'class_name' has been
  previously created in the SymbTable.Returns true if the class exists,
  false otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_layer\_add\_to\_class(SymbTable\_ptr self, const char* layer\_name, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Adds a given layer (that must exist into self already)
  to a class of layers. Classes are used to group layers into
  possibly overlapping sets. For example the class of layers
  containing the set of symbols that belongs to the SMV model.  If
  class_name is NULL, the default class name will be taken (must
  be set before)]

  Description [A new class will be created if given class does not
  exist yet. The given layer must be existing.]

  SideEffects        []

  SeeAlso            [SymbTable_layer_remove_from_class]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_layer\_remove\_from\_class(SymbTable\_ptr self, const char* layer\_name, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a given layer (that must exist into self already)
  from a given class of layers. If class_name is NULL, the default class
  is taken (must be set before)]

  Description [Given class must be existing, or if NULL default
  class must be existing. If the layer is not found, nothing happens.]

  SideEffects        []

  SeeAlso            [SymbTable_layer_add_to_class]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t* SymbTable\_get\_class\_layer\_names(SymbTable\_ptr self, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns an array of layer names that belong to the
  given class name. If class_name is NULL, default class name will
  be taken (must be set before).]

  Description [Specified class must be existing, or if NULL is
  specified a default class must have been defined. Returned
  array belongs to self and has NOT to be destroyed or changed by
  the caller.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_layer\_in\_class(SymbTable\_ptr self, const char* layer\_name, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if given layer name belongs to the given class]

  Description [If class_name is NULL, the default class will be checked]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* SymbTable\_get\_class\_of\_layer(const SymbTable\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the name of the class in which the given layer is
               declared or NULL if there is no such a class.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_vars\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all declared variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_state\_vars\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all declared state variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_frozen\_vars\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all declared frozen variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_input\_vars\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all declared input variables]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_constants\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all declared constants]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_defines\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all declared defines]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_array\_defines\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all declared array define]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_parameters\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all parameters]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbTable\_get\_functions\_num(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of all NFunctions]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbTable\_get\_layers\_sf\_vars(SymbTable\_ptr self, const array\_t* layer\_names)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of state and frozen variables
  that belong to the given layers]

  Description        [Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings.
  WARNING: The returned instance must be destroyed by the caller]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbTable\_get\_layers\_sf\_symbols(SymbTable\_ptr self, const array\_t* layer\_names)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of state and frozen symbols
  that belong to the given layers]

  Description        [Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings.
  WARNING: The returned instance must be destroyed by the caller.
  Note: state symbols include frozen variables.]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbTable\_get\_layers\_i\_symbols(SymbTable\_ptr self, const array\_t* layer\_names)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of input symbols that belong to the
  given layers]

  Description        [Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings.
  WARNING: The returned instance must be destroyed by the caller]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbTable\_get\_layers\_i\_vars(SymbTable\_ptr self, const array\_t* layer\_names)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of input variables that belong to the
  given layers]

  Description        [Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings.
  WARNING: The returned instance must be destroyed by the caller]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbTable\_get\_layers\_sf\_i\_symbols(SymbTable\_ptr self, const array\_t* layer\_names)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the list of state and input symbols that
  belong to the given layers, meaning those DEFINES whose body
  contain both state (or frozen) and input variables. This methods
  does _NOT_ return the state symbols plus the input symbols.]

  Description        [Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings.
  WARNING: The returned instance must be destroyed by the caller]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbTable\_get\_layers\_sf\_i\_vars(SymbTable\_ptr self, const array\_t* layer\_names)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the list of variables that belong to the given layers]

  Description        [Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings.
  WARNING: The returned instance must be destroyed by the caller]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTable\_get\_var\_type(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the type of a given variable]

  Description        [The type belongs to the layer, do not destroy it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_define\_body(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the body of the given DEFINE]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_actual\_parameter(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the actual param of the given formal parameter ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_array\_define\_body(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the body of the given array define name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTable\_get\_variable\_array\_type(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the body of the given array define name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NFunction\_ptr SymbTable\_get\_function(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the NFunction with the given name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_function\_context(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the context of the NFunction with the given name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_array\_define\_flatten\_body(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the flattened body of the given array define name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_define\_flatten\_body(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the flattenized body of the given
  define]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_flatten\_actual\_parameter(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the flattenized actual parameter of the given
  formal parameter]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_define\_context(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the context of the given DEFINE name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_actual\_parameter\_context(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the context of the actual parameter associated
  with the given formal one]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_array\_define\_context(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the context of the given array define name]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbCategory SymbTable\_get\_symbol\_category(const SymbTable\_ptr self, node\_ptr symbol)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function returns the category of
  an identifier]

  Description [Possible categories are: state vars, input vars, state
  only defines, input only defines, state-input defines,
  state-input-next defines. If a symbol is not properly recognized as
  one of the above, SYMBOL_INVALID is returned (for constants, for examples).

  An identifier is var or define. It is also allowed to have arrays
  with constant index, i.e. if V is identifier than V[5] is also
  identifier.]

  SideEffects [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_state\_var(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is a state variable.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_frozen\_var(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is a frozen variable.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_state\_frozen\_var(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is a frozen or a state variable.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_input\_var(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is an input variable.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_var(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is either a state, frozen or
  an input variable.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_bool\_var(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is a variable of enum type
  with the values 0 and 1 (boolean)]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_declared(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is declared]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_define(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
  DEFINE]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_function(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
                      NFunction]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_parameter(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
  parameter]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_array\_define(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
  array define]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_variable\_array(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is a declared
  variable array]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_symbol\_constant(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given symbol is a declared
  constant]

  Description [Notice that this method will check only symbols defined
  within self. For example if an integer constant was not declared
  within self, this method will return false for it. For generic
  expressions, consider using function node_is_leaf which performs a
  purely-syntactly check.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_is\_var\_finite(const SymbTable\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the given variable has a finite domain]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_list\_contains\_input\_var(const SymbTable\_ptr self, const NodeList\_ptr var\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if var_list contains at least one input
  variable, false otherwise]

  Description        [The given list of variables is traversed until an input
  variable is found]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_list\_contains\_state\_frozen\_var(const SymbTable\_ptr self, const NodeList\_ptr var\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if var_list contains at least one state
  or frozen variable, false otherwise]

  Description        [The given list of variables is traversed until
  a state or frozen variable is found]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_list\_contains\_undef\_var(const SymbTable\_ptr self, const NodeList\_ptr var\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbols list contains
  one or more undeclared variable names, false otherwise]

  Description        [Iterates through the elements in var_list
  checking each one to see if it is one undeclared variable.]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbLayer\_ptr SymbTable\_variable\_get\_layer(SymbTable\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the layer a variable is defined in.]

  Description        [Returns the layer a variable is defined in, NULL
  if there is no layer containing it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbLayer\_ptr SymbTable\_symbol\_get\_layer(SymbTable\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the layer a symbol is defined in.]

  Description        [Returns the layer a symbol is defined in, NULL
                      if there is no layer containing it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbLayer\_ptr SymbTable\_define\_get\_layer(SymbTable\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the layer a DEFINE is defined in.]

  Description        [Returns the layer a DEFINE is defined in, NULL
  if there is no layer containing it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbLayer\_ptr SymbTable\_function\_get\_layer(SymbTable\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the layer a NFunction is defined in.]

  Description        [Returns the layer a NFunction is defined in, NULL
                      if there is no layer containing it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_determinization\_var\_name(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a valid name for a new determinization variable]

  Description        [Returns a valid name for a new determinization
                      variable.  Searches in the symbol table for a
                      variable name which is not declared yet, and
                      returns it. Warning: This method does not
                      declare a new variable, it simply finds a
                      valid name for a new determinization
                      variable. If the returned variable name is
                      not used later to declare a new variable,
                      succeed calls to this method may not return a
                      valid name.]

  SideEffects        []

  SeeAlso            [symb_table_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_get\_fresh\_symbol\_name(SymbTable\_ptr self, const char* tplate)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a tplate, returns a fresh symbol name.  This
                      function NEVER returns the same symbol twice and
                      NEVER returns a declared name]

  Description        [If tplate is NULL then a valid fresh symbol is choosed.
  NB: here tplate actually means prefix.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr SymbTable\_get\_simplification\_hash(SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a hash which can be used only in
  Expr_simplify.]

  Description        [See function Expr_simplify for more details. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr SymbTable\_copy(const SymbTable\_ptr self, Set\_t blacklist)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create a new SymbolTable which contains the same info
                      as the given one except the specified symbols in blacklist]

  Description        [Returned ST is allocated and has to be released by caller.
                      The copy is performed iterating over each layer in the
                      Symbol Table. The new ST contains a copy of each layer of
                      the given Symbol Table]

  SideEffects        []

  SeeAlso            [SymbTable_create SymbTable_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ResolveSymbol\_ptr SymbTable\_resolve\_symbol(SymbTable\_ptr self, node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Resolves the given symbol in the given context]

  Description        [Resolves the given symbol in the given context.
                      This function returns the internal instance of
                      ResolveSymbol, which must NOT be freed by the
                      caller. The ResolveSymbol internal instance is
                      re-populated everytime that this function is
                      called.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_gen\_iter(const SymbTable\_ptr self, SymbTableIter* iter, unsigned int mask)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the given iterator with the given mask.]

  Description        [Initializes the given iterator with the given mask.
                      It is fundamental to call this procedure before
                      using the iterator.

                      SYMB_TABLE_FOREACH and SYMB_TABLE_FOREACH_FILTER
                      automaticcaly call this function, so the caller
                      does not have to worry about that.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_iter\_next(const SymbTable\_ptr self, SymbTableIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Moves the iterator to the next valid symbol]

  Description        [Moves the iterator to the next valid symbol]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_iter\_is\_end(const SymbTable\_ptr self, const SymbTableIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the iterator is at it's end]

  Description        [Checks if the iterator is at it's end]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbTable\_iter\_get\_symbol(const SymbTable\_ptr self, const SymbTableIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the symbol pointed by the given iterator]

  Description        [Gets the symbol pointed by the given iterator.
                      The given iterator must not be at it's end]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_iter\_set\_filter(const SymbTable\_ptr self, SymbTableIter* iter, SymbTableIterFilterFun fun, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the filter to be used by the iterator]

  Description        [Sets the filter to be used by the iterator.
                      The iterator internally moves itself to the next
                      valid symbol that satisfies both the filter and
                      the mask]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_iter\_filter\_sf\_i\_symbols(const SymbTable\_ptr self, const node\_ptr sym, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Default iterator filter: State, Frozen and Input symbols]

  Description        [Default iterator filter: State, Frozen and Input symbols.
                      Only defines that predicate over state or frozen
                      AND input variables or variables themselfs
                      satisfy this filter.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_iter\_filter\_sf\_symbols(const SymbTable\_ptr self, const node\_ptr sym, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Default iterator filter: State, Frozen symbols]

  Description        [Default iterator filter: State, Frozen symbols.
                      Only defines that predicate over state or frozen
                      variables or state / frozen variables themselfs
                      satisfy this filter.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_iter\_filter\_i\_symbols(const SymbTable\_ptr self, const node\_ptr sym, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Default iterator filter: Input symbols]

  Description        [Default iterator filter: Input symbols.
                      Only defines that predicate over input variables
                      or input variables themselfs satisfy this
                      filter.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_foreach(const SymbTable\_ptr self, unsigned int mask, SymbTableForeachFun fun, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Executes the given function over each symbol
                      that satisfies the given symbol mask]

  Description        [Executes the given function over each symbol
                      that satisfies the given symbol mask]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t SymbTable\_iter\_to\_set(const SymbTable\_ptr self, SymbTableIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a set starting from the iterator]

  Description        [Creates a set starting from the iterator. The set
                      must be freed. The iterator is NOT changed (it
                      is passed as value..)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SymbTable\_iter\_to\_list(const SymbTable\_ptr self, SymbTableIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a set starting from the iterator]

  Description        [Creates a list starting from the iterator. The list
                      must be freed. The iterator is NOT changed (it
                      is passed as value..)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned int SymbTable\_iter\_count(const SymbTable\_ptr self, SymbTableIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Counts the elements of the iterator]

  Description        [Counts the elements of the iterator. The iterator
                      is NOT changed (it is passed as value..)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_add\_trigger(const SymbTable\_ptr self, SymbTableTriggerFun trigger, SymbTableTriggerAction action, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a trigger to the symbol table]

  Description        [Adds a trigger to the symbol table.
                      "arg" is the argument that will be passed to
                      function "trigger" when invoked.

                      The "action" parameter determines when "trigger"
                      is triggered. The possibilities are:

                      ST_TRIGGER_SYMBOL_ADD: Triggered when a symbol
                        is added. When the trigger is called, all
                        informations about the symbol are already
                        available (e.g. SymbType).

                      ST_TRIGGER_SYMBOL_REMOVE: Triggered when a
                        symbol is removed. This may happen when
                        removing a layer from the symbol table, or
                        when removing a variable from a layer. All
                        informations about the symbol are still
                        available when the trigger is invoked

                      ST_TRIGGER_SYMBOL_REDECLARE: Triggered when a
                        symbol that had been removed from the symbol
                        table, or a from a layer, is redeclared with
                        the same name. All informations about the new
                        symbol are available, while informations about
                        the old symbol are not]

  SideEffects        []

  SeeAlso            [SymbTable_remove_trigger]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTable\_remove\_trigger(const SymbTable\_ptr self, SymbTableTriggerFun trigger, SymbTableTriggerAction action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes a trigger from the Symbol Table]

  Description        [Removes a trigger from the Symbol Table]

  SideEffects        []

  SeeAlso            [SymbTable_add_trigger]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbTable\_contains\_infinite\_precision\_variables(const SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks whether the Symbol Table contains infinite
                      precision variables]

  Description        [Checks whether the Symbol Table contains infinite
                      precision variables]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_table\_init(SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private initializer]

  Description        [Private initializer, called by the constructor only]

  SideEffects        []

  SeeAlso            [symb_table_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval class\_layers\_hash\_free(char *key, char *data, char * arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private destructor used by clas destroyer]

  Description        []

  SideEffects        []

  SeeAlso            [symb_table_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_table\_deinit(SymbTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private deinitializer]

  Description        [Private deinitializer, called by the destructor only]

  SideEffects        []

  SeeAlso            [symb_table_init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean symb\_table\_layer\_exists(const SymbTable\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given name corresponds to an already
  registered layer.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static NodeList\_ptr symb\_table\_filter\_layers\_symbols(SymbTable\_ptr self, const array\_t* layer\_names, SymbTableIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given a list of symbols and a list of layers names,
  returns a new list that contains only those symbols that have been
  declared within the given layers]

  Description [The caller is responsible for destroying the
  returned list]

  SideEffects        []

  See Also           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_table\_layer\_rename\_in\_class(SymbTable\_ptr self, const char* class\_name, const char* old\_layer\_name, const char* new\_layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Removes or rename a given layer inside the given
  layers class. If class_name is NULL, then default class is taken
  (must be set before)]

  Description        [Used internally by remove_layer and rename_layer.
  To remove, pass NULL as new_layer_name]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static array\_t* symb\_table\_get\_layers\_from\_class(const SymbTable\_ptr self, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Internal service used by methods that handle layer classes]

  Description        [Returns the array of layer class, or NULL when not existing.
  Resolves NULL class_name to the default class]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static array\_t* symb\_table\_create\_layers\_class(const SymbTable\_ptr self, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Internal service used by methods that handle layer classes]

  Description        [Returns the array of layer class, creating it when
  needed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static array\_t* symb\_table\_get\_layers\_class(const SymbTable\_ptr self, const char* class\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Internal service used by methods that handle layer classes]

  Description        [Returns the array of layer class, NULL if class does
  not exist.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr symb\_table\_flatten\_array\_define(const SymbTable\_ptr self, const node\_ptr body, const node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal service used by
                      SymbTable_get_array_define_flatten_body]

  Description        [Returns the flattened body of an array define]

  SideEffects        []

  SeeAlso            [SymbTable_get_array_define_flatten_body]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SymbCategory symb\_table\_detect\_expr\_category(const SymbTable\_ptr st, const Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the type of a define.]

  Description [Returns the type of a define, for a discussion on
               symbol categories look the SymbCategory enum
               description in SymbTable.h]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SymbType.c}
		
	\texttt{SymbType\_ptr SymbType\_create(SymbTypeTag tag, node\_ptr body)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Class SymbType constructor]

   Description [The tag must be a correct tag. The 'body' is the
   additional info corresponding to a particular kind of the type:
   * for a enum type the body is the list of values;
   * for "BOOL", "INT" or "REAL" the body is unused, and set to Nil;
   * for signed and unsigned "WORD" it is the NUMBER node defining the
      width of the type;
   * for "WORDARRAY", the body is a pair of NUMBER nodes, defining
      the width of the address, and the width of the value.
   * for everything else body is Nil;

   Note that array types have to be created with
   SymbType_create_array, not with this constructor.

   Set-types are used with expressions which represent a set values.
   "NO-TYPE" is used with expressions which normally do not
        have any type such as assignments.
   "ERROR" type indicates an error (not an actual type).

   No-type, error-type and all set-types (boolean-set, integer-set,
   symbolic-set, symbolic-integer-set) should not be created with this
   constructor, but only with memory-shared function
   SymbTablePkg_..._type.  The reason behind this constrain is that
   only expressions (not variables) can have these types, therefore
   only memory-shared versions of these types are required.

   The constructor does not create a copy of the body, but just remember
   the pointer.

   NB: system "reset" command destroys all node_ptr objects, including those
   used in SymbType_ptr. So destroy all symbolic types before the destruction
   of node_ptr objects, i.e. before or during "reset"]

   SideEffects        [allocate memory]

   SeeAlso            [SymbType_create_array, SymbType_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_create\_array(SymbType\_ptr subtype, int lower\_bound, int upper\_bound)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Class SymbType constructor for array types only]

   Description [This is specialized version of SymbType_create
   which is designed for array types only.
   It is implemented as a special construtor because array types are quite
   different from all the others.

   Parameter subtype is the subtype of the array type. This type has
   to be not-memory-shared and its ownership is passed to created
   type. I.e. subtype will be destroyed when returned type is destroyed.

   lower_bound, upper-bound are the lower and upper bounds,resp, of
   the array.

   All the constrains about memory, lifetype, etc are the same as for
   SymbType_create.
   ]

   SideEffects        [allocate memory]

   SeeAlso            [SymbType_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbType\_destroy(SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Class SymbType destructor]

   Description        [Deallocate the memory. The destructor
   does not deallocate memory from the type's body (since the
   constructor did not created the body).

   NOTE: If self is a memory sharing type instance, i.e. a type returned by
   SymbTablePkg_..._type functions then the destructor will not delete
   the type.]

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_copy(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Class SymbType copy-constructor]

   Description [This function takes one type and returns its copy.

   Note: the body of the type is not copied, i.e. just pointer is remembered.
   See SymbType_create for more info about body.

   Note: the input type should not be a memory-shared type (since there is no
   meaning in coping a memory sharing type).
   ]

   SideEffects        [allocate memory]

   SeeAlso            [SymbType_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_create\_memory\_sharing\_type(SymbTypeTag tag, node\_ptr body)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private class SymbType constructor
   for memory sharing type instances]

   Description        [The difference from the public constructor is that this
   constructor marks the created type as a memory sharing type. As
   result the public constructor will not be able to destroy memory
   sharing instance of a type. Use the private constructor
   SymbType_destroy_memory_sharing_type to destroy such instances.
   ]

   SideEffects        [allocate memory]

   SeeAlso            [SymbType_create, SymbType_destroy_memory_sharing_type]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_create\_memory\_sharing\_array\_type(SymbType\_ptr subtype, int lower\_bound, int upper\_bound)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private class SymbType constructor
   for memory sharing array type instances]

   Description        [The same as SymbType_create_memory_sharing_type
   but can be used to create array types.
   subtype has to be memory shared.]

   SideEffects        [allocate memory]

   SeeAlso            [SymbType_create, SymbType_destroy_memory_sharing_type]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbType\_destroy\_memory\_sharing\_type(SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private Class SymbType destructor
   for memory sharing instances of types.]

   Description        [The same as the public destructor SymbType_destroy
   but 'self' has to be created by private constructor
   SymbType_create_memory_sharing_type only.]

   SideEffects        []

   SeeAlso            [SymbType_create_memory_sharing_type, SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTypeTag SymbType\_get\_tag(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the tag (the kind) of the type]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_enum(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns true if the type is a enum-type, or else returns false]

   Description []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_boolean(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns true, if the type is boolean. Otherwise - returns false.]

   Description [The kind of enum-type is analysed in the constructor.]

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_integer(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns true if the type is a integer-type, or else returns false]

   Description []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_real(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns true if the type is a real-type, or else returns false]

   Description []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_pure\_int\_enum(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is a enum-type and its value
   are integers only. Otherwise - returns false.]

   Description [The kind of enum-type is analysed in the constructor.]

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_pure\_symbolic\_enum(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is a enum-type and its value
   are symbolic constants only. Otherwise - returns false.]

   Description [The kind of enum-type is analysed in the constructor.]

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_int\_symbolic\_enum(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is a enum-type and its value
   are symbolic AND integer constants. Otherwise - returns false.]

   Description [The kind of enum-type is analysed in the constructor.]

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_word\_1(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is a Unsigned Word type and the width of
   the word is 1. Otherwise - returns false.]

   Description []

   SideEffects []

   SeeAlso     [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_unsigned\_word(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is an unsigned Word type]

   Description []

   SideEffects []

   SeeAlso     [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_signed\_word(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is a signed Word type]

   Description []

   SideEffects []

   SeeAlso     [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_word(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is a Word type (signed or unsigned)]

   Description []

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_set(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is one of the set-types, i.e.
   boolean-set, integer-set, symbolic-set, integer-symbolic-set, and
   false otherwise.]

   Description []

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_string(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true, if the type is a String type]

   Description        []

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_error(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is a error-type, and false otherwise.]

   Description [Error type is used to indicate an error]

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_statement(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is a statement-type,
   and false otherwise.]

   Description []

   SideEffects []

   SeeAlso     [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_infinite\_precision(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true, if the type is one of infinite-precision types]

   Description [Inifinite-precision types are such as integer and real.]

   SideEffects []

   SeeAlso     [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_array(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns true if the type is an array-type, or else returns false]

   Description []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_wordarray(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true if the given type is a wordarray]

   Description        [.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbType\_calculate\_type\_size(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [The function calculate how many bits is required to
   store a value of a given type]

   Description [This function can be invoked only on finite-precision
   valid type of variables. This means that such types as no-type or error-type
   or real or any memory-shared ones should not be given to this function.
   ]

   SideEffects []

   SeeAlso     [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbType\_generate\_all\_word\_values(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Generates and returns a list of all possible values
   of a particular Unsigned Word type]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbType\_get\_word\_width(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the width of a Word type]

   Description        [The given type should be Word and the
   body of the type (given to the constructor) should be NUMBER node.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbType\_get\_wordarray\_awidth(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the width of the address in a WordArray type]

   Description        [.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbType\_get\_wordarray\_vwidth(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the width of the value in a WordArray type]

   Description        [.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbType\_get\_word\_line\_number(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns the line number where the type was declared.]

   Description [The body of the type, provided during construction, is
   a node NUMBER specifying the width of the Word or a node CONS
   specifying the address-value widths or WordArray.  This node was
   create during parsing and contains the line number of the type
   declaration.
   NB: The type should not be memory-sharing.
   NB: Virtually this function is used only in TypeChecker_is_type_wellformed
   ]

   SideEffects        []

   SeeAlso            [SymbType_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SymbType\_get\_enum\_type\_values(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the list of values of an enum type]

   Description        [The given type has to be a ENUM type.
   The return list is a list of all possible values of a enum type. This list
   was provided during construction.

   NB: Memory sharing types do not have particular values, since they
   are "simplified".]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_get\_array\_subtype(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis            [Get inner type of an array]

   Description         [The returned pointer belongs to the ginven SymbType_ptr
                        and must not be freed]

   SideEffects         []

   SeeAlso             []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbType\_get\_array\_lower\_bound(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis            [Get array lower bound]

   Description         []

   SideEffects         []

   SeeAlso             []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SymbType\_get\_array\_upper\_bound(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis            [Get array upper bound]

   Description         []

   SideEffects         []

   SeeAlso             []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbType\_print(const SymbType\_ptr self, FILE* output\_stream)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis            [Prints the type structure to the output stream.]

   Description         [This function is made very similar to print_node.
   If a Enum type was created with SymbType_create then all its values will be
   printed, otherwise the type was created with SymbTablePkg_..._type
   and simplified type name (instead of actual type values) is printed.
   ]

   SideEffects        []

   SeeAlso            [ SymbType_sprint ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* SymbType\_sprint(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis            [ Return a string representation of the given type. ]

   Description         [ This function is made very similar to sprint_node.
                         If an Enum type was created with
                         SymbType_create then all its values will be
                         printed, otherwise the type was created with
                         SymbTablePkg_..._type and simplified type
                         name (instead of actual type values) is
                         printed.

                         The returned string must be released by the caller. ]

   SideEffects        [ The returned string is allocated and has to be released
                        by the caller]

   SeeAlso            [ SymbType_print ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_back\_comp(const SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [returns true if the given type is "backward compatible",
   i.e. a enum or integer type.]

   Description        [We distinguish "old" types because we may want to turn
   off the type checking on these types for backward
   compatibility. Integer is also considered as "old", because an enum
   of integer values is always casted to Integer.]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_get\_greater(const SymbType\_ptr type1, const SymbType\_ptr type2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns one of the given types, if the other one
   can be implicitly converted to the former one. Otherwise - Nil.]

   Description        [The implicit conversion is performed
   in accordance to the type order.
   NOTE: only memory-shared types can be given to this function.]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_convert\_right\_to\_left(SymbType\_ptr leftType, SymbType\_ptr rightType)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the left type, if the right
   one can be implicitly converted to the left one. NULL - otherwise]

   Description        [The implicit conversion is performed
   in accordance to the type order.
   NOTE: only memory-shared types can be given to this function.]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_get\_minimal\_common(SymbType\_ptr type1, SymbType\_ptr type2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the minimal type to which the both given types
   can be converted, or Nil if there is none.]

   Description [The implicit conversion is performed in accordance to
   the type order.  NOTE: only memory-shared types can be given to this
   function except for SYMB_TYPE_ARRAY which can be non-memory shared]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_make\_set\_type(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns a minimal set-type which the given type
   can be implicitly converted to, or NULL if this is impossible.]

   Description        [
   The implicit conversion is performed in accordance to the type order.
   NOTE: only memory-shared types can be given to this function.]

   SideEffects        []

   SeeAlso            [SymbType_make_type_from_set_type]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_make\_from\_set\_type(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [This function is opposite to
   SymbType_make_set_type, i.e. if the given type is one of
   the set-types, then the type without "set" suffix is
   returned. Otherwise the type is returned without change.]

   Description        [
   More precisely the following conversion takes place:
   boolean-set -> boolean
   integer-set ->integer
   symbolic-set -> symbolic-enum
   integer-symbolic-set -> integer-symbolic-set
   another type -> the same type

   The implicit conversion is performed in accordance to the type order.
   NOTE: only memory-shared types can be given to this function.]

   SideEffects        []

   SeeAlso            [SymbType_make_set_type]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbType\_make\_memory\_shared(const SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [This function takes a NOT memory shared type
   and returns a memory shared one. ]

   Description        [The input type should have
   a corresponding memory shared type. For example, function type
   and error type do not have memory shared instances.]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_is\_memory\_shared(SymbType\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [True if and only if the given type is memory shared ]

   Description        []

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SymbType\_equals(SymbType\_ptr self, SymbType\_ptr oth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [ True if and only if the given types are equal, the given
   types can be memory-sharing or not. ]

   Description        []

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean node\_equal(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [ Equality function for node_ptr, used to compare bodies of
  types in SymbType_equal.]

  Description        []

  SideEffects        []

  SeeAlso            [SymbType_equal]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void str\_print(SymbTypePrinterInfo\_ptr pinfo, const char *fmt, ...)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Utility of SymbType_sprint and SymbType_print to print
                       in an fprintf-like fashion using information in the given
                       SymbTypePrinterInfo ]

  Description        [ This function prints the specified formatted string in
                       the pinfo ]

  SideEffects        []

  SeeAlso            [SymbType_print, SymbType_sprint]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void symb\_type\_sprint\_aux(const SymbType\_ptr self, SymbTypePrinterInfo\_ptr pinfo)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Utility of SymbType_sprint and SymbType_print to
                       actually print the type ]

  Description        [ This is the function that prints the SymbType using the
                       file stream or the string buffer provided by pinfo ]

  SideEffects        []

  SeeAlso            [SymbType_print, SymbType_sprint]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{symb\_table.c}
		
	\texttt{void SymbTablePkg\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initialises the class package.]

  Description        [This initialisation can be performed only after
  the Node package and the variable boolean_range have been initialised.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SymbTablePkg\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Shut down the package.]

  Description        [WARNING: the package de-initialisation
  destroys types created with the function SymbTablePkg_..._type.

  NB: The reason behind this constrain is the following: these functions
  exploit memory sharing, and this memory is freed during
  de-initialisation.

  In any case, the de-initialisation is performed by
  system "reset" command, and this command also frees all node_ptr,
  so in any case the symbolic types will be unusable, because they 
  use node_ptr inside. 
  SO, DESTROY ALL SYMBOLIC TYPES CREATED SO FAR BEFORE THE symb_table
  PACKAGE DE-INITIALISATION!  
  ]
  
  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_no\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a no-type]

  Description        [This type is a type of correct expressions
  which normally do not have any time. 
  The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_statement\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a no-type]

  Description [This type is a type of correct expressions which are
  statements, like assignments, or high-level nodes like TRANS, INIT,
  etc. The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_boolean\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a boolean enum type]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_pure\_symbolic\_enum\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a pure symbolic enum type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
  Do not access the values contained in the type's body.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_int\_symbolic\_enum\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a enum type containing integers AND symbolic 
  constants]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
  Do not access the values contained in the type's body.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_pure\_int\_enum\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a pure integer enum type]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
  Do not access the values contained in the type's body.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_integer\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns an Integer type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_real\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a Real type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_unsigned\_word\_type(int width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns an unsigned Word type (with a given width)]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_signed\_word\_type(int width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a signed Word type (with a given width)]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_wordarray\_type(int awidth, int vwidth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a WordArray type (given array width and value width)]

  Description        [The memory is shared, so you can compare pointers to
  compare types. The association is done based on the cons of awidth and vwidth.
  De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_array\_type(SymbType\_ptr subtype, int lower\_bound, int upper\_bound)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns an array type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
  PRECONDITION: subtype has to be created with one of SymbTypePkg_.._type 
  function.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_string\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a String type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_boolean\_set\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a boolean-set type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_integer\_set\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a integer-set type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_symbolic\_set\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a symbolic-set type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_integer\_symbolic\_set\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a integer-symbolic-set type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr SymbTablePkg\_error\_type()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns an Error-type.]

  Description        [The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static enum st\_retval symb\_table\_types\_hash\_cleaner(char * c1, char * c2, char *c3)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

  Synopsis           [The function is used to free the memory from
  memory-sharing Word/WordArray/Array types stored in the hash table
  symb_table_..._type_hash. Used in the SymbTablePkg_quit only]

******************************************************************************/

	\end{verbatimtab}
	
	\section{type\_checking}
		
	\section{checkers}
		
	\subsection{CheckerBase.c}
		
	\texttt{CheckerBase\_ptr CheckerBase\_create(const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates and initializes a checker.
  To be usable, the checker will have to be registered to a TypeChecker.]

  Description        [To each checker is associated a partition of
  consecutive indices over the symbols set. The lowest index of the
  partition is given through the parameter low, while num is the
  partition size. Name is used to easily identify checker instances. 

  This method is private, as this class is virtual]

  SideEffects        []

  SeeAlso            [NodeWalker_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL SymbType\_ptr CheckerBase\_check\_expr(CheckerBase\_ptr self, node\_ptr exp, node\_ptr ctx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks the given node]

  Description [This is virtual method. Before calling, please ensure
  the given node can be handled by self, by calling
  CheckerBase_can_handle. 

  Note: This method will be never called by the user]

  SideEffects        []

  SeeAlso            [CheckerBase_can_handle]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void checker\_base\_init(CheckerBase\_ptr self, const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CheckerBase class private initializer]

  Description        [The CheckerBase class private initializer]

  SideEffects        []

  SeeAlso            [CheckerBase_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void checker\_base\_deinit(CheckerBase\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CheckerBase class private deinitializer]

  Description        [The CheckerBase class private deinitializer]

  SideEffects        []

  SeeAlso            [CheckerBase_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL boolean checker\_base\_manage\_violation(CheckerBase\_ptr self, TypeSystemViolation violation, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Virtual protected method for violation handling]

  Description [This virtual method is called by checkers to handle 
  their violations. Tipically this method is not called directly, but 
  throw the macro _VIOLATION that casts its arguments and improves 
  readability (at least as main tentative idea)]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void checker\_base\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The CheckerBase class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SymbType\_ptr checker\_base\_check\_expr(CheckerBase\_ptr self, node\_ptr expression, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean checker\_base\_viol\_handler(CheckerBase\_ptr checker, TypeSystemViolation violation, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{CheckerCore.c}
		
	\texttt{CheckerCore\_ptr CheckerCore\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The CheckerCore class constructor]

   Description        [The CheckerCore class constructor]

   SideEffects        []

   SeeAlso            [NodeWalker_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void checker\_core\_init(CheckerCore\_ptr self, const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The CheckerCore class private initializer]

   Description        [The CheckerCore class private initializer]

   SideEffects        []

   SeeAlso            [CheckerCore_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void checker\_core\_deinit(CheckerCore\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The CheckerCore class private deinitializer]

   Description        [The CheckerCore class private deinitializer]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void checker\_core\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [The CheckerCore class virtual finalizer]

   Description [Called by the class destructor]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SymbType\_ptr checker\_core\_check\_expr(CheckerBase\_ptr self, node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    []

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean checker\_core\_viol\_handler(CheckerBase\_ptr self, TypeSystemViolation violation, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The type core violation handler.]

   Description        [The violation handler is implemented as
   a virtual method, which is invoked by the checker when an expression
   being checked violates the type system.
   See the violation handler TypeCheckingViolationHandler_ptr
   for more explanations.

   The below function is the default violation handler, and a
   user can potentially define its own violation handler, by deriving
   a new class from this class and by overriding this virtual method.

   This violation handler outputs an error and warning message to
   nusmv_stderr. A warning is output if the detected violation is
   TC_VIOLATION_TYPE_BACK_COMP and the system variable
   "type_checking_backward_compatibility" is true. Also the
   TC_VIOLATION_TYPE_WARNING violation outputs a warning. Only in
   this case the false value is returned, indicating that this is NOT
   an error. Otherwise the true value is returned, indicating that this
   is an error.

   Also, if the system variable "type_check_warning_on" is false,
   warning messages are not output.

   NB: if the expression is checked in some context (context is not null) then
   before providing the expression to this function the expression should be
   wrapped into context, i.e. with find_node(CONEXT, context, expr)]

   SideEffects       []

   SeeAlso           [TypeSystemViolation]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{CheckerPsl.c}
		
	\texttt{CheckerPsl\_ptr CheckerPsl\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CheckerPsl class constructor]

  Description        [The CheckerPsl class constructor]

  SideEffects        []

  SeeAlso            [NodeWalker_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void checker\_psl\_init(CheckerPsl\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CheckerPsl class private initializer]

  Description        [The CheckerPsl class private initializer]

  SideEffects        []

  SeeAlso            [CheckerPsl_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void checker\_psl\_deinit(CheckerPsl\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CheckerPsl class private deinitializer]

  Description        [The CheckerPsl class private deinitializer]

  SideEffects        []

  SeeAlso            [CheckerPsl_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void checker\_psl\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The CheckerPsl class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SymbType\_ptr checker\_psl\_check\_expr(CheckerBase\_ptr self, node\_ptr e, node\_ptr ctx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean checker\_psl\_viol\_handler(CheckerBase\_ptr self, TypeSystemViolation violation, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The type core violation handler.]

  Description        [The violation handler is implemented as
  a virtual method, which is invoked by the checker when an expression
  being checked violates the type system.
  See the violation handler TypeCheckingViolationHandler_ptr
  for more explanations.

  The below function is the default violation handler, and a
  user can potentially define its own violation handler, by deriving
  a new class from this class and by overriding this virtual method.

  This violation handler outputs an error and warning message to
  nusmv_stderr. A warning is output if the detected violation is
  TC_VIOLATION_TYPE_BACK_COMP and the system variable
  "type_checking_backward_compatibility" is true. Also the
  TC_VIOLATION_TYPE_WARNING violation outputs a warning. Only in this
  case the false value is returned, indicating that this is NOT an
  error. Otherwise the true value is returned, indicating that this is
  an error.

  Also, if the system variable "type_check_warning_on" is false,
  warning messages are not output.

  NB: if the expression is checked in some context (context is not null) then
  before providing the expression to this function the expression should be
  wrapped into context, i.e. with find_node(CONEXT, context, expr)]

  SideEffects       []

  SeeAlso           [TypeSystemViolation]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{CheckerStatement.c}
		
	\texttt{CheckerStatement\_ptr CheckerStatement\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CheckerStatement class constructor]

  Description        [The CheckerStatement class constructor]

  SideEffects        []

  SeeAlso            [CheckerStatement_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void checker\_statement\_init(CheckerStatement\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CheckerStatement class private initializer]

  Description        [The CheckerStatement class private initializer]

  SideEffects        []

  SeeAlso            [CheckerStatement_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void checker\_statement\_deinit(CheckerStatement\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CheckerStatement class private deinitializer]

  Description        [The CheckerStatement class private deinitializer]

  SideEffects        []

  SeeAlso            [CheckerStatement_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void checker\_statement\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The CheckerStatement class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SymbType\_ptr checker\_statement\_check\_expr(CheckerBase\_ptr self, node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean checker\_statement\_viol\_handler(CheckerBase\_ptr self, TypeSystemViolation violation, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The type core violation handler.]

  Description        [The violation handler is implemented as
  a virtual method, which is invoked by the checker when an expression
  being checked violates the type system.
  See the violation handler TypeCheckingViolationHandler_ptr
  for more explanations.

  The below function is the default violation handler, and a
  user can potentially define its own violation handler, by deriving
  a new class from this class and by overriding this virtual method.

  This violation handler outputs an error and warning message to
  nusmv_stderr. A warning is output if the detected violation is
  TC_VIOLATION_TYPE_BACK_COMP or TC_VIOLATION_DUPLICATE_CONSTANTS and
  the system variable "type_checking_backward_compatibility" is
  true. Also the TC_VIOLATION_TYPE_WARNING violation outputs a
  warning. Only in this case the false value is returned, indicating
  that this is NOT an error. Otherwise the true value is returned,
  indicating that this is an error.

  Also, if the system variable "type_check_warning_on" is false,
  warning messages are not output.

  NB: if the expression is checked in some context (context is not null) then
  before providing the expression to this function the expression should be
  wrapped into context, i.e. with find_node(CONEXT, context, expr)]

  SideEffects       []

  SeeAlso           [TypeSystemViolation]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{checkersInt.c}
		
	\texttt{boolean TypeSystemViolation\_is\_valid(TypeSystemViolation violation)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true iff given violation number is 
  supported by the system.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TypeChecker.c}
		
	\texttt{TypeChecker\_ptr TypeChecker\_create(SymbTable\_ptr symbolTable)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [TypeChecker class constructor]

   Description        [TypeChecker class constructor.
   The 'symbolTable' is a symbol table to look for the type of found
   identifiers]

   SideEffects        []

   SeeAlso            [TypeChecker_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TypeChecker\_ptr TypeChecker\_create\_with\_default\_checkers(SymbTable\_ptr symbolTable)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [TypeChecker class constructor, with registration of
   a set of default of checkers.]

   Description        [TypeChecker class constructor, with registration of
   a set of default of checkers.
   The 'symbolTable' is a symbol table to look for the type of found
   identifiers]

   SideEffects        []

   SeeAlso            [TypeChecker_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TypeChecker\_destroy(TypeChecker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The TypeChecker class destructor]

   Description        [The TypeChecker class destructor]

   SideEffects        []

   SeeAlso            [TypeChecker_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr TypeChecker\_get\_symb\_table(TypeChecker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the symbol table this type checker is
   associated to.]

   Description        [During its lifetime every type checker can deal only
   with one symbol table instance (because type checker caches the
   checked expressions and their types). The symbol table is given to
   the type checker during construction, and this function returns
   this symbol table.]

   SideEffects        []

   SeeAlso            [TypeChecker_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TypeChecker\_check\_layer(TypeChecker\_ptr self, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks that the types of variable decalarations
   in the layer are correctly formed. Also defines are checked to have
   some well-formed type.]

   Description        [Constrain: the input layer should belong to the symbol
   table the type checker is associated with.

   The function iterates over all variables in the layer, and checks their type
   with function TypeChecker_is_type_wellformed.

   The function also type checks the expressions provided in
   defines (also the generated "running" defines) have some type.
   NB for developers: This is done to allow the type checker
   to remember the type of these defines (and associated constants and variable
   _process_selector_). Without this list the evaluation phase will not
   know the type of these defines (if there were not explicitly used in the
   input text), since they can be implicitly used in ASSIGN(TRANS) contrains.

   Returns true if all the types are correctly formed and the defines
   are correct, false otherwise. ]

   SideEffects        []

   SeeAlso            [TypeChecker_is_type_wellformed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TypeChecker\_check\_constrains(TypeChecker\_ptr self, node\_ptr init, node\_ptr trans, node\_ptr invar, node\_ptr assign, node\_ptr justice, node\_ptr compassion)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks all the module contrains are correctly typed]

   Description        [
   The module contrains are declarations INIT, INVAR, TRANS, ASSIGN,
   JUSTICE, COMPASSION.

   The first parameter 'checker' is a type checker to perfrom checking.
   All the remaining parameters are the sets of expressions
   constituting the bodies of the corresponding high-level
   declarations. These expressions are created during compilation and
   then passed to this function unmodified, flattened or
   flattened+expanded.  So this function is relatively specialised to
   deal with concrete data-structures created during compilation. For
   example, the expressions in the given sets are expected to be
   separated by CONS and AND.

   NOTE: if an expression has been flattened, then
   info about line numbers mat not be accurate.

   The type checker remebers all the checked expressions and their
   types, thus TypeChecker_get_expression_type uses memoizing to
   return the type of already checked expressions.

   The parameter 'assign' is actually the 'procs' returned
   by Compile_FlattenHierarchy, which contains all the assignments.

   If some of expressions violates the type system, the type checker's
   violation handler is invoked. See checkers into the checkers
   sub-package for more info.

   Returns false if the module contrains violate the type system, and
   otherwise true is returned.
   ]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TypeChecker\_check\_property(TypeChecker\_ptr self, Prop\_ptr property)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks that the expression constituting the
   property is correctly typed]

   Description        [
   If some of expressions violates the type system, the type checker's
   violation handler is invoked. See checkers into the checkers
   sub-package for more info.

   The type checker remebers all the checked expressions and their
   types, thus TypeChecker_get_expression_type uses memoizing to return
   the type of already checked expressions.

   If the property violates the type system, the false value is return,
   and true value otherwise.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TypeChecker\_is\_expression\_wellformed(TypeChecker\_ptr self, node\_ptr expression, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The method type checks an expression and returns true
   if an expression is wellformed with respect to the type system and
   false otherwise.]

   Description        [
   The main purpose of this function is to be invoked on temporarily
   created expressions before they are evaluated to ADD or BDD.
   This function may not be useful for expressions read from files (such as
   bodies of INVAR, SPEC, etc) since they go through flattening in the
   compilation package and type-checked there.

   NOTE: an expression may be unmodified (after parsing and compilation),
   flattened or flattened+expanded.
   The expressions and their types are remembered by the type checker and
   the expressions types can be obtained with TypeChecker_get_expression_type.

   NOTE: memoizing is enabled before checking the expression.

   See checkers into the checkers sub-package for more info.]

   SideEffects        []

   SeeAlso            [type_checker_check_expression]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TypeChecker\_is\_specification\_wellformed(TypeChecker\_ptr self, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Performs type checking of a specification]

   Description        [
   A specification is a usual (i.e. able to have a type)
   expression wrapped into a node with a specification tag such as INIT,
   INVAR, SPEC, COMPASSION, etc.
   There are two special case:
   ASSIGN can contains a list of EQDEF statements, and
   COMPUTE can contains MIN and MAX statement.

   The returned value is true if no violations of the type system are detected,
   and false otherwise.

   NOTE: the expression may be unmodified (after compilation),
   flattened or flattened+expanded.
   The expressions and their types are remembered by the type checker and
   the expressions types can be obtained with TypeChecker_get_expression_type.

   NOTE: memizing is enbaled before checking the specification

   See checkers into the checkers sub-package for more info.]

   SideEffects        []

   SeeAlso            [type_checker_check_expression]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TypeChecker\_is\_type\_wellformed(TypeChecker\_ptr self, SymbType\_ptr type, node\_ptr varName)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks that a type is well formed.]

   Description        [
   This function is used to check the well-formedness of a type
   from a symbol table. This type should have properly created body,
   in particular, bodies should have correct line info.

   The constrains on a type are:
   1. word type: the width should be a NUMBER and have positive value.
   The width should not be greater than implemenetation limit
   WordNumber_max_width() bit (since we do not use
   arbitrary-precision arithmetic and ADD structores will be
   too big otherwise)
   2. enum type: there should be no duplicate values.

   The third parameter is the variable name that type is to be checked.
   The variable name is used just to output proper message in the case
   of a type violation.

   In the case of a type violation the violation handler obtain an
   expression CONS with variable name as left child and the body of the type
   as the right child.
   ]

   SideEffects        []

   SeeAlso            [type_checker_check_expression]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr TypeChecker\_get\_expression\_type(TypeChecker\_ptr self, node\_ptr expression, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the type of an expression.]

   Description        [If the expression has been already type-checked
   by the same type-checker, then the type of an expression is returned.
   Otherwise, the expression is type checked and its type is returned.

   The parameter 'context' indicates the context where expression
   has been checked. It should be exactly the same as during type checking.
   For outside user this parameter is usually Nil.
   NOTE: The returned type may be error-type indicating that
   the expression violates the type system.
   NOTE: all returned types are the memory-sharing types
   (see SymbTablePkg_..._type). So you can compare pointers instead of
   the type's contents.

   ]

   SideEffects        [TypeChecker_is_expression_wellformed,
   TypeChecker_is_specification_wellformed]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TypeChecker\_is\_expression\_type\_checked(TypeChecker\_ptr self, node\_ptr expression, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true iff a given expression has been type checked]

   Description        [If this function returns true then
   TypeChecker_get_expression_type will return the cached type without performing
   the actual type checking.

   The parameter 'context' indicates the context where expression
   has been checked. It should be exactly the same as during type checking.
   For outside user this parameter is usually Nil.
   ]

   SideEffects        []

   SeeAlso            [TypeChecker_get_expression_type]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr tc\_set\_expression\_type(TypeChecker\_ptr self, node\_ptr expression, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Creates the association between an expression and
   its type, if memoizing is enabled]

   Description        [There should be not existing associated type
   for a given expression.

   Note: if there is (not null) context then the expression
   must be wrapped into CONTEXT expression. For example,
   for an expression exp and not null context ctx, the
   expression provided for this function should be find_node(CONTEXT, ctx, exp).
   The expression should not be wrapped into Nil context.]

   SideEffects        []

   SeeAlso            [tc_lookup_expr_type]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr tc\_lookup\_expr\_type(TypeChecker\_ptr self, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Looks up the internal type memoizing for expression's type
   and returns the associated type, or nullType if the expression was not
   previously checked]

   Description [If memoizing is not enabled, nullType will always be
   returned]


   SideEffects        []

   SeeAlso            [tc_set_expression_type]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr type\_checker\_check\_expression(TypeChecker\_ptr self, node\_ptr expression, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Perform type checking of an expression, and returns its
   type]

   Description        [This function is the core of the expression type
   checking.

   The expression may by unmodified (after compilation), flattened or
   flattened+expanded.

   The return value is the type of the expression.  If an expression
   violates the type system, the violation handler function is invoked
   and "error" type is returned (not NULL).



   NB: As it is said in TypeChecker.h, the expression type checking package
   uses only memory-shared types (SymbTablePkg_..._type).

   NB: This function does not perform the type checking on already
   checked expressions (even if they were erroneous), but just returns
   their types (possibly error-type). This avoids multiple error and warning
   messages for the same subexpression.]

   SideEffects        []

   SeeAlso            [type_checking_violation_handler]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void type\_checker\_print\_error\_message(TypeChecker\_ptr self, node\_ptr expr, boolean is\_error)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Prints whther an error or a warning message, depending on
   the given parameter]

   Description [This private funciont is called by violation handler
   into checkers and self, to print a uniform message when type errors
   and warnings occur]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void type\_checker\_enable\_memoizing(TypeChecker\_ptr self, boolean enabled)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Enables or disables internal type memoizing]

   Description [This method is used by checkers to temporary disable
   internal type memoizing that associates each sub-expression to its
   type.  This can be used to force an already checked formula to be
   re-checked.  For example the PSL checker while checking 'forall'
   expressions requires the repeated formula to be checked as many times as
   the id has a range of possible values.

   Important: memoizing is enabled by default and re-enabled every time
   the user calls the top level checking method. However, it is good
   behaviour for checkers to re-enable memoizing after disabling it]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean type\_checker\_is\_memoizing\_enabled(const TypeChecker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true if memoizing is currently enabled, false
   otherwise]

   Description        []

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void type\_checker\_init(TypeChecker\_ptr self, SymbTable\_ptr symbolTable)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The TypeChecker class private initializer]

   Description        [The TypeChecker class private initializer]

   SideEffects        []

   SeeAlso            [TypeChecker_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void type\_checker\_deinit(TypeChecker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The TypeChecker class private deinitializer]

   Description        [The TypeChecker class private deinitializer]

   SideEffects        []

   SeeAlso            [TypeChecker_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void type\_checker\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [The PrinterBase class virtual finalizer]

   Description [Called by the class destructor]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean type\_checker\_viol\_handler(TypeChecker\_ptr self, TypeSystemViolation violation, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The type core violation handler.]

   Description        [The violation handler is implemented as
   a virtual method, which is invoked by the checker when an expression
   being checked violates the type system.
   See the violation handler TypeCheckingViolationHandler_ptr
   for more explanations.

   The below function is the default violation handler, and a
   user can potentially define its own violation handler, by deriving
   a new class from this class and by overriding this virtual method.

   This violation handler outputs an error and warning message to
   nusmv_stderr. A warning is output if the detected violation is
   TC_VIOLATION_DUPLICATE_CONSTANTS and
   the system variable "type_checking_backward_compatibility" is
   true. Only in this case the false value is returned, indicating that
   this is NOT an error. Otherwise the true value is returned,
   indicating that this is an error.

   Also, if the system variable "type_check_warning_on" is false,
   warning messages are not output.

   NB: if the expression is checked in some context (context is not null) then
   before providing the expression to this function the expression should be
   wrapped into context, i.e. with find_node(CONEXT, context, expr)]

   SideEffects       []

   SeeAlso           [TypeSystemViolation]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void type\_checker\_memoizing\_force\_enabled(TypeChecker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Resets memoizing to be enabled]

   Description [This function is called by high level type checking
   functions to enable memoizing]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void type\_checker\_reset\_memoizing(TypeChecker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Resets memoizing, cleaning up all type information]

   Description [This function is called by high level type checking
   functions to reset memoizing, after an error occurs]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void type\_checker\_remove\_symbol\_trigger(const SymbTable\_ptr st, const node\_ptr sym, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Trigger for symbols removal in the symbol table]

   Description        [Trigger for symbols removal in the symbol table.
                       When invoked, clears the memoization hash.]

   SideEffects        []

   SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{FlatHierarchy.c}
		
	\texttt{FlatHierarchy\_ptr FlatHierarchy\_create(SymbTable\_ptr st)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [The constructor]

Description        [The class is used to store information
obtained after flattening module hierarchy.
These class stores:
the list of TRANS, INIT, INVAR, ASSIGN, SPEC, COMPUTE, LTLSPEC,
PSLSPEC, INVARSPEC, JUSTICE, COMPASSION,
a full list of variables declared in the hierarchy,
a hash table associating variables to their assignments and constrains.

NOTE: this structure is filled in by compileFlatten.c routines. There are
a few assumptions about the content stored in this class:
1. All expressions are stored in the same order as in the input
file (in module body or module instantiation order).
2. Assigns are stored as a list of pairs
{process instance name, assignments in it}.
3. Variable list contains only vars declared in this hierarchy.
4. The association var->assignments should be for assignments of
this hierarchy only.
Note that var may potentially be from another hierarchy. For
example, with Games of the GAME package an assignment in the body of
one hierarchy (one player) may have on the left hand side a variable from
another hierarchy (another player).
See FlatHierarchy_lookup_assign, FlatHierarchy_insert_assign
5. The association var->constrains (init, trans, invar) should be
for constrains of this hierarchy only. Similar to
var->assignment association (see above) a variable may
potentially be from another hierarchy.
See FlatHierarchy_lookup_constrains, FlatHierarchy_add_constrains
]

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{EXTERN FlatHierarchy\_ptr FlatHierarchy\_create\_from\_members(SymbTable\_ptr st, node\_ptr init, node\_ptr invar, node\_ptr trans, node\_ptr input, node\_ptr justice, node\_ptr compassion)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Class FlatHierarcy destructorUtility constructor]

Description        [Use this constructor to set the main hierarchy members]

SideEffects        [FlatHierarchy_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_destroy(FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Class FlatHierarcy destructor]

Description        [The destoructor does not destroy the nodes
given to it with access functions.]

SideEffects        [FlatHierarchy_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FlatHierarchy\_ptr FlatHierarchy\_copy(const FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns a newly created instance that is a copy of self]

Description        []

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_mergeinto(FlatHierarchy\_ptr self, const FlatHierarchy\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Merges the contents of other into self (leaves other
intact)]

Description        []

SideEffects        [flat_hierarchy_mergeinto,
SexpFsm_apply_synchronous_product]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr FlatHierarchy\_get\_symb\_table(const FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the associated symbol table]

Description        []

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_set\_symb\_table(const FlatHierarchy\_ptr self, SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the associated symbol table]

Description        []

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr FlatHierarchy\_get\_init(FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [A set of functions accessing the fields of the class]

Description        []

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t FlatHierarchy\_get\_vars(const FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns the set of variables declared in the given hierarchy]

Description        [Do not destroy or change returned set]

SideEffects        []

SeeAlso            [FlatHierarchy_add_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr FlatHierarchy\_get\_ordered\_vars(const FlatHierarchy\_ptr self, hash\_ptr* outbound\_edges)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns an ordered list of variables]

Description        [Starting from hierarchy assignments, creates a DAG
                    and returns the topological sort of it. The set of nodes
                    contained in this dag is the union of the dependencies
                    of all assings expressions of the hierarchy.
                    If not NULL, outbound_edges will contain a map between vars
                    and their respective outgoing edges to other variables]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_add\_var(FlatHierarchy\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Add a variable name to the list of variables
declared in the given hierarchy]

Description        []

SideEffects        []

SeeAlso            [FlatHierarchy_get_vars]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_remove\_var(FlatHierarchy\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Remove a variable name to the list of variables
                    declared in the given hierarchy]

Description        []

SideEffects        []

SeeAlso            [FlatHierarchy_get_vars]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr FlatHierarchy\_lookup\_assign(FlatHierarchy\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the right handside of an assignment which has
"name" as the left handside.]

Description        [The name can be a usual variable name, init(variable
name) or next(variable name). The name should be fully resolved (and
created with find_node).

NB: All returned assignments are supposed to be declared in the
given hierarchy.]

SideEffects        []

SeeAlso            [FlatHierarchy_insert_assign]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_insert\_assign(FlatHierarchy\_ptr self, node\_ptr name, node\_ptr assign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Insert the right handside of an assignment which
has "name" as the left handside]

Description        [The name can be a usual variable name, init(var-name) or
next(var-name).
The variable name should be fully resolved (and created  with find_node).

NB: All given assignments should have been declared in the given hierarchy.]

SideEffects        []

SeeAlso            [FlatHierarchy_lookup_assign]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr FlatHierarchy\_lookup\_constrains(FlatHierarchy\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns  a list of constrains which contain
a variable of the given name.]

Description        [
If the parameter "name" is a usual variable name then
the INVAR expressions are returned.
If the parameter "name" has a form init(var-name) then
the INIT expressions are returned.
If the parameter "name" has a form next(var-name) then
the TRANS expressions are returned.

The name should be fully resolved (and created with find_node).

NB: All returned expressions are supposed to be declared in the
given hierarchy.]

SideEffects        []

SeeAlso            [FlatHierarchy_add_constrains]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_add\_constrains(FlatHierarchy\_ptr self, node\_ptr name, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Adds the given expressions to the list
of constrains associated to the given variable]

Description        [
The parameter "name" can be a usual variable name then
an expression is expected to be INVAR body.
The parameter "name" can have a form init(var-name) then
an expression is expected to be INIT body.
The parameter "name" can have a form next(var-name) then
an expression is expected to be TRANS body.

In any case the variable name should be fully resolved (and created
with find_node).

NB: All given expressions should have been declared in the given hierarchy.]


SideEffects        []

SeeAlso            [FlatHierarchy_lookup_constrains]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr FlatHierarchy\_lookup\_constant\_constrains(FlatHierarchy\_ptr self, int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Retrieves the list of constrains associated to constants]

Description        [Retrieves the list of constrains associated to constants
                    for the given hierarchy section.
                    Type must be one of "INIT, INVAR or TRANS"]


SideEffects        []

SeeAlso            [FlatHierarchy_add_constant_constrains]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_add\_constant\_constrains(FlatHierarchy\_ptr self, node\_ptr expr, int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Adds the given expressions to the list
                    of constrains associated to constants]

Description        [Adds the given expressions to the list
                    of constrains associated to constants.
                    Type must be one of "INIT, INVAR or TRANS"]


SideEffects        []

SeeAlso            [FlatHierarchy_lookup_constant_constrains]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr FlatHierarchy\_get\_constants\_associations(FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [This function returns the hash table storing the
                    association between the hierarchy section and
                    constants expressions]

Description        [self retains ownership of returned value.
                    Note: you should know what you are doing when
                    performing modifications on the table.  ]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_set\_constants\_associations(FlatHierarchy\_ptr self, hash\_ptr h)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [This function sets the hash table storing the
                    association between the hierarchy section and
                    constants expressions]

Description        [self retains ownership of h.
                    Note: you should know what you are doing when
                    performing modifications on the table.  ]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_clear\_constants\_associations(FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Clears the association between hierarchy sections
                    and constant expressions]

Description        [Clears the association between hierarchy sections
                    and constant expressions]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_calculate\_vars\_constrains(FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Creates association between variables and all the expressions
the variables occur in.]

Description [For every variable var-name in the given expressions the
function creates association between:
1. var-name and and the INVAR expression list the variable occur.
2. init(var-name) and INIT expression list
3. next(var-name) and TRANS expression list.
The result is remembered by flatHierarchy.

The function compileFlattenProcess works similarly but with assignments.]

SideEffects        []

SeeAlso            [compileFlattenProcess]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr FlatHierarchy\_get\_var\_expr\_associations(FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [This function returns the hash table storing the
association between a variable name and expressions the variable is used in.]

Description        [self retains ownership of returned value.

Note: you should know what you are doing when performing modifications
on the table.
]


SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_set\_var\_expr\_associations(FlatHierarchy\_ptr self, hash\_ptr h)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [This function sets the hash table storing the
association between a variable name and expressions the variable is used in
to h.]

Description        [self obtains ownership of h.

Note: you should know what you are doing when using this function. You are
fully responsible that the contents of h make sense - no checks are performed
whatsoever.
]


SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_clear\_var\_expr\_associations(FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [This function cleans the association between a variable name
and expressions the variable is used in.]

Description        [
Practically, this function cleans association created by
FlatHierarchy_insert_assign and FlatHierarchy_add_constrains such that
functions FlatHierarchy_lookup_assign and FlatHierarchy_lookup_constrains
will return Nil for any var name.

Note: you should know what you are doing when invoke this function since
it makes COI and various checks of FSM incorrect.
]


SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FlatHierarchy\_self\_check(const FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Performs a self check of the instance content wrt the
                    set of language self was declared to contain]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void flat\_hierarchy\_init(FlatHierarchy\_ptr self, SymbTable\_ptr st)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [initialisation function used by the constructor]

Description        []

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void flat\_hierarchy\_deinit(FlatHierarchy\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [de-initialisation function used by the destructor]

Description        []

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void flat\_hierarchy\_copy(const FlatHierarchy\_ptr self, FlatHierarchy\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Copies self's data into other, so that other contains
the same information]

Description        []

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void flat\_hierarchy\_mergeinto(FlatHierarchy\_ptr self, const FlatHierarchy\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Performs the actual merging.]

Description        []

SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void flat\_hierarchy\_calc\_var\_const\_aux(FlatHierarchy\_ptr self, node\_ptr expr, int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           []

Description        [see compileFlattenSexpModel]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void flat\_hierarchy\_calc\_var\_const\_recur(FlatHierarchy\_ptr self, node\_ptr expr, int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           []

Description        [see compileFlattenSexpModel]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean flat\_hierarchy\_check\_const\_deps(FlatHierarchy\_ptr self, node\_ptr expr, int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Called when a constant has been found in INVAR, INIT or
TRANS]

Description         [If the constant is trivially true, false is returned.
                     In all other cases, this function returns true
                     NB: This function has been keept ONLY for the
                     verbosity it produces]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void flat\_hiearchy\_self\_check\_expr(const FlatHierarchy\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Internal service to self-check that a given
                       expression's language is contained within
                       the set of variables which this FH was
                       declared to have at construction time ]

   Description        [optional]

   SideEffects        []

   SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static const char* constr\_type\_to\_string(int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [required]

Description        [optional]

SideEffects        []

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PredicateExtractor.c}
		
	\texttt{PredicateExtractor\_ptr PredicateExtractor\_create(SymbTable\_ptr st, boolean use\_approx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [The constructor creates a predicate-extractor]

   Description [See PredicateExtractor.h for more info on
   predicates and clusters.  The parameter 'checker' is a type checker
   used during predicate extraction and subsequent type checking of
   generated expressions.

   Parameter use_approx can be used to make the extractor
   give up when dealing with too-large expressions. This is
   currently used by the heuristics which extract the variable
   ordering out of the fsm.   

   NOTE that the type checker remembers the type of checked
   expressions (free or reuse nodes with care).]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PredicateExtractor\_destroy(PredicateExtractor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Class PredicateExtractor destructor]

   Description []

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PredicateExtractor\_compute\_preds(PredicateExtractor\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [The function computes and collects
   the predicates of a given expression]

   Description [
   See PredicateExtractor.h for more info on predicates and clusters.

   Note: that normalization of the input expression is not done.  Only
   predicates are computed (the lesser things are done the lesser
   time/memory is spent). See class PredicateNormaliser if
   predicate-normalized expressions are required.

   To additionally get/compute clusters
   PredicateExtractor_get_all_clusters can be used.

   Input expressions may/may not be expanded/normalized/flattened,
   whereas the collected predicates are flattened, expanded and
   created with find_node, in particular all identifiers fully
   resolved.

   WARNING: memoization is done. Providing the same expression a second
   times does not produce any additional predicate.

   Collected clusters/predicates are stored internally and can be
   obtained with PredicateExtractor_get_all_preds and
   PredicateExtractor_get_all_clusters.  ]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PredicateExtractor\_compute\_preds\_from\_hierarchy(PredicateExtractor\_ptr self, FlatHierarchy\_ptr fh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [This function applies PredicateExtractor_compute_preds
   to every element of an hierarchy]

   Description [Note that symbol table in self has to correspond to
   the hierarchy, i.e. contains all the required symbols]

   SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t PredicateExtractor\_get\_all\_preds(const PredicateExtractor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns the set of predicates computed so far]

   Description [Predicates are fully expanded and resolved expressions
   created with find_node, i.e. no freeing or modifications are allowed.
   Returned Set_t belongs to self.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t PredicateExtractor\_get\_all\_clusters(const PredicateExtractor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns the set of clusters for all so far collected
   predicates]

   Description [This function computes and returns clusters for all so far
   computed predicates.

   Returned result is Set_t of Set_t of fully resolved variables.
   Everything returned belongs to self.

   Note that this function perform computation and may take some time
   (though intermediate results are remembered between calls).

   It is possible to get a group of predicates responsible for a given
   cluster with PredicateExtractor_get_preds_of_a_cluster.

   NOTE: subsequent call of PredicateExtractor_compute_preds makes any
   data returned by this function invalid.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t PredicateExtractor\_get\_var\_cluster(const PredicateExtractor\_ptr self, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Given a fully resolved var name the function
   returns a cluster the variable belongs to]

   Description [If clusters were not computed before this function
   triggers the cluster computation.

   Returned result is Set_t of fully resolved variables.
   Everything returned belongs to self.

   If a var was not met in any of predicates then NULL is
   returned. (This is always so for boolean vars since boolean vars
   cannot be in predicates).

   NOTE: subsequent call of PredicateExtractor_compute_preds makes any
   data returned by this function invalid.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t PredicateExtractor\_get\_preds\_of\_a\_cluster(const PredicateExtractor\_ptr self, Set\_t cluster)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns a set of predicates responsible for a given cluster]

   Description [Given a cluster (Set_t of vars) returned by
   PredicateExtractor_get_all_clusters this function
   returns a set of predicates which caused the given cluster.

   Returned result is not-empty Set_t of fully expanded/resolved expressions
   and belongs to self.

   NOTE: subsequent call of PredicateExtractor_compute_preds makes any
   data returned by this function or
   PredicateExtractor_get_all_clusters invalid.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PredicateExtractor\_print(const PredicateExtractor\_ptr self, FILE* stream, boolean printPredicates, boolean printClusters)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [The function prints out the predicates collected so far
   and clusters computed.]

   Description [Options printPredicates and printClusters
   control what should be printed.
   At least one of them has to be set up.

   If only predicates are printed, then they are printed in the order
   they were obtained.

   Otherwise, clusters are printed and if additionally printPredicates
   is up then the after every cluster its predicates are printed.

   Note that if clusters were not computed so far but asked to be
   printed, they will be computed.
   ]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void pred\_extract\_init(PredicateExtractor\_ptr self, SymbTable\_ptr st, boolean use\_approx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [initialiser of an object of this class]

   Description []

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void pred\_extract\_deinit(PredicateExtractor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [de-initialiser of an object of this class]

   Description []

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t pred\_extract\_process\_recur(PredicateExtractor\_ptr self, node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Performs the predicates extraction]

   Description [See PredicateExtractor_compute_preds for more info.

   This is the main function for extraction.

   The function returns the set of predicate subparts, i.e. Set_t of
   node_ptr. For expressions having whole predicates (i.e. boolean
   expressions) PREDICATES_TRUE/PREDICATES_FALSE/PREDICATES_ARBITRARY
   value is returned.

   Returned set of predicate subparts belong to self->expr2preds. The
   expression (predicates subparts are find_node-ed and belong to
   whole system).]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean pred\_extract\_is\_bool\_preds(Set\_t result)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis   [This function returns true iff the result set of predicates
   subparts may belong only to boolean expression]

   Description [There 2 expressions which can be boolean and not
   boolean at the same time: "0" and 1".  These can be considered
   as predicate subparts as well as complete predicates.

   This function returns true iff the result consists of such kind
   of predicates.]

   SideEffects  [pred_extract_process_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t pred\_extract\_fix\_any\_preds(PredicateExtractor\_ptr self, Set\_t result)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [This function put any expression in the set into
   "self" as complete predicates. "result" if released by this
   function.]

   Description []

   SideEffects  [pred_extract_process_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t pred\_extract\_bool2int(PredicateExtractor\_ptr self, node\_ptr expr, Set\_t preds)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis   [This function perform cast bool-to-int during predicate
   extraction. Result set can be accessed but not remembered
   in self->expr2preds.]

   Description [Normally bool2int cast means the predicate subparts
   are the set {0, 1}. But as optimization this function checks the
   original expression. If it is TRUE then only number 1 is returned,
   if it is FALSE then 0 is returned, and only otherwise {0,1} is
   returned.

   'expr' is the original expression and 'preds' is predicate set computed
   for expr.

   The returned Set_t belongs to self->special_int_preds and cannot be
   used anywhere else. Use Set_Copy to create a copy to store it in
   the expr2preds.

   NOTE: 'expr' is not actually required. currently used for debugging only.
   ]

   SideEffects  [pred_extract_process_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t pred\_extract\_apply\_unary(PredicateExtractor\_ptr self, int type, Set\_t childResult)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [This function take a unary operator,
   the result of predicates extraction of the child expression
   and returns new result for the whole expression.]

   Description [This function is used only by pred_extract_process_recur.
   Created set belongs to the invoker, i.e. to pred_extract_process_recur
   which will insert them into self->expr2preds.

   ]

   SideEffects  [pred_extract_process_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t pred\_extract\_apply\_binary(PredicateExtractor\_ptr self, int type, Set\_t leftResult, Set\_t rightResult)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [This function take a binary operator,
   the results of predicates extraction of the children subexpressions
   and returns new result for the whole expression]

   Description [This function is used only by pred_extract_process_recur.
   Created set belongs to an invoker, pred_extract_process_recur which will
   insert them into self->expr2preds.

   ]

   SideEffects  [pred_extract_process_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PredicateNormaliser.c}
		
	\texttt{PredicateNormaliser\_ptr PredicateNormaliser\_create(SymbTable\_ptr st)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The constructor creates a predicate-normaliser]

   Description [See PredicateNormaliser.h for more info on
   predicate normalisation.  The paramer 'checker' is a type checker
   used during predication-normalisation, and subsequent type checking of
   generated expressions.
   NOTE that the type checker remember the type of checked expressions.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PredicateNormaliser\_destroy(PredicateNormaliser\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Class PredicateNormaliser destructor]

   Description        []

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr PredicateNormaliser\_normalise\_expr(PredicateNormaliser\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The function performs predicate-normalisation of
   a generic boolean expression]

   Description [The function returns a new expression -- a
   predicate-normalised version of the given one.
   A predicate normalised expression is a symbolic expression (Sexp)
   whose not-boolean subexpressions do not encompass boolean subexpression.
   For example, not predicate-normalised expression
   "case a : 3; 1 : 4; esac + 2 = 7"
   after normalisatio becomes
   "case a : 3 + 2 = 7; 1 : 4 + 2 = 7; esac"

   The provided expression should be scalar (since there is no
   meaning to normalise booleanised expressions).  The given
   expression must be already type checked (by the type checker
   given to the constructor), but may be or may not be flattened
   and expanded.

   During normalisation the type checker (given during construction) is
   used to distinguish boolean from not-boolean expressions.
   Note that the generated expressions may be type checked, i.e. the type
   checker remember their types.

   The normaliser caches processed expressions. So, if the same expression is
   given, the same result will be returned.

   The returned expression is always flattened and expanded. Also, it
   is created by find_node function, therefore it belongs to
   the node package (i.e. do not modify it).

   NOTE: if only predicates are required at the end and not the whole
   normalized expressions, then it is better to use PredicateExtractor
   class.  ]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr PredicateNormaliser\_normalise\_specification(PredicateNormaliser\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The function performs predicate-normalisation of
   specification (SPEC, LTLSPEC, etc)]

   Description [This function does the same things as
   PredicateNormaliser_normalise_expr, except that the input expression
   must be a specification (such expression are returned by Prop_get_expr_core)
   ]

   See also           [PredicateNormaliser_normalise_expr]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PredicateNormaliser\_get\_predicates\_only(const PredicateNormaliser\_ptr self, Set\_t* preds, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The function adds to the given set the expression's
   predicates, i.e. subexpressions which have not-boolean operands.]

   Description [Only boolean expressions obtained with
   PredicateNormaliser_normalise_expr and with the same
   predicate-normaliser (i.e. 'self') can be given to this function.

   See function PredicateNormaliser_compute_predicates_and_clusters
   if only predicates are required without normalization of a whole expression.

   This function just walks the exressions, tries to find
   a subexpression with not-boolean operands then adds it to the given set.
   Every predicate is added only once.
   ]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PredicateNormaliser\_print\_predicates\_only(const PredicateNormaliser\_ptr self, FILE* stream, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The function prints out the expressions's
   predicates, i.e. subexpressions which
   have not-boolean operands.]

   Description [Only expressions obtained with
   PredicateNormaliser_normalise_expr and with the same
   predicate-normaliser (i.e. 'self') can be given to this function.

   This function just walks the exressions, tries to find
   a subexpression with not-boolean operands then print it.
   ]

   SideEffects        [PredicateNormaliser_get_predicates_only]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void pred\_norm\_init(PredicateNormaliser\_ptr self, SymbTable\_ptr st)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [initialiser of an object of this class]

   Description        []

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void pred\_norm\_deinit(PredicateNormaliser\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [de-initialiser of an object of this class]

   Description        []

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr pred\_norm\_normalise(PredicateNormaliser\_ptr self, node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Performs the predicate-normalisation of an expression]

   Description        [See PredicateNormaliser_normalise_expr
   for more info on predicate-normalisation.
   This function is the main part of normalisation.

   NB for developers: the main idea behind this function is that
   if a not-boolean operation is applied (to one or two not-boolean operands),
   then ITE from operands must be pushed up to the root of the expression.
   For example,
   "case a : 3; true : 5; esac + 400"
   is converted to
   "case a : 3 + 400; true : 5 + 400; esac"
   i.e. after convertion not-boolean operand will not have ITE, and
   therefore will not have boolean subexpression.

   Boolean expressions are not changed since boolean expressions
   may have any subexpression.
   ]

   SideEffects        []

   SeeAlso            [PredicateNormaliser_normalise_expr]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr pred\_norm\_find\_node(PredicateNormaliser\_ptr self, int kind, node\_ptr oper1, node\_ptr oper2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Create a new node with the help of find_node function]

   Description         [This function is the same as find_node, except that if
   the operator is commutative then operands are ordered before applying
   find_node. This may result in a greater sharing.

   Note that it is necessary to use find_node during construction
   of the expression, because later subexpressions with not-boolean operands
   will be assigned a new boolean var. Since find_node is used,
   the same var will be assigned to the same subexpression (because pointer
   will be the same).]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean pred\_norm\_is\_true\_bool\_exp(PredicateNormaliser\_ptr self, node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true is the given expression is a boolean
   expression]

   Description        [This function returns true if the expression
   is "really boolean", i.e. has a boolean types and
   NOT constants "0" and "1" and NOT mod-operation.
   (Currently, "0", "1" and "expr mod 2" is officially a boolean expression).

   This function is used to detect cases when a boolean expression
   must be converted to an integer one. And this function decreases the number
   of such conversions.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr pred\_norm\_bool2int(PredicateNormaliser\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Casts a boolean expression to an integer expression]

   Description        [the function takes an boolean expression and
   converts its to integer by the following way:
   if "expr" is original expressions, then the result is
   "case expr: 1; 0; esac"]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr pred\_norm\_bool2word1(PredicateNormaliser\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Cast a boolean expression to a Word[1] expression]

   Description        [ the function takes an boolean expression and
   converts its to Word[1] by the following way:
   if "expr" is an original expressions then the result is
   "case expr: 0b1_1; 0b1_0; esac"
   ]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr pred\_norm\_push\_ite\_up(PredicateNormaliser\_ptr self, int op, node\_ptr oper1, node\_ptr oper2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Applies an operators to two (or one) not-boolean operands
   The returned value is predicate-normalised]

   Description        [The function takes an operator and its two operands and
   return an expression of applying the operator to operands.
   The operands are assumed to be not-boolean.
   The distinguishing feature of the function is that
   if operands are ITE expresssions, then ITE will be pushed up from
   operands to the root of the result expression. For example,
   if input operator is "+",
   the left operator is "case a1 : e1; a2 : e2; 1 : e3; esac"
   the right opeator is "case b1 : s1; b2 : s2; 1 : s3; esac"
   then the result will be (if nested ITE are not allowed, see
   ALLOW_NESTED_CASES)
   "case
   a1 & b1 : e1 + s1;
   a1 & b2 : e1 + s2;
   a1      : e1 + s3;
   a2 & b1 : e2 + s1;
   a2 & b2 : e2 + s2;
   a2      : e2 + s3;
   b1      : e3 + s1;
   b2      : e3 + s2;
   1       : e3 + s3;
   esac"
   another possible result can be (if nested ITE are allowed):
   "case
   a1 : case b1 : e1 + s1;
             b2 : e1 + s2;
                   1  : e1 + s3;
        esac;
   a2 : case b1 : e2 + s1;
             b2 : e2 + s2;
             1  : e2 + s3;
        esac;
   b1 : e3 + s1;
   b2 : e3 + s2;
   1  : e3 + s3;
   esac"

   Macro ALLOW_NESTED_CASES switches these two behaviours.

   If the given operator is unary then the oper2 is Nil.

   NB: If the operator is unary, the second operand will be Nil.

   NB: if the operator is NEXT or SMALLINIT, then it, of course, applied to
   the conditions of ITE also (not only to the second and third operators).
   ]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr pred\_norm\_push\_ite\_up\_conditioned(PredicateNormaliser\_ptr self, node\_ptr condition, int op, node\_ptr exp1, node\_ptr exp2, node\_ptr tail)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [This function takes condition (cond),
   operator (op), three expressions (exp1, exp2 and tail) and creates
   an expression ITE(cond, op(exp1, exp2), tail) and then pushes all
   ITE from exp1 and exp2 up (if required).]


   Description        [The function creates a new expression with the semantics
   ITE(condition, exp1 op exp2, tail)
   'condition' is the condition of ITE,
   op - binary operation,
   exp1, exp2 - expression,
   tail - is the else-expression of created ITE.

   This function is used to normalise not-boolean expressions (exp1 and exp2).

   If nested ITE are not allowed, then exp1 cannot be an ITE expression, but
   exp2 can be. In this case the return value is
   a linearised (one-dimensional) ITE expression (i.e. only
   else-expression of ITE can contain another ITE). To obtain such
   form, given 'condition' will be conjuncted with all conditions in
   exp2, and exp1 will be applied to all expressions in exp2 and the
   final expression in the list of ITE will be 'tail'.

   Otherwise, nested ITE are allowed and no normalisation is required.

   If the given operator is unary then the oper2 is Nil.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr pred\_norm\_normalise\_ite(PredicateNormaliser\_ptr self, node\_ptr cond, node\_ptr then, node\_ptr tail)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The function take three expressions (cond, e1, e2) and
   creates ITE(cond, e1, e2). Normalisation is performed if required.]

   Description        [normalises ITE expression, i.e.
   the function creates "ITE(cond, then, tail)"  and normalised it.

   The 'then' and 'tail' expressions are assumed to be not-boolean.

   If nested ITE are not allowed and 'then' is an ITE-expression
   then normalisation is performed, i.e. all ITE are moved up from 'then'.
   For example,
   ITE(c1, ITE(c2, t2, e2), e1)
   will become
   ITE(c1&c2, t2, ITE(c1, e2, e1)),
   and the result will be ITE list (without nested ITE). Note that in
   this case t2 cannot be ITE expression(has been already
   normalised)).]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void pred\_norm\_get\_predicates\_only(const PredicateNormaliser\_ptr self, Set\_t* preds, node\_ptr expr, hash\_ptr already\_processed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [This is implementation of PredicateNormaliser_get_predicates_only]

   Description [already_processed is a hash table of already processed
   expressions. Since every predicate has to be collected only once
   there is no need to process the same exp twice.]

   SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileBEval.c}
		
	\texttt{Expr\_ptr Compile\_expr2bexpr(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts a scalar expression into a boolean expression.]

  Description        [Takes an scalar expression intended to evaluate
  to boolean, maps through booleans down to the atomic scalar
  propositions, builds the corresponding boolean function, and returns
  the resulting boolean expression.

  The conversion of atomic scalar proposition is currently performed
  by generating the corresponding ADD, and then printing it in terms
  of binary variables.

  If one or more determinization variable must be created
  (i.e. non-determinism must be allowed) then det_layer is the
  SymbLayer instance to be filled with the newly created
  determinization variables. If non-determinism is not allowed, specify
  NULL as det_layer value. In this case you can use detexpr2bexpr as well.

  The input expression will be processed with Nil context (for
  flattened expr this does not matter).]

  SideEffects        [None]

  SeeAlso            [Compile_detexpr2bexpr, expr2bexpr_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Compile\_detexpr2bexpr(BddEnc\_ptr enc, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts a scalar expression into a boolean expression.]

  Description        [Takes an scalar expression intended to evaluate
  to boolean, maps through booleans down to the atomic scalar
  propositions, builds the corresponding boolean function, and returns
  the resulting boolean expression.

  The conversion of atomic scalar proposition is currently performed
  by generating the corresponding ADD, and then printing it in terms
  of binary variables.

  An error is returned if determinization variables are introduced in
  the booleanization process.

  The input expression will be processed with Nil context (for
  flattened expr this does not matter).]

  SideEffects        [None]

  SeeAlso            [Compile_expr2bexpr, expr2bexpr_recur,
  Compile_detexpr2bexpr_list]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Compile\_detexpr2bexpr\_list(BddEnc\_ptr enc, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts a scalar expression into a boolean expression.]

  Description        [This function is exactly like Compile_detexpr2bexpr
  except that the input expressions is expected to be a list of expressions.
  The only purpose of this function wrt Compile_detexpr2bexpr is efficiency.
  For big model list of expressions may be huge and stack overflow may happen
  in Compile_detexpr2bexpr because the expressions are processed recursively
  whereas here top-level expressions are processed in loop.

  expr has to be a RIGHT-connected list of elements (i.e. car is head
  and cdr is tail). The connecting nodes have to be of type AND or
  CONS with the semantics of AND.  The returned expression is a list
  of the same order but with the booleanized expressions and AND used
  as connector.

  NOTE: some simplifications are done, e.g. if FALSE is met among
  elements then FALSE is returned.

  NOTE: when the function see on the right a node of a type other than
  AND and CONS then right child is considered as the last element in the
  list.

  NOTE: special case: if NEXT is met at the top then its sub-expression
  is processed as a list.

  TODO: if in future is will be necessary to process lists of
  different connector kind, e.g. OR, it will be necessary to provided
  the kind as parameter. Still AND and CONS have to dealt the same way
  because in traces it is unspecified if AND or CONS is used in
  var=value lists.]

  SideEffects        [None]

  SeeAlso            [Compile_detexpr2bexpr, Compile_expr2bexpr,
  expr2bexpr_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Compile\_is\_expr\_booleanizable(const SymbTable\_ptr st, node\_ptr expr, boolean word\_unbooleanizable, hash\_ptr cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check if an expr is of a finite range type]

   Description        [Check if an expr is of a finite range type.

                       REMARK: Words are considered finite only if
                       word_unbooleanizable is set to false

                       If cache is not null whenever we encounter a formula in
                       the cache we simply return the previously computed value,
                       otherwise an internal and temporary map is used.

                       NOTE: the internal representation of cache is private so
                             the user should provide only caches generated by
                             this function!]

   SideEffects        [none]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_cleanup\_booleanizer\_cache\_about(SymbTable\_ptr st, NodeList\_ptr symbs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Cleans those hashed entries that are about a symbol that
  is being removed]

  Description        [Called by BoolEnc class when removing a layer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_shift\_left(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr context, boolean in\_next, node\_ptr a, node\_ptr b, node\_ptr def\_case, int numWidth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Creates the encoding of the left-shifting circuit for
  words]

  Description        [ numWidth is the width of b or -1 if b is not a word
  (it can be a number)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_shift\_right(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr context, boolean in\_next, node\_ptr a, node\_ptr b, node\_ptr def\_case, int numWidth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Creates the encoding of the unsigned right-shifting circuit for
  words]

  Description        []

  SideEffects        [numWidth is the width of b or -1 if b is not a word
  (it can be a number)]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_get\_shift\_def\_value(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr context, boolean in\_next, node\_ptr a, node\_ptr b, int numWidth, node\_ptr defaultBit)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Private service for shifting operations]

  Description [creates a default error case.
  numWidth is the width of b or -1 if b is not a word.
  defaultBit is a default value of a bit. Typically it is 0 and
  the highest bit of a for right signed shift.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_shift(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr expr, node\_ptr context, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [High-level function for shifting operations]

  Description        [This function is called directly by the booleanizer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_rotate(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr expr, node\_ptr context, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [High-level function for rotating words]

  Description        [This function is called directly by the booleanizer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_recur\_unary(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr expr, node\_ptr context, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function booleanize an unary expression in a standard way:
  at first process the argument. Then for words apply a corresponding unary
  word function, for all other type just create exp of the same kind with
 find_node.]

  Description []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_recur\_binary(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr expr, node\_ptr context, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [This function booleanize a binary expression in a standard way.]

  Description   [ For words: at first convert to boolean the arguments
  and then apply a corresponding word function.
    For all other types if the kind of an expression is arithmetic or
  relational converte the exp down to an ADD, and then back to a
  node_ptr to booleanize it.
    Otherwise process the arguments and create a new expression of the
  same kind with find_node.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_ite(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr expr, node\_ptr context, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an encoding for CASE node. If CASE evaluates to
  a word, a WORD encoding is created.]

  Description        [Private sesrvice called by expr2bexpr_recur]

  SideEffects        [None]

  SeeAlso            [expr2bexpr_word_ite_aux]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_word\_ite\_aux(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr expr, node\_ptr context, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

 Synopsis [Service of expr2bexpr_word_ite, that creates the word encoding]

 Description        [Creates the resulting WORD encoding as:
 <textarea>
                     WORD
                  /        \
                 /          NUMBER(size)
                /
             _____ CONS ________________
            /                           \
       _   ITE                         CONS
      |  /  |  \                      /    \
      |c1 t1.0  ITE                 ITE     ...
  bit0|        /  |  \            _ ...
  |          c2  t2.0 ITE       |
  .           ...      |        |
  .                    .    bit1|
  |_                   .
  |_
</textarea>
Encoding complexity is N*C (N=word width, C=num of cases)]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr2bexpr\_recur(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr expr, node\_ptr context, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

 Synopsis           [Converts a generic expression into a boolean expression.]

 Description        [Takes an expression intended to evaluate to boolean,
 maps through booleans down to the atomic scalar propositions,
 builds the corresponding boolean function,
 and returns the resulting boolean expression.

 The conversion of atomic scalar proposition is currently performed
 by generating the corresponding ADD, and then printing it in terms
 of binary variables.

 The introduction of determinization variables is allowed only if
 parameter "det_layer" is not NULL; Those variables will be declared
 within the given layer

 The input expression may be normal (not flattened), flattened or
 expanded. Parameter 'context' is used if the expression is not flattened.]

 SideEffects        [None]

 SeeAlso            [Compile_expr2bexpr, detexpr2bexpr]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr scalar\_atom2bexpr(BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, node\_ptr expr, node\_ptr context, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Converts an atomic expression into the corresponding
  (boolean) expression.]

  Description        [Takes an atomic expression and converts it into
  a corresponding boolean expression.

  The introduction of determinization variables is allowed only if the layer
  <tt>det_layer</tt> is not NULL]

  SideEffects        [A new boolean variable might be introduced.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean compile\_is\_booleanizable\_aux(const SymbTable\_ptr st, node\_ptr expr, node\_ptr context, boolean word\_unbooleanizable, hash\_ptr cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [true if expression is booleanizable]

   Description        [Private service of compile_is_booleanizable.
                       To represent 'true' in cache we use the constant 2 for
                       'false' we use 1 to avoid representation problems wrt Nil]

   SideEffects        [cache can be updated]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileCheck.c}
		
	\texttt{void Compile\_CheckAssigns(const SymbTable\_ptr symb\_table, node\_ptr procs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Semantic checks on assignments of the module.]

  Description        [
  The function checks that there are no multiple assignments and
  circular definitions.<br> Then the functions tries to detect
  multiple assignments between different modules.]

  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void compileCheckForInputVars(const SymbTable\_ptr symb\_table, node\_ptr trans\_expr, node\_ptr init\_expr, node\_ptr invar\_expr, node\_ptr assign\_expr, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks expressions for illegal occurrences of input vars]

  Description        [Checks the TRANS, INIT, INVAR and ASSIGN statements to
  make sure that input variables are not used where they should not be. That
  is, anywhere in a TRANS, INIT or INVAR statement and within next expressions
  in the init and next sections of an ASSIGN statement.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_check\_next(const SymbTable\_ptr st, node\_ptr expr, node\_ptr context, boolean is\_one\_next\_allowed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Checks that given expression contains either no nested
  next, or no next operator at all.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_check\_input\_next(const SymbTable\_ptr st, node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Checks that given expression contains either no input
  variables in next.]

  Description        [It outputs an error message (and rises an exception)
  iff the expression contains a next statement which itself has an
  input variable in it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compileCheckInitForInputVars(SymbTable\_ptr symb\_table, node\_ptr init)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks flattened init statement for input variables]

  Description        [If the flattened init statement contains input
  variables then this function will print out an error message.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compileCheckInvarForInputVars(SymbTable\_ptr symb\_table, node\_ptr invar)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks flattened invar statement for input variables]

  Description        [If the flattened invar statement contains input
  variables then this function will print out an error message.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compileCheckTransForInputVars(SymbTable\_ptr symb\_table, node\_ptr trans)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks flattened trans statement for input variables]

  Description        [If the flattened trans statement contains input
  variables within next() statements then this function will print out an
  error message.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compileCheckAssignForInputVars(SymbTable\_ptr symb\_table, node\_ptr assign, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks flattened assign statement for input variables]

  Description        [If the flattened assign statement contains input
  variables then this function will print out an error message. Note that
  input variables are allowed in some parts of an assign statement. They're
  not allowed anywhere in an init section and cannot be contained within a
  next statement inside a next declaration.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compileCheckNoNextInputs(SymbTable\_ptr symb\_table, node\_ptr expr, node\_ptr ctx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Checks expression for input variables in next statements]

  Description [It outputs an error message (and rises an exception)
  iff the expression contains a next statement which itself has an
  input variable in it.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void init\_check\_program(node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the data structure to perform semantic
  checks.]

  Description        [The input should be a list of processes names.
  Loops over the list of process names
  and inserts the process symbolic name in the <tt>check_constant_hash</tt>.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void check\_circ(const SymbTable\_ptr symb\_table, node\_ptr n, node\_ptr context, boolean is\_next, boolean lhs\_is\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks for circular definitions.]

  Description        [This function checks for circular definition of
  any kind. This function is able to detect circularity of the
  following kinds:
  <ul>
     <li><code>next(x) := alpha(next(x))<code></li>
     <li><code>next(x) := next(alpha(x))<code></li<
     <li>any combination of the two above.</li>
     <li><code>x := alpha(x)</code>
  </ul>
  where <code>alpha(x)</code> (<code>alpha(next(x))</code>) is a
  formula in which the variable <code>x</code> (<code>next(x)</code>)
  occurs. Notice that <code>next(alpha(x))</code> can be rewritten in
  term of <code>next(x)</code>, since the next operator distributes
  along all kind of operators.<br>

  Here we check also the case where we have next(x), and x is a symbol
  declared as DEFINE whose body contain a next(v).  These kind of
  formulas cannot be checked at parsing time, since, it would require
  to knowledge of part of the model that might be possibly parsed
  later. And removing next from the body of DEFINE is a too
  restrictive choice.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void check\_circular\_assign(const SymbTable\_ptr symb\_table, node\_ptr n, node\_ptr context, boolean is\_next, boolean is\_lhs, boolean lhs\_is\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs circular assignment checking]

  Description        [Checks for circular assignments in the model. If
  there are any, then an error is generated. NEXT operator, if any,
  must be stripped away from given expression 'n', and in that case is_next
  must be set to true. Parameter is_lhs is true at the first call (done
  with the first left-hand-side value (the assigned value)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void check\_assign(const SymbTable\_ptr symb\_table, node\_ptr n, node\_ptr context, int mode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks for multiple or circular assignments.]

  Description        [This function detects either multiple or
  circular assignments in "context" regarding to "mode".
  If mode is equal to 0 (zero) then it checks for multiple assignments
  or symbols redefinition. Otherwise it performs checks for circular
  assignments.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void check\_assign\_both(node\_ptr v, int node\_type, int lineno)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a variable, it checks if there are
  multiple assignments to it.]

  Description        [Checks if there exists in the model an
  assignments of type <tt>node_type</tt> for variable <tt>v</tt>. If
  such an assignment exists, then an error is generated.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_check\_print\_io\_atom\_stack\_assign(FILE * fd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileCmd.c}
		
	\texttt{void Compile\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the compile package.]

  Description        [Initializes the compile package. The set of commands must
  be explicitly initialized later by calling Compile_InitCmd.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_init\_cmd()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the commands provided by this package]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Shut down the compile package]

  Description        [Shut down the compile package]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandProcessModel(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs the batch steps and then returns
  control to the interactive shell.]

  CommandName        [process_model]

  CommandSynopsis    [Performs the batch steps and then returns control
  to the interactive shell.]

  CommandArguments   [\[-h\] \[-f\] \[-r\] \[-i model-file\] \[-m Method\]]

  CommandDescription [ Reads the model, compiles it into BDD and
  performs the model checking of all the specification contained in
  it. If the environment variable <tt>forward_search</tt> has been set
  before, then the set of reachable states is computed. If the
  option <tt>-r</tt> is specified, the reordering of variables is
  performed accordingly. This command simulates the batch behavior of
  NuSMV and then returns the control to the interactive shell.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-f</tt>
       <dd> Forces model construction even when COI is enabled.
    <dt> <tt>-r</tt>
       <dd> Performs a variable ordering at the end of the
       computation, and dumps the variable ordering as the command
       line option <tt>-reorder</tt> does.
    <dt> <tt>-i model-file</tt>
       <dd> Sets the environment variable <tt>input_file</tt> to file
           <tt>model-file</tt>, and reads the model from file
           <tt>model-file</tt>.
    <dt> <tt>-m Method</tt>
       <dd> Sets the environment variable <tt>partition_method</tt> to
       <tt>Method</tt> and uses it as partitioning method.
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandFlattenHierarchy(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Flattens the hierarchy of modules]

  CommandName        [flatten_hierarchy]

  CommandSynopsis    [Flattens the hierarchy of modules]

  CommandArguments   [\[-h\] \[-d\]]

  CommandDescription [
  This command is responsible of the instantiation of modules and
  processes. The instantiation is performed by substituting the actual
  parameters for the formal parameters, and then by prefixing the result via
  the instance name.
  <p>
  Command options:<p>
  <dl>
    <dt><tt>-d</tt>
     <dd>Delays the construction of vars constraints until needed
    </dl>
]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandShowVars(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Shows model's symbolic variables and their values]

  CommandName        [show_vars]

  CommandSynopsis    [Shows model's symbolic variables and their values]

  CommandArguments   [\[-h\] \[-s\] \[-f\] \[-i\] \[-v\] \[-t|-V\]
                      \[-m | -o output-file\]]

  CommandDescription [
  Prints symbolic input, frozen and state variables of the model with their
  range of values (as defined in the input file).
  <p>
  Command Options:<p>
  <dl>
    <dt> <tt>-s</tt>
       <dd> Prints state variables.
    <dt> <tt>-f</tt>
       <dd> Prints frozen variables.
    <dt> <tt>-i</tt>
       <dd> Prints input variables.
    <dt> <tt>-t</tt>
       <dd> Prints only the number of variables (among selected
            kinds), grouped by type. Incompatible with -V.
    <dt> <tt>-V</tt>
       <dd> Prints only the list of variables with their types (among
            selected kinds), and no other summary
            information. Incompatible with -t.
    <dt> <tt>-v</tt>
       <dd> Prints verbosely. With this option, all scalar variable values are
            printed
    <dt> <tt>-m</tt>
       <dd> Pipes the output to the program specified by the
           <tt>PAGER</tt> shell variable if defined, else through the
           <tt>UNIX</tt> command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command to <tt>output-file</tt>
  </dl> ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandEncodeVariables(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the BDD variables necessary to compile the
  model into BDD.]

  CommandName        [encode_variables]

  CommandSynopsis    [Builds the BDD variables necessary to compile the
  model into BDD.]

  CommandArguments   [\[-h\] \[-i order-file\]]

  CommandDescription [
  Generates the boolean BDD variables and the ADD needed to encode
  propositionally the (symbolic) variables declared in the model.<br>

  The variables are created as default in the order in which they
  appear in a depth first traversal of the hierarchy.<p>

  The input order file can be partial and can contain variables not
  declared in the model. Variables not declared in the model are
  simply discarded. Variables declared in the model which are not
  listed in the ordering input file will be created and appended at the
  end of the given ordering list, according to the default ordering.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-i order-file</tt>
       <dd> Sets the environment variable <tt>input_order_file</tt> to
       <tt>order-file</tt>, and reads the variable ordering to be used from
       file <tt>order-file</tt>. This can be combined with the
       <tt>write_order</tt> command. The variable ordering is written to a
       file, which can be inspected and reordered by the user, and then
       read back in.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandBuildModel(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compiles the flattened hierarchy into BDD]

  CommandName        [build_model]

  CommandSynopsis    [Compiles the flattened hierarchy into BDD]

  CommandArguments   [\[-h\] \[-f\] \[-m Method\]]

  CommandDescription [
  Compiles the flattened hierarchy into BDD (initial states, invariants,
  and transition relation) using the method specified in the environment
  variable <tt>partition_method</tt> for building the transition relation.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-m Method</tt>
       <dd> Sets the environment variable <tt>partition_method</tt> to
           the value <tt>Method</tt>, and then builds the transition
           relation. Available methods are <code>Monolithic</code>,
           <code>Threshold</code> and <code>Iwls95CP</code>.
    <dt> <tt>-f</tt>
       <dd> Forces model construction. By default, only one partition
            method is allowed. This option allows to overcome this
            default, and to build the transition relation with different
            partitioning methods.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandBuildFlatModel(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compiles the flattened hierarchy into SEXP]

  CommandName        [build_flat_model]

  CommandSynopsis    [Compiles the flattened hierarchy into SEXP]

  CommandArguments   [\[-h\]]

  CommandDescription [
  Compiles the flattened hierarchy into SEXP (initial states, invariants,
  and transition relation).<p>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandBuildBooleanModel(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compiles the flattened hierarchy into boolean SEXP]

  CommandName        [build_boolean_model]

  CommandSynopsis    [Compiles the flattened hierarchy into boolean SEXP]

  CommandArguments   [\[-h\] \[-f\]]

  CommandDescription [
  Compiles the flattened hierarchy into boolean SEXP
  (initial states, invariants, and transition relation).<p>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandWriteOrder(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes variable order to file.]

  CommandName        [write_order]

  CommandSynopsis    [Writes variable order to file.]

  CommandArguments   [\[-h\] \[-b\] \[(-o | -f) order-file\]]

  CommandDescription [Writes the current order of BDD variables in the
  file specified via the -o option. If no option is specified the environment
  variable <tt>output_order_file</tt> will be considered. If the variable
  <tt>output_order_file</tt> is unset (or set to an empty value) then standard
  output will be used. The option <tt>-b</tt> forces the dumped
  variable ordering to contain only boolean variables.
  All the scalar variables will be substituted by those variables bits
  that encode them.  The variables bits will occur within the dumped
  variable ordering depending on the position they have within the
  system when the command is executed.
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-b</tt>
       <dd> Dumps bits of scalar variables instead of the single
       scalar variables. When specified, this option temporary
       overloads the current value of the system variable
       <tt>write_order_dumps_bits</tt>.

    <dt> <tt>-o order-file</tt>
       <dd> Sets the environment variable <tt>output_order_file</tt>
       to <tt>order-file</tt> and then dumps the ordering list into that file.
    <dt> <tt>-f order-file</tt>
       <dd> Alias for -o option. Supplied for backward compatibility.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCPPrintClusterInfo(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints out information about the clustering.
  ** DEPRECATED in 2.4 **]

  CommandName        [print_clusterinfo]

  CommandSynopsis [Prints out  information about the
  clustering. This command is *deprecated* in 2.4]

  CommandArguments   [\[-h\] \| \[-m\] \| \[-o output-file\]]

  CommandDescription [Deprecated in 2.4: use print_fsm_stats instead.

  This command prints out information
  regarding each cluster. In particular for each cluster it prints
  out the cluster number, the size of the cluster (in BDD nodes), the
  variables occurring in it, the size of the cube that has to be
  quantified out relative to the cluster and the variables to be
  quantified out.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-m</tt>
       <dd> Pipes the output generated by the command through the
            program specified by the <tt>PAGER</tt> shell variable if
            defined, or through the UNIX utility "more".
    <dt> <tt>-o output-file</tt>
       <dd> Redirects the generated output to the file
            <tt>output-file</tt>.
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandPrintFsmStats(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints out information about the fsm and clustering.]

  CommandName        [print_fsm_stats]

  CommandSynopsis    [Prints out information about the fsm and clustering.]

  CommandArguments   [\[-h\] \| \[-m\] \| \[-p\] \| \[-o output-file\]]

  CommandDescription [This command prints out information
  regarding the fsm and each cluster. In particular for each cluster
  it prints out the cluster number, the size of the cluster (in BDD
  nodes), the variables occurring in it, the size of the cube that has
  to be quantified out relative to the cluster and the variables to be
  quantified out.<p>

   Also the command can print all the normalized predicates the FMS
   consists of. A normalized predicate is a boolean expression which
   does not have other boolean sub-expressions. For example,
   expression (b<0 ? a/b : 0) = c is normalized into (b<0
   ? a/b=c : 0=c) which has 3 normalized predicates inside:
   b<0, a/b=c, 0=c.

  Command options:<p>
  <dl>
    <dt> <tt>-m</tt>
       <dd> Pipes the output generated by the command through the
            program specified by the <tt>PAGER</tt> shell variable if
            defined, or through the UNIX utility "more".
    <dt> <tt>-p</tt>
       <dd> Prints out the normalized predicates the FSM consists of.
    <dt> <tt>-o output-file</tt>
       <dd> Redirects the generated output to the file
            <tt>output-file</tt>.
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandIwls95PrintOption(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the Iwls95 Options.]

  CommandName        [print_iwls95options]

  CommandSynopsis    [Prints the Iwls95 Options.]

  CommandArguments   [\[-h\]]

  CommandDescription [This command prints out the configuration
  parameters of the IWLS95 clustering algorithm, i.e.
  <tt>image_verbosity</tt>, <tt>image_cluster_size</tt> and
  <tt>image_W{1,2,3,4}</tt>.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandGo(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the go command]

  CommandName        [go]

  CommandSynopsis    [Initializes the system for the verification.]

  CommandArguments   [\[-h\]\[-f\]]

  CommandDescription [This command initializes the system for
  verification. It is equivalent to the command sequence
  <tt>read_model</tt>, <tt>flatten_hierarchy</tt>,
  <tt>build_flat_model</tt>, <tt>encode_variables</tt>,
  <tt>build_model</tt>.<p>
  If some commands have already been
  executed, then only the remaining ones will be invoked.<p>
  Command options:<p>
  <dl><dt> -f
  <dd> Forces the model contruction.<p>
  <dt> -h
  <dd> Prints the command usage.<p>
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandGoBmc(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the go_bmc command]

  CommandName        [go_bmc]

  CommandSynopsis    [Initializes the system for the BMC verification.]

  CommandArguments   [\[-h\] | \[-f\]]

  CommandDescription [This command initializes the system for
  verification. It is equivalent to the command sequence
  <tt>read_model</tt>, <tt>flatten_hierarchy</tt>,
  <tt>encode_variables</tt>, <tt>build_boolean_model</tt>, <tt>bmc_setup</tt>.
  If some commands have already been
  executed, then only the remaining ones will be invoked.<p>
  Command options:<p>
  <dl>
  <dt> -f
  <dd> Forces the model construction.<p>
  <dt> -h
  <dd> Prints the command usage.<p>
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandGetInternalStatus(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the get_internal_status command]

  CommandName        [get_internal_status]

  CommandSynopsis    [Returns the internal status of the system.]

  CommandArguments   [\[-h\]]

  CommandDescription [Prints out the internal status of the system. i.e.
  <ul>
  <li> -1 : read_model has not yet been executed or an error occurred
            during its execution. </li>
  <li>  0 : flatten_hierarchy has not yet been executed or an error
            occurred during its execution. </li>
  <li>  1 : encode_variables has not yet been executed or an error
            occurred during its execution. </li>
  <li>  2 : build_model has not yet been executed or an error occurred
            during its execution. </li>
  </ul>
  Command options:<p>
  <dl><dt> -h
  <dd> Prints the command usage.<p>
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandWriteModelFlat(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes the currently loaded SMV model in the
  specified file, after having flattened it]

  CommandName        [write_flat_model]

  CommandSynopsis    [Writes a flat model of a given SMV file]

  CommandArguments   [\[-h\] \[-o filename\] \[-A\] \[-m\]]

  CommandDescription [Processes are eliminated
  and a corresponding equivalent model is printed out.
  If no file is specified, the file specified with the environment variable
  <tt>output_flatten_model_file</tt> is used if any, otherwise standard output
  is used as output.
  <p>
  Command options:<p>
  <dl>
     <dt><tt>-o filename</tt>
       <dd> Attempts to write the flat SMV model in <tt>filename</tt>.
     <dt><tt>-A</tt>
       <dd> Write the model using variables and defines rewriting to
       make it anonimized.
     <dt><tt>-m</tt>
       <dd> Disable printing of key map when writing anonimized model
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandWriteModelFlatUdg(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes the currently loaded SMV model in the
                      specified uDraw file, after having flattened it]

  CommandName        [write_flat_model_udg]

  CommandSynopsis    [Writes a flat model of a given SMV file in uDraw format]

  CommandArguments   [\[-h\] \[-o filename\]]

  CommandDescription [Processes are eliminated
  and a corresponding equivalent model is printed out.
  If no file is specified, the file specified with the environment variable
  <tt>output_flatten_model_file</tt> is used if any, otherwise standard output
  is used as output.
  <p>
  Command options:<p>
  <dl>
     <dt><tt>-o filename</tt>
       <dd> Attempts to write the flat SMV model in <tt>filename</tt>.
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandWriteModelFlatBool(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Writes a flat and boolean model of a given SMV file]

  CommandName        [write_boolean_model]

  CommandSynopsis    [Writes a flattened and booleanized model of a
  given SMV file]

  CommandArguments   [\[-h\] \[-o filename\]]

  CommandDescription [Writes the currently loaded SMV model in the
  specified file, after having flattened and booleanized it. Processes
  are eliminated and a corresponding equivalent model is printed
  out.

  If no file is specified, the file specified via the environment
  variable <tt>output_boolean_model_file</tt> is used if any,
  otherwise standard output is used.
  <p>
  Command options:<p>
  <dl>
     <dt><tt>-o filename</tt>
       <dd> Attempts to write the flat and boolean SMV model in
       <tt>filename</tt>.
  </dl>

  ** New in 2.4.0 and later **
  Scalar variables are dumped as DEFINEs whose body is their boolean
  encoding.

  This allows the user to still express and see parts of the generated
  boolean model in terms of the original model's scalar variables
  names and values, and still keeping the generated model purely boolean.

  Also, symbolic constants are dumped within a CONSTANTS statement to
  declare the values of the original scalar variables' for future
  reading of the generated file.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandWriteCoiModel(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Writes a flat model of a given SMV file, restricted to the
            COI of the model properties]

  CommandName        [write_coi_model]

  CommandSynopsis    [Writes a flat model of SMV file, restricted to the COI
  of the model properties]

  CommandArguments   [\[-h\] \[-o filename\] \[-n <prop> | -p <expr>
                      | -P <name>\] | \[-c\] | \[-l\] | \[-i\] | \[-s\] |
                      \[-q\] | \[-p expr\] | \[-C\] | \[-g\]]

  CommandDescription [Writes the currently loaded SMV model in the
  specified file, after having flattened it. If a property is
  specified, the dumped model is the result of applying the COI over
  that property. otherwise, a restricted SMV model is dumped for each
  property in the property database.

  Processes are eliminated and a corresponding equivalent model is
  printed out.

  If no file is specified, stderr is used for output
  <p>
  Command options:<p>
  <dl>
     <dt><tt>-o filename</tt>
       <dd> Attempts to write the flat and boolean SMV model in
       <tt>filename</tt>.
    <dt> <tt>-c</tt>
       <dd> Dumps COI model for all CTL properties
    <dt> <tt>-l</tt>
       <dd> Dumps COI model for all LTL properties
    <dt> <tt>-i</tt>
       <dd> Dumps COI model for all INVAR properties
    <dt> <tt>-s</tt>
       <dd> Dumps COI model for all PSL properties
    <dt> <tt>-q</tt>
       <dd> Dumps COI model for all COMPUTE properties
     <dt><tt>-p expr</tt>
       <dd> Applies COI for the given expression "expr"
     <dt><tt>-n idx</tt>
       <dd> Applies COI for property stored at index "idx"
     <dt><tt>-P name</tt>
       <dd> Applies COI for property named "name" idx
     <dt><tt>-C</tt>
       <dd> Only prints the list of variables that are in
           the COI of properties
     <dt><tt>-g</tt>
       <dd> Dumps the COI model that represents the union of all COI properties
  </dl>

  ]
  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageWriteCoiModel()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the usage for the write_coi_command]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandShowDependencies (int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Show expression dependencies]

  CommandName        [show_dependencies]

  CommandSynopsis    [Shows the expression dependencies]

  CommandArguments   [\[-h\] \[-k bound\] -e expr]

  CommandDescription [
  Shows the dependencies of the given expression
  <p>
  Command options:<p>
  <dl>
     <dt><tt>-k bound</tt>
       <dd> Stop dependencies computation at step "bound"
     <dt><tt>-e expr</tt>
       <dd> The expression on which the dependencies are computed on
  </dl>
  ]
  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int compile\_encode\_variables()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [ Encodes variables in the model (BDD only). ]

  Description [ ]

  SideEffects [ ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int compile\_flatten\_smv(boolean calc\_vars\_constrains)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [ Traverses the parse tree coming from the smv parser and
                flattens the smv file. ]

  Description [ ]

  SideEffects [ ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_create\_flat\_model()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [creates the  master scalar fsm if needed]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_create\_boolean\_model()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis  [Creates the  master boolean fsm if needed.
  A new layer called DETERM_LAYER_NAME
  will be added if the bool fsm is created.]

  Description [The newly created layer will be committed to both the
  boolean and bdd encodings. Warning: it is assumed here that the flat model
  has been already created]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void compile\_build\_model(boolean force\_build)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [ Builds the BDD fsm. ]

  Description [ ]

  SideEffects [ ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr compile\_cmd\_remove\_assignments(Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes expression in the form "a := b" from the given
                      expression]

  Description        [Removes expression in the form "a := b" from the given
                      expression. The new expression is returned]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_cmd\_write\_coi\_prop(Set\_t cone, Set\_t props, FILE* output\_file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the COI for the given property]

  Description        [Dumps the COI for the given property]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_cmd\_write\_coi\_prop\_fsm(FlatHierarchy\_ptr fh, Set\_t cone, Set\_t props, FILE* output\_file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the model applied to COI for the given property]

  Description        [Dumps the model applied to COI for the given property]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int get\_bits(const SymbTable\_ptr st, const NodeList\_ptr lst)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the total bit number of symbols in the given
                      list]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_cmd\_write\_global\_coi\_fsm(FlatHierarchy\_ptr hierarchy, Prop\_Type prop\_type, FILE* output\_file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps on output_file the global coi FSM]

  Description        [Dumps on output_file the FSM built using the union of all
                      properties cone of influence. Properties can be filtered
                      by type using prop_type: if prop_type == Prop_NoType,
                      all properties are used]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_cmd\_write\_properties\_coi(FlatHierarchy\_ptr hierarchy, Prop\_Type prop\_type, boolean only\_dump\_coi, const char* file\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps properties shared COI FSMs or sets]

  Description        [Dumps properties shared COI informations.
                      If only_dump_coi is true, only the set of
                      variables in the cone of each property is
                      dumped. Otherwise, an FSM is created and
                      dumped. Properties with the same COI will appear
                      in the same FSM. Properties can be filtered by
                      type using prop_type: if prop_type ==
                      Prop_NoType, all properties are used]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_cmd\_print\_type(FILE * file, node\_ptr ntype, int threshold)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the given type to the given stream]

  Description        [Prints the given type to the given stream.

                      The type must be created with the
                      compile_cmd_get_var_type function. If the type
                      is scalar, then values are printed until
                      "threshold" number of characters are reached. If
                      some values are missing because of the
                      output]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_cmd\_get\_var\_type(SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an internal representaion of the symbol type]

  Description        [Creates an internal representaion of the symbol type.
                      The representation of the type returned is
                      intended to be used only with the
                      compile_cmd_print_type procedure. If 2 types are
                      the same, the same node is returned]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileCone.c}
		
	\texttt{Set\_t Formula\_GetDependencies(const SymbTable\_ptr symb\_table, node\_ptr formula, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes dependencies of a given SMV expression]

  Description        [The set of dependencies of a given formula are
  computed. A traversal of the formula is performed. Each time a
  variable is encountered, it is added to the so far computed
  set. When a formula depends on a next variable, then the
  corresponding current variable is added to the set. When an atom is
  found a call to <tt>formulaGetDefinitionDependencies</tt> is
  performed to compute the dependencies. Returned set must be disposed
  by the caller]

  SideEffects        []

  SeeAlso            [formulaGetDefinitionDependencies]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Formula\_GetDependenciesByType(const SymbTable\_ptr symb\_table, node\_ptr formula, node\_ptr context, SymbFilterType filter, boolean preserve\_time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the dependencies of an SMV expression by type]

  Description        [The set of dependencies of a given formula are
  computed, as in Formula_GetDependencies, but the variable type filters the
  dependency collection.

  If flag preserve_time is true, then entries in the returned set
  will preserve the time they occur within the formula. For
  example, formula 'a & next(b) = 2 & attime(c, 2) < 4' returns
  {a,b,c} if preserve_time is false, and {a, next(b), attime(c, 2)}
  if preserve_time is true.

  Returned set must be disposed by the caller]

  SideEffects        []

  SeeAlso            [formulaGetDependenciesByTypeAux
  formulaGetDefinitionDependencies]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Formulae\_GetDependencies(const SymbTable\_ptr symb\_table, node\_ptr formula, node\_ptr justice, node\_ptr compassion)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compute the dependencies of two set of formulae]

  Description [Given a formula and a list of fairness constraints, the
  set of variables occurring in them is computed. Returned Set must be
  disposed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Formula\_GetConstants(const SymbTable\_ptr symb\_table, node\_ptr formula, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Calculates the set of constants occurring into
  the given formula]

  Description [Given a formula the set of constants occurring in
  them is computed and returned. Returned set must be disposed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t ComputeCOIFixpoint(const SymbTable\_ptr symb\_table, const FlatHierarchy\_ptr hierarchy, const Expr\_ptr expression, const int steps, boolean* reached\_fixpoint)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the COI of a given expression]

  Description        [Computes the COI of a given expression,
                      up to step "steps" (or fixpoint if steps = -1).
                      If not NULL, if the fixpoint has been reached
                      (ie: there are no more dependencies), reached_fixpoint
                      is set to true.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t ComputeCOI(const SymbTable\_ptr symb\_table, Set\_t base)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the COI of a given set of variables, defined
  within the given symb_table]

  Description        [Computes the COI of a given set of variables, defined
  within the given symb_table. Returned Set must be disposed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t formulaGetDefinitionDependencies(const SymbTable\_ptr symb\_table, node\_ptr formula, SymbFilterType filter, boolean preserve\_time, int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compute the dependencies of an atom]

  Description [This function computes the dependencies of an atom. If
  the atom corresponds to a variable then the singleton with the
  variable is returned. If the atom corresponds to a "running"
  condition the singleton with variable PROCESS_SELECTOR_VAR_NAME is
  returned. Otherwise if the atom corresponds to a defined symbol the
  dependency set corresponding to the body of the definition is
  computed and returned. filter specifies what variables we are
  interested to, as in Formula_GetDependenciesByType, and
  is_inside_next is supposed to be true if the atom is inside a Next,
  false otherwise. Returned set must be disposed by the caller]

  SideEffects        [The <tt>define_dep_hash</tt> is modified in
  order to memoize previously computed dependencies of defined symbols.]

  SeeAlso            [Formula_GetDependencies]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t formulaGetDependenciesRecur(const SymbTable\_ptr symb\_table, node\_ptr formula, node\_ptr context, SymbFilterType filter, boolean preserve\_time, int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Recursive call to Formula_GetDependenciesByType]

  Description        [Recursive call to Formula_GetDependenciesByType.
  Returned set must be released by the caller.]

  SideEffects        []

  SeeAlso            [formulaGetDefinitionDependencies
Formula_GetDependenciesByType]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void coiInit(const SymbTable\_ptr symb\_table, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pre-compute the COI of the variables]

  Description        [Computes the COI of all the variables occurring within
  the symbol table]

  SideEffects        []

  SeeAlso            [ComputeCOI]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t computeCoiVar(SymbTable\_ptr st, FlatHierarchy\_ptr fh, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the complete cone for a given variable.]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t \_coi\_get\_var\_coi0(SymbTable\_ptr st, FlatHierarchy\_ptr hierarchy, node\_ptr var, boolean * nonassign, boolean use\_cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a variable it returns the cone at depth 0.]

  Description        [Given a variable it returns the cone at depth
  0. If use_cache is true, then the result is memoized on the
  cache. When use_cache is true, it is assumed the hierarchy to be the
  mainFlatHierarchy. An assertion enforces this condition.]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileFlatten.c}
		
	\texttt{FlatHierarchy\_ptr Compile\_FlattenHierarchy( const SymbTable\_ptr symb\_table, SymbLayer\_ptr layer, /* the symbolic layer to flat */ node\_ptr module\_name, /* the <code>ATOM</code> representing the name of the module being instantiated (at the top of the hierarchy. */ node\_ptr inst\_name, /* the name of the module instance at the top of the hierarchy. */ node\_ptr actual, /* the actual module arguments */ boolean create\_process\_variables, /* enables creation of process variables */ boolean calc\_vars\_constr, /* triggers calc of vars constr, or delays it */ HrcNode\_ptr hrc\_result) /* hrc node to be populated*/}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Traverse the module hierarchy, collect all required
   the informations and flatten the hierarchy.]

   Description        [Traverses the module hierarchy and extracts the
   information needed to compile the automaton. The hierarchy of modules
   is flattened, the variables are added to the symbol table, all the
   necessary parts of the model are collected (i.e. the formulae to be
   verified, the initial expressions, etc). Most of the collected
   expressions are flattened.


   The returned value is a structure containing all the collected
   parts. See FlatHierarchy_create function for more info about, and
   constrains on content of the class FlatHierarchy.

   It is the invoker's responsibility to destroy the returned value.

   Parameter `create_process_variables` enables the creation of
   process variable (i.e. declaration of 'running's ). So, this
   parameter can be set up only for users 'main' modules. For auxiliary
   modules created during execution (for example, during LTL tablaue
   generation) this parameter should be set to false (as is done in ltl.c).

   Parameter calc_vars_constr controls the time association between
   constraints and variables is calculated. If true, the association is
   calculated before existing the function, otherwise it is possibly
   calculated later when needed, i.e. when
   FlatHierarchy_lookup_constrains is called. Postponing this calculation
   can be effective when vars constraints are not used in later phases.
   Any value of calc_vars_constr is safe, but having this parameter set
   to false possibly postpones calculations from the model construction
   phase to the model checking phase, when LTL MC is carried out, or when
   COI is involved.

   Parameter hrc_result contains the hrc node to be constructed from the
   model. If hrc_result is NULL then the structure is not populated.]

   SideEffects        [None]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_ConstructHierarchy( SymbTable\_ptr st, /* the symbol table the layer belongs to */ SymbLayer\_ptr layer, /* the layer that must be filled in by the flattening */ node\_ptr module\_name, /* the <code>ATOM</code> representing the name of the module being instantiated */ node\_ptr instance\_name, /* the name of the module instance to be instantiated */ node\_ptr actual, /* the actual module arguments */ FlatHierarchy\_ptr result, HrcNode\_ptr hrc\_result, hash\_ptr instances)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Traverses the module hierarchy and extracts the
   information needed to compile the automaton.]

   Description        [This function is a subfunction of
                       Compile_FlattenHierarchy.

   This function traverses the module hierarchy and extracts the
   information needed to compile the automaton. The hierarchy of modules
   is flattened, the variables are added to the symbol table, all the
   necessary parts of the model are collected (i.e. the formulae to be
   verified, the initial expressions, etc).

   The returned value is a structure constraining all the collected parts
   which are:
   the list of TRANS, INIT, INVAR, ASSIGN, SPEC, COMPUTE, LTLSPEC,
   PSLSPEC, INVARSPEC, JUSTICE, COMPASSION,
   a full list of variables declared in the hierarchy,
   a hash table associating variables to their assignments and constrains.
   See FlatHierarchy class for more info.
   ]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_ProcessHierarchy(SymbTable\_ptr symb\_table, SymbLayer\_ptr layer, FlatHierarchy\_ptr hierarchy, node\_ptr name, boolean create\_process\_variables, boolean calc\_vars\_constr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [This function processes a hierarchy after
   collecting all its subparts.]

   Description        [This processing means:
   1. process_selector variable and running defines are declared (only if
   create_process_variables is on)
   2. All the required lists of expressions are reversed.
   All the constrains (not specifications) are flattened.
   3. An association between vars and constrains are created (for ASSIGN,
   INIT, INVAR, TRANS).
   4. Type checking of the variable and define declarations and of all the
   expressions.
   5. Also a correct use of input variables and lack of circular dependences
   are checked.

   The parameters:
   layer is a layer with module variables.
   hierachy is a hierarchy to be process.
   name is a name of the module instance, i.e. a context of all expressions.
   create_process_variables enables creation of process variables.
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Compile\_FlattenSexp(const SymbTable\_ptr symb\_table, node\_ptr sexp, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Builds the flattened version of an expression.]

   Description        [Builds the flattened version of an
   expression. It does not expand defined symbols with the
   corresponding body.]

   SideEffects        []

   SeeAlso            [Flatten_GetDefinition, Compile_FlattenSexpExpandDefine]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Compile\_FlattenSexpExpandDefine(const SymbTable\_ptr symb\_table, node\_ptr sexp, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Flattens an expression and expands defined symbols.]

   Description        [Flattens an expression and expands defined symbols.]

   SideEffects        []

   SeeAlso            [Flatten_GetDefinition, Compile_FlattenSexp]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Flatten\_GetDefinition(const SymbTable\_ptr symb\_table, node\_ptr atom)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Gets the flattened version of an atom.]

   Description        [Gets the flattened version of an atom. If the
   atom is a define then it is expanded. If the definition mode
   is set to "expand", then the expanded flattened version is returned,
   otherwise, the atom is returned.]

   SideEffects        [The <tt>flatten_def_hash</tt> is modified in
   order to memoize previously computed definition expansion.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr CompileFlatten\_concat\_contexts(node\_ptr ctx1, node\_ptr ctx2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Concatenates contexts ctx1 and ctx2]

   Description        [Since contexts are organized bottom-up
   ("a.b.c" becomes

   DOT
   /  \
   DOT   c
   / \
   a   b
   )

   ctx2 is appended to ctx1 by concatenating ctx1 to ctx2. For example
   if ctx1="c.d.e" and ctx2="a.b.c", node 'a' is searched in ctx2, and
   then substituted by

   / ...
   DOT
   /   \
   ->>  DOT   b
   /  \
   (ctx1)  a

   Important: nodes in ctx2 are traversed and possibly recreated with find_node
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Flatten\_remove\_symbol\_info(node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Resets the hashed information about the given symbol]

   Description [This method is used when removing symbols (for example,
   when removing a layer) as some information about that symbol may be
   chached internally to this module. For example this is the case of
   defines, whose flatten body are privately cached within this module.

   If the symbol is not cached or have no associated information, no
   action is taken.  ]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void error\_bit\_selection\_assignment\_not\_supported(node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Error message for unsupported feature]

   Description        []

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compileFlattenProcess(const SymbTable\_ptr symb\_table, node\_ptr proc\_assign\_list, FlatHierarchy\_ptr flattenHierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Flatten a hierarchy of SMV processes.]

   Description         [This functions takes in input the list of process names
   and their assignments resulting from the instantiation step and
   fills in the hash table (parameter assign_hash) with the
   associations the following form:
   <ul>
   <li><tt>init(var) -> (init_assign)</tt><br>
   where <tt>init_assign</tt> is the right side of the initialization
   assignement of the variable <tt>var</tt>.
   <li><tt>next(var) -> (case P1.running : next_assign_1;
   case P2.running : next_assign_2;
   ...
   var)</tt><br>
   where  <tt>next_assign_i</tt> is the right side of the next
   assignement for the variable <tt>var</tt> in process <tt>i</tt>.
   When other processes not affecting the variable are running,
   the variable stutter.
   If there are no processes the data structure will degenerate
   into <tt>next(var) -> next_assign</tt>.
   <li><tt>var -> (normal_assign)</tt><br>
   where  <tt>normal_assign</tt> is the right side of the
   normal (invariant) assignement for the variable
   <tt>var</tt>.  </ul>

   The parameter proc_assignment_list is a list of pairs
   (process_name, a list of assignment in the process).
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr CompileFlatten\_expand\_range(int a, int b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns a range going from a to b]

   Description        [Returns a range going from a to b. An empty range (Nil)
   is returned whether given 'a' is greater than 'b']

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr CompileFlatten\_normalise\_value\_list(node\_ptr old\_values)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Takes a list of values and returns the same
   list being normalised]

   Description         [Takes a list of values and returns the same
   list being normalised]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr CompileFlatten\_resolve\_number(SymbTable\_ptr symb\_table, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Resolves the given symbol to be a number]

   Description        [If given symbol is a number, the node is simply
   returned.  If it is a define, the body is
   returned if it is a number. If it is an actuial
   parameter, it is evaluated. Otherwise NULL is
   returned. Notice that returned nodes can be
   NUMBER, NUMBER_SIGNED_WORD or NUMBER_UNSIGNED_WORD.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr CompileFlatten\_resolve\_define\_chains(const SymbTable\_ptr symb\_table, node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Takes an expression, and if it is a define or parameter
   resolves it to the actual expression.]

   Description [Sometimes a define may be equal to another
   define. This function will remove such chain of defines/parameters
   and return the actual expression or a fully resolved variable or
   constant identifier.
   This operation may be considered more like an optimization
   to avoid define chains, eg, during FSM output.

   NEXT is processed not as an expression but as a part of an identifier, i.e.
   its operand will be resolved as well.

   Note that array defines are not resolved to its definition.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CompileFlatten\_init\_flattener()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Inits the flattener module]

   Description        [Inits all the internal structures, in order to correctly
   bootstrap the flattener ]

   SideEffects [This module will be initialized, all previously
   iniitalized data will be lost]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CompileFlatten\_quit\_flattener()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Quits the flattener module]

   Description        [Resets all internal structures, in order to correctly
   shut down the flattener. Calls clear_* local functions, and resets all
   private variables. ]

   SideEffects [This module will be deinitialized, all previously
   iniitalized data will be lost]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CompileFlatten\_hash\_module(node\_ptr parsed\_module)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Add the tableau module to the list of known modules]

   Description [Add the tableau module (coming from parser) to the
   list of known modules. After this function has been invoked, the
   module will be recognized by the flattener]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbType\_ptr Compile\_InstantiateType(SymbTable\_ptr st, SymbLayer\_ptr layer, node\_ptr name, node\_ptr type, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis   [convert a type from node_ptr-form constructed by parser
   into not-memory-shared SymbType_ptr.]

   Description [All normal simple and complex types can be processed.

   Note that PROCESS and MOD_TYPE are not types and cannot be processed here.
   Parameter:
   st -- is symbol table where constants met in type can be evaluated.
   layer -- is layer where constants will be declared (for enum types).
   type -- is the type to be converted.
   name -- is the name of variable a given type is processed for.
       It is used only in error messaged and also additional checks
       are done wrt special var _process_selector_.

   If type is constructed incorrectly then error is raise. I.e. NULL
   is never returned.

   NOTE: An invoker has to free the returned type.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Compile\_DeclareVariable(SymbTable\_ptr st, SymbLayer\_ptr layer, node\_ptr name, SymbType\_ptr type, node\_ptr context, Instantiation\_Variables\_Mode\_Type mode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Instantiates the given variable.]

   Description [It takes as input a variable name, its type and a
   context, and depending on the type of the variable some operation
   are performed in order to instantiate it in the given context:

   Depending on the kind of variable instantiation mode the variables
   are appended to <tt>input_variables</tt>, <tt>frozen_variables</tt> or
   <tt>state_variables</tt>, respectively.

   Note that if type is ARRAY then the "name" is declared
   with SymbLayer_declare_variable_array and then subvariables are
   created.

   Returns true iff a variable (input,state or frozen) or array was
   created.

   PRECONDITION: type has to be not memory-shared, and its ownership
   is passed to this function.
   ]

   SideEffects        []

   SeeAlso            [compile_instantiate_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_add\_vars\_to\_hierarhcy(node\_ptr name, SymbType\_ptr type, FlatHierarchy\_ptr fh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis   [Given a fully resolved array name and its type the function
   adds all the variables in the array to the hierarchy]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_instantiate\_var(SymbTable\_ptr st, SymbLayer\_ptr layer, node\_ptr name, node\_ptr type, node\_ptr context, node\_ptr *assign, FlatHierarchy\_ptr result, HrcNode\_ptr hrc\_result, hash\_ptr instances)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Instantiates the given variable.]

   Description        [It takes as input a variable and a context, and
   depending on the type of the variable some operation are performed in order
   to instantiate it in the given context:
   <br><br>
   <ul>
   <li><b>BOOLEAN</b><br>
   if the variable is of type boolean, then we add an entry in
   <code>symbol_hash</code> saying that the variable values are <code>{0,1}
   </code>.</li>
   <li><b>RANGE</b><br>
   if the variable is a range of the form <code>M..N</code>, then
   we add an entry in the <code>symbol_hash</code> saying that the
   variable values are <code>{M, M+1, ..., N-1, N}</code>. If
   <code>M</code> is less or equal to <code>N</code>, than an error occurs.
   </li> <li><b>ENUMERATION</b><br>
   if the variable is a scalar variable whose possible values are
   <code>{a1, a2, ..., aN}</code>, then we add an entry in the
   <code>symbol_hash</code> saying that the variable values are
   <code>{a1, ..., aN}</code>. </li>
   <li><b>ARRAY</b><br>
   for each element of the array it is created the corresponding
   symbol. Suppose you have the following definition "<code>VAR
   x : array 1..4 of boolean;</code>". We call this function
   for 4 times, asking at each call <code>i</code> (<code>i</code> from 1
   to 4) to declare the boolean variable <code>x\[i\]</code>.</li>
   <li><b>MODULE</b><br>
   If the variable is an instantiation of a module, than their
   arguments (if any) are contextualized, and passed as actual
   parameter to <code>instantiate_by_name<code> with the name of the
   instantiated module as root name (to extract its definition)
   and as variable name as the name of the module (to perform
   flattening).</li>
   <li><b>PROCESS</b><br>
   If the variable is of type process, than we extract the
   module name and args, we perform the contextualization of the
   process arguments and we perform a call to
   <tt>Compile_ConstructHierarchy</tt> using the variable name as process
   name (to perform flattening), the module name as root name (to
   extract its definition) and the computed actual parameters.</li>
   </ul><br>

   Depending on the kind of variable instantiation mode the variables of
   type boolean, scalar, and array are appended to <tt>input_variables</tt>,
   <tt>frozen_variables</tt> or <tt>state_variables</tt>, respectively.
   ]

   SideEffects        []

   SeeAlso            [compile_instantiate_vars]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_instantiate\_vars(SymbTable\_ptr st, SymbLayer\_ptr layer, node\_ptr var\_list, node\_ptr mod\_name, node\_ptr *assign, FlatHierarchy\_ptr result, HrcNode\_ptr hrc\_result, hash\_ptr instances)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Recursively applies <tt>compile_instantiate_var</tt>.]

   Description        [Recursively applies <tt>compile_instantiate_var</tt> to
   a given list of variables declaration, and performs some check for
   multiple variable definitions.]

   SideEffects        []

   SeeAlso            [compile_instantiate_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void resolve\_range(SymbTable\_ptr st, node\_ptr range, node\_ptr context, int* low, int* high)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [This function takes a TWODOTS node, and tries to resolve
   the bounds to integer numbers which are returned.]

   Description        [If it is not possible to resolve the bounds to numbers,
   an error is issued.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr put\_in\_context(node\_ptr v)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Put a variable in the current "context"]

   Description        [Put a variable in the current "context", which
   is stored in <code>param_context</code>.]

   SideEffects        [None]

   SeeAlso            [param_context]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void make\_params(SymbLayer\_ptr layer, node\_ptr basename, node\_ptr actual\_list, node\_ptr formal\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Builds the parameters of a module from the list of formal
   parameters of the module itself.]

   Description        [Builds the parameters of a module from the list
   of formal parameters of the module itself and a <tt>basename</tt>.<br>
   There must be a one to one correspondence between the elements of
   <tt>actual_list</tt> and <tt>formal_list</tt> parameters. If the
   number of elements of the lists are different then, an error occurs.]

   SideEffects        [In the symbol table the new parameter is
   associated to the old one.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void make\_params\_hrc(node\_ptr basename, node\_ptr actual\_list, node\_ptr formal\_list, HrcNode\_ptr hrc\_result)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Builds the parameters of a module from the list of formal
and actual parameters of the module itself.]

Description        [Builds the parameters of a module from the list
of formal parameters of the module itself.<br>There must be a one to
one correspondence between the elements of <tt>actual_list</tt> and
<tt>formal_list</tt> parameters. If the number of elements of the
lists are different then, an error occurs. The list
<tt>actual_list</tt> must be a list of non-flattened actual
parameters. For hrc structure it is not necessary to store the
flattening information that is implicit in the hierarchy.]

SideEffects        [In <tt>hrc_result</tt> the lists of formal and
actual parameter used to instatiate a module is changed.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_instantiate(SymbTable\_ptr st, SymbLayer\_ptr layer, node\_ptr mod\_def, node\_ptr mod\_name, node\_ptr actual, node\_ptr *assign, FlatHierarchy\_ptr result, HrcNode\_ptr hrc\_result, hash\_ptr instances)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Instantiates all in the body of a module.]

   Description        [This function is responsible of the
   instantiation of the body of a module. The module definition
   (parameter and body) is <tt>mod_def</tt> and the module instance name
   <tt>mod_name</tt> are passed as arguments. First we instantiate the
   arguments of the given module. Then it loops over the module
   definition searching for defined symbols (i.e. those introduced by
   the keyword <tt>DEFINE</tt>) and inserts their definition in the
   <tt>symbol_hash</tt>. After this preliminary phase it loops again
   over module body in order to performs the other instantiation, and
   to extract all the information needed to compile the automaton,
   i.e. the list of processes, the TRANS statements, the INIT
   statements, ... and so on.

   NB: After parsing and creating the module hash table, the order of
   declarations is correct (not reversed). This function reverse the order
   of SPEC, LTLSPEC, PSLSPEC, INVARSPEC, COMPUTE, JUSTICE AND COMPATION
   ]


   SideEffects        []

   SeeAlso            [compile_instantiate_var compile_instantiate_vars]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_instantiate\_by\_name(SymbTable\_ptr st, SymbLayer\_ptr layer, node\_ptr module\_name, node\_ptr instance\_name, node\_ptr actual, node\_ptr *assign, FlatHierarchy\_ptr result, HrcNode\_ptr hrc\_result, hash\_ptr instances)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Starts the flattening from a given point in the
   module hierarchy.]

   Description        [<tt>module_name</tt> is the name of the module being
   instantiated. The name of the module instance
   is <tt>instance_name</tt>. First checks if the module exists. Then it checks
   if the module is recursively defined, and if the case an error is
   printed out. If these checks are passed, then it proceeds in the
   instantiation of the body of the module.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compileFlattenSexpRecur(const SymbTable\_ptr symb\_table, node\_ptr sexp, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Recursive function for flattenig a sexp.]

   Description        [

   DOCUMENTATION ABOUT ARRAY:

      In NuSMV ARRAY has 2 meanings, it can be a part of identifier
   (which we call identifier-with-brackets) or a part of
   expression. For example, VAR v[5] : boolean; declares a new
   identifier-with-brackets v[5] where [5] is a part of
   identifier. Thus v[d], where d is a define equal to 5, is not a
   valid identifier as well as v[4+1] or v, whereas v[5] is valid.

   For "VAR v : array 1..5 of boolean;" v[5] is identifier (array
   elements are declared in symbol table) v[d] is not,
   but both are valid expressions.

   This difference is important for code, e.g.
     DEFINE d := v;
     INVARSPEC d[5];
   If v[5] is declared as individual identifier this code is invalid
   because v is not declared whereas if v is an array the code becomes
   valid.

   Flattener additionally makes every ARRAY-expression normalized.
   For example, d[i+1] is changed to
   case i+1=0 : v[0]; i+1=1 : v[1]; ... FAILURE; esac.
   Such a way every v[N] become a legal identifier wrt symbol table.
   Note that above normalization is done independent if defines are set
   to be expanded or not.

   NOTE: arrays of modules are not supported. Thus ARRAY before DOT
   can be legal only through identifier-with-brackets declaration, e.g.
   for v[3].b to be valid it is necessary to declare v[3] as module instance.
   ]

   SideEffects        []

   SeeAlso            [Compile_FlattenSexp Compile_FlattenSexpExpandDefine]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compileFlattenProcessRecur(const SymbTable\_ptr symb\_table, node\_ptr assign, node\_ptr context, node\_ptr running, FlatHierarchy\_ptr flatHierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Recursive definition of compileFlattenProcess]

   Description        [Recursive definition of compileFlattenProcess.
   If running is Nil there are no processes => no need to create
   data structure with CASEs (for next-assignments).]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void create\_process\_symbolic\_variables(SymbTable\_ptr symb\_table, SymbLayer\_ptr layer, node\_ptr process\_name\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Creates the internal process selector variable, within
   the given layer]

   Description        [Creates an input variable to denote
   the internal process selector, and the defines to denote
   the corresponding 'running' symbols.

   'process_name_list' is a list of existing processes names. If the list
   contains just one element ("main") no variables and defines are
   declared (no need). This happens if there is no "process" modules or
   the modules were flattened (which also removes "process" things).

   NB for developers: the internal process selector variable is by
   default positioned at the top of the ordering. It is attached to
   <tt>input_variables</tt> and <tt>all_variables</tt> too. ]

   SideEffects        [<tt>input_variables</tt> and
   <tt>all_variables</tt> are affected.]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr construct\_array\_multiplexer(node\_ptr array, node\_ptr index, boolean is\_array\_next, SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis   [Create array multiplexer in order to get rid of dynamic
   indexes.]

   Description [This function takes index-access expression
   with dynamic index and returns if-then-else expression
   with all indexes are constants
   E.g.:
      a[i]
   is converted to
      case i = min-index : a [0];
           i = min-index+1 : a [1];
           ...
           i = max-index : a [max-index];
           failure;
       esac;

   Precondition: array is allowed to be an array variable or
   array define only.

   The array and its index have to be resolved already, i.e.
   context is not required.

   Flat is_array_next signals that array has to be
   wrapped in NEXT, whereas index is not.

   The minimal and maximal indexes are obtained from the type
   of the array.
   ]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr push\_array\_index\_down(node\_ptr array, node\_ptr index, boolean is\_array\_next, SymbTable\_ptr st)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Pushes the index-access operator down
   to if-then-else expressions leaves.]

   Description [An index-access operator can be applied
   to if-then-else expression. In such case this function is used
   to push the index-access operator down. E.g.
   (a ? b : c)[i] will be converted to (a ? b[i] : c[i]).

   Flag is_array_next signals that array expression has to
   be wrapped in next whereas index remains intact.

   If idx is a variable index multiplexer is generated (on
   leaves).]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_flatten\_eval\_number(SymbTable\_ptr st, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Tries to resolve recursively to a number]

   Description        [This is a private service of function
   CompileFlatten_resolve_number]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void flatten\_declare\_constants\_within\_list(SymbTable\_ptr symb\_table, SymbLayer\_ptr layer, node\_ptr value\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Traverses the list of values, and declare all
   constants (leaves) it finds]

   Description        [Constants will occur within the given layer]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void instantiate\_array\_define(SymbTable\_ptr st, SymbLayer\_ptr layer, node\_ptr name, node\_ptr mod\_name, node\_ptr definition)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Instantiates the elements of an array define]

   Description [For every cell and every dimension create a correct
   binding in the symbol layer]


   SideEffects [Elements are added to the layer an the symbol table]

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_insert\_assign\_hrc(HrcNode\_ptr hrc\_result, node\_ptr cur\_decl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Add an assign declaration in hrc_result.]

  Description        [Add an assign declaration in hrc_result. The
  type of assign is inferred by the node type found.]

  SideEffects        [Contents of hrc_result is changed adding an
  assign constraint.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static HrcNode\_ptr get\_hrc\_root\_node (HrcNode\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Get the HRC root node from a child]

   Description        [Get the HRC root node from a child]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_flatten\_get\_int(node\_ptr value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a numeric constant in node_ptr representation
   the function returns its value as int]

   Description        [It is an error if overflow/underflow happens]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_flatten\_normalise\_value\_list(node\_ptr old\_value\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Aux function for the CompileFlatten_normalise_value_list]

   Description         [The normalisation includes: all TRUE and FALSE
   constants are substituted by 1 and 0 numbers]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_flatten\_build\_word\_toint\_ith\_bit\_case(node\_ptr wexpr, int bit, boolean is\_neg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Aux function for the
                       compile_flatten_rewrite_word_toint_cast, which
                       is used for toint cast operator rewriting]

   Description        [Creates the following expression:
                       wexpr[bit:bit] (is_neg ? "!=" : "=") 0ud1_1 ? (2^bit) : 0

                       For example, for wexpr = "word_var", bit = "2",
                       is_neg = "false" we have:

                       word_var[2:2] = 0ud1_1 ? 4 : 0]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_flatten\_rewrite\_word\_toint\_cast(node\_ptr body, SymbType\_ptr type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Rewrites the toint operator for word expressions
                       conversion]

   Description        [This functions takes a word expression and rewrites it
                       as a circuit in order to convert the word
                       expression into an integer expression.

                       For unsigned word[N], we rewrite the operator as follows:

                       (w[0:0] = 0ud1_1 ? 1 : 0) +
                       (w[1:1] = 0ud1_1 ? 2 : 0) +
                       ..... +
                       (w[N-1:N-1] = 0ud1_1 ? 2^(N-1) : 0)

                       For signed word[N], we do the following:
                       case
                       w[N-1:N-1] = 0ud1_0 :
                       (w[0:0] = 0ud1_1 ? 1 : 0) +
                       (w[1:1] = 0ud1_1 ? 2 : 0) +
                       ..... +
                       (w[N-2:N-2] = 0ud1_1 ? 2^(N-2) : 0);
                       TRUE:
                       -((w[0:0] = 0ud1_1 ? 0 : 1) +
                       (w[1:1] = 0ud1_1 ? 0 : 2) +
                       ..... +
                       (w[N-2:N-2] = 0ud1_1 ? 0 : 2^(N-2)) + 1);
                       esac]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileStruct.c}
		
	\texttt{PredicateNormaliser\_ptr Compile\_get\_global\_predicate\_normaliser()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a global predicate normaliser]

  Description [See PredicateNormaliser.h for more info 
  on predication normaliser.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FsmBuilder\_ptr Compile\_get\_global\_fsm\_builder()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the global fsm builder]

  Description [See fsm/FsmBuilder.h for more info]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{cmp\_struct\_ptr cmp\_struct\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the cmp structure]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void cmp\_struct\_quit(cmp\_struct\_ptr cmp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Free the cmp structure]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileUtil.c}
		
	\texttt{node\_ptr sym\_intern(char *s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds an internal representation for a given string.]

  Description        [Builds an internal representation for a given
  string. If the conversion has been performed in the past, then the
  hashed value is returned back, else a new one is created, hashed and
  returned. We hash this in order to allow the following:
  <pre>
  VAR
     x : {a1, a2, a3};
     y : {a3, a4, a5};

  ASSIGN
     next(x) := case
                 x = y    : a2;
                 !(x = y) : a1;
                 1        : a3;
                esac;
  </pre>
  i.e. to allow the equality test between x and y. This can be
  performed because we internally have a unique representation of the
  atom <tt>a3</tt>.]

  SideEffects        []

  SeeAlso            [find_atom]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Compile\_pop\_distrib\_ops(node\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Simplifies the given property by exploiting 
  the distributivity of G, AG and H over AND, and distributivity of F, AF and O 
  over OR]

  Description        [Transformation rules are:
   1) <OP> <OP> a           :-> <OP> a
   2) (<OP> a) * (<OP> b)   :-> <OP> (a * b);
   3) (<OP> (a * <OP> b))   :-> <OP> (a * b);
   4) (<OP> (<OP> a * b))   :-> <OP> (a * b);
   5) (<OP> (<OP> a * <OP> b)) :-> <OP> (a * b); 

   Where <OP> can be either:
     G|AG|H for * := &
     F|AF|O for * := |

   Given property can be both flattened or unflattened.
   ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Compile\_make\_sorted\_vars\_list\_from\_order(const SymbTable\_ptr st, const NodeList\_ptr vars, const NodeList\_ptr vars\_order)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [This function creates a new list of variables that will
  contain the same symbols into 'vars', but ordered wrt to
  'vars_order' content]

  Description [This function can be used to construct an ordered list
  of symbols. The set of symbols is provided by the input list 'vars',
  whereas the ordering is provided by the 'vars_order' list, that can
  be an intersecting set over 'vars'. The resulting list will
  contain those symbols that occur in vars_order (respecting their
  order), plus all the symbols in vars that do not occur in vars_order,
  pushed at the end of the list. All duplicates (if any) will not occur
  into the resulting list. The returned set must be destroyed by the
  caller.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Compile\_check\_if\_model\_was\_built(FILE* err, boolean forced)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if bdd model has been constructed]

  Description [Returns 0 if constructed, 1 otherwise. If given file is
  not NULL, an error message is also printed out to it (typically, you
  will use nusmv_stderr). Use this function from commands that require 
  the model to be constructed for being executed.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Compile\_check\_if\_bool\_model\_was\_built(FILE* err, boolean forced)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if boolean model has been constructed]

  Description [Returns 0 if constructed, 1 otherwise. If given file is
  not NULL, an error message is also printed out to it (typically, you
  will use nusmv_stderr). If forced is true, thatn the model is
  requested to be built even when COI is enabled.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Compile\_check\_if\_flat\_model\_was\_built(FILE* err, boolean forced)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if flat model has been constructed]

  Description [Returns 0 if constructed, 1 otherwise. If given file is
  not NULL, an error message is also printed out to it (typically, you
  will use nusmv_stderr). If forced is true, than the model is
  requested to be built even when COI is enabled.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Compile\_check\_if\_encoding\_was\_built(FILE* err)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the variables enconding has been constructed]

  Description [Returns 0 if constructed, 1 otherwise. If given file is
  not NULL, an error message is also printed out to it (typically, you
  will use nusmv_stderr)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Compile\_check\_if\_flattening\_was\_built(FILE* err)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks if the flattening has been carried out]

  Description [Returns 0 if constructed, 1 otherwise. If given file is
  not NULL, an error message is also printed out to it (typically, you
  will use nusmv_stderr)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileWrite.c}
		
	\texttt{void Compile\_WriteFlattenModel(FILE* out, const SymbTable\_ptr st, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteRestrictedFlattenModel(FILE* out, const SymbTable\_ptr st, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Dumps the flatten model on the given FILE]

   Description        [Dumps the flatten model on the given FILE.
                       The dumped model is restricted to the set of variables
                       defined in the given FlatHierarchy]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteObfuscatedFlattenModel(FILE* out, const SymbTable\_ptr st, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy, boolean print\_map, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteFlattenFsm(FILE* out, const SymbTable\_ptr st, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the flatten version of FSM of an SMV model.]

   Description        [Prints on the specified file the flatten
   FSM of an SMV model, i.e. a list of all variable, defines, and all
   constrains (INIT, TRANS, INVAR, ASSIGNS, JUSTICE, COMPASSION).
   Specifications are NOT printed.

   layer_names is an array of names of layers that is typically
   obtained from the symbol table. fsm_name is a name of the output
   structure, usually it is "MODULE main".  ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteFlattenSpecs(FILE* out, const SymbTable\_ptr st, FlatHierarchy\_ptr hierarchy, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the given flatten specifications.]

   Description        [Prints into the specified file the flatten
   specifications.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteBoolModel(FILE* out, BddEnc\_ptr enc, NodeList\_ptr layers, const char* fsm\_name, BoolSexpFsm\_ptr bool\_sexp\_fsm, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the given boolean model ]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteBoolFsm(FILE* out, const SymbTable\_ptr st, NodeList\_ptr layers, const char* fsm\_name, BoolSexpFsm\_ptr bool\_sexp\_fsm, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the boolean FSM of an SMV model.]

   Description        [Prints into the specified file the boolean FSM of an
   SMV model.
   bool_sexp_fsm should be a boolean Sexp FSM.
   layer_names is an array of layers whose variables will be printed,
   usually this parameter is a list of all layers committed to enc. The array
   should be ended by a NULL element.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteBoolSpecs(FILE* out, BddEnc\_ptr enc, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the boolean specifications of an SMV model.]

   Description        [Prints into the specified file the booleanized
   specifications of an SMV model.

   NOTE: a temporary layer will be created during the dumping for
   determinization variables that derived from the booleanization of
   the specifications. These variable declarations will be printed
   after the specs.
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Compile\_make\_dag\_info(node\_ptr expr, hash\_ptr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Returns a node COLON(NUMBER count, NUMBER depth)]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_destroy\_dag\_info(hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Frees the content of given structures.]

   Description        [Warning: the hashes are not freed, only the content]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_write\_dag\_defines(FILE* out, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Compile\_convert\_to\_dag(SymbTable\_ptr symb\_table, node\_ptr expr, hash\_ptr dag\_hash, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Top level function to create dags from expressions]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_print\_array\_define(FILE* out, const node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints an array define node to out file.]

   Description        [Prints a array define node to out file.
   This function is exported so the hrc package can use it.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean is\_array\_define\_element(const SymbTable\_ptr symb\_table, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true iff this name is sub-element of
   an array define.]

   Description [If name refers to an array element the index has to be
   a NUMBER. The name has to be a define or array define identifier. ]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean is\_array\_var\_element(const SymbTable\_ptr symb\_table, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Returns true iff this name is sub-element of
   a variable array.]

   Description [If name refers to an array element the index has to
   be a NUMBER. The name has to be a var or array var identifier.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flat\_define(const SymbTable\_ptr symb\_table, FILE* out, const NodeList\_ptr names, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Writes DEFINE declarations in SMV format on a file.]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flat\_define(const SymbTable\_ptr symb\_table, FILE* out, const SymbLayer\_ptr layer, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Writes DEFINE declarations in SMV format on a file.]

   Description [This function behaves exactly like compile_write_flat_define
   except that identifiers a re obfuscated before.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flat\_define\_aux(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr name, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr printed\_arrays, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Writes a DEFINE declarations in SMV format on a file.]

   Description [If a define happens to be an array define's element
   then array is output (and remembered in printed_arrays)
   instead of the original identifiers.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flat\_define\_aux(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr name, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr printed\_arrays, hash\_ptr obfuscation\_map, boolean force\_flattening)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Writes a DEFINE declarations in SMV format on a file.]

   Description [This function behaves example like
   compile_write_flat_define_aux
   except that identifiers are obfuscated before being printed.
   ]

   SideEffects        []

   SeeAlso            [compile_write_flat_define_aux]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_vars(const SymbTable\_ptr symb\_table, FILE* out, const SymbLayer\_ptr layer, SymbLayerIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes VAR, FROZENVAR, and IVAR declarations in
   SMV format on a file.]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flatten\_vars(const SymbTable\_ptr symb\_table, FILE* out, const SymbLayer\_ptr layer, const SymbTableType type, hash\_ptr obfuscation\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes VAR, FROZENVAR, and IVAR declarations in
   SMV format on a file.]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_vars\_aux(const SymbTable\_ptr symb\_table, const node\_ptr name, FILE* out, hash\_ptr printed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Print the variable declaration.]

   Description [If the identifier contains an index subscript in its
   name then at first the identifier check for being a part of an array.
   In this case array is output (and remembered in "printed") instead of
   the var. Otherwise, the identifier is output.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean compile\_write\_obfuscated\_flatten\_vars\_aux(const SymbTable\_ptr symb\_table, const node\_ptr name, FILE* out, hash\_ptr printed, hash\_ptr obfuscation\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Print the variable declaration after obfuscation]

   Description [The function works exactly like
   compile_write_flatten_vars_aux but all identifiers
   are obfuscated before being printed.]

   SideEffects []

   SeeAlso     [compile_write_flatten_vars_aux]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Compile\_obfuscate\_expression(const SymbTable\_ptr symb\_table, node\_ptr expr, const hash\_ptr obfuscation\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Apply the obfuscation over an expression]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flat\_asgn(const SymbTable\_ptr symb\_table, FILE* out, const NodeList\_ptr vars, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened ASSIGN declarations in SMV format on a
   file.]

   Description        [Writes flattened ASSIGN declarations in SMV format on a
   file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flat\_asgn(const SymbTable\_ptr symb\_table, FILE* out, const SymbLayer\_ptr layer, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened ASSIGN declarations in SMV format on a
   file.]

   Description        [Writes flattened ASSIGN declarations in SMV format on a
   file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_print\_assign(SymbTable\_ptr st, FILE * out, node\_ptr lhs, node\_ptr rhs, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints an assignement statement]

   Description        [Prints an assignement statement]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_bool\_vars(const SymbTable\_ptr symb\_table, const BoolEnc\_ptr bool\_enc, FILE* out, const SymbLayer\_ptr layer, const SymbTableType type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes boolean VAR, FROZENVAR and IVAR declarations in
   SMV format on a file. Non boolean vars are dumped as defines for the sake of
   readability of conterexamples. ]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_spec\_split(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened spec in SMV format on a file.]

   Description        [Writes a generic spec prefixed by a given
   string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flatten\_spec\_split(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened spec in SMV format on a file.]

   Description        [Writes a generic spec prefixed by a given
   string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_spec(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened spec in SMV format on a file.]

   Description        [Writes a generic spec prefixed by a given
   string in SMV format on a file.
   Returns true if at least one character was printed, and false otherwise.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flatten\_spec(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened spec in SMV format on a file.]

   Description        [Writes a generic spec prefixed by a given
   string in SMV format on a file.
   Returns true if at least one character was printed, and false otherwise.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flatten\_expr\_split(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened expression in SMV format on a file.]

   Description        [Writes a generic expression prefixed by a given
   string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_expr\_split(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened expression in SMV format on a file.]

   Description        [Writes a generic expression prefixed by a given
   string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_expr(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened expression in SMV format on a file.]

   Description        [Writes a generic expression prefixed by a given
   string in SMV format on a file.
   Returns true if at least one character was printed, and false otherwise.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flatten\_expr(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened expression in SMV format on a file.]

   Description        [Writes a generic expression prefixed by a given
   string in SMV format on a file.
   Returns true if at least one character was printed, and false otherwise.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_psl(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes PSL properties as they are.]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_bfexpr(BddEnc\_ptr enc, const SymbTable\_ptr symb\_table, SymbLayer\_ptr det\_layer, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened expression in SMV format on a file.]

   Description        [Writes a generic expression prefixed by a given
   string in SMV format on a file. The given layer is intended to hold the
   determization variables that are created by the booleanization process of
   the properties, that are kept not booleanized within the system.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flatten\_expr\_pair(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr l, const char* s, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Writes flattened expression pairs in SMV format on a
   file.]

   Description [Writes a list of flattened expression pairs prefixed by
   a given string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_flatten\_expr\_pair(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr l, const char* s, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Writes flattened expression pairs in SMV format on a
   file.]

   Description [Writes a list of flattened expression pairs prefixed by
   a given string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_constants(const SymbTable\_ptr symb\_table, FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes the set of non-numeric constants as CONSTANTS
   statement]

   Description        [Returns 1 if at least one char have been written, 0
   otherwise]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_obfuscated\_constants(const SymbTable\_ptr symb\_table, FILE* out, hash\_ptr obfuscation\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes the set of non-numeric constants as CONSTANTS
   statement]

   Description        [Returns 1 if at least one char have been written, 0
   otherwise]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr Compile\_get\_obfuscation\_map(const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Generates the obfuscation map]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_obfuscated\_flat\_fsm(FILE* out, const SymbTable\_ptr symb\_table, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the obfuscated flatten version of FSM of an
   SMV model.]

   Description        []

   SideEffects        []

   SeeAlso            [compile_write_flat_fsm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_flat\_fsm(FILE* out, const SymbTable\_ptr symb\_table, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the flatten version of FSM of an SMV model.]

   Description        [Prints on the specified file the flatten
   FSM of an SMV model, i.e. a list of all variable, defines, and all
   constrains (INIT, TRANS, INVAR, ASSIGNS, JUSTICE, COMPASSION).
   Specifications are NOT printed.

   layer_names is an array of names of layers that is typically
   obtained from the symbol table. fsm_name is a name of the output
   structure, usually it is "MODULE main".  ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean compile\_write\_is\_var\_in\_set(const SymbLayer\_ptr layer, const node\_ptr sym, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Filter for a SymbLayer iter, filters out variables
                       that are not in the set given as argument]

   Description        [Filter for a SymbLayer iter, filters out variables
                       that are not in the set given as argument]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_restricted\_flat\_fsm(FILE* out, const SymbTable\_ptr symb\_table, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the restricted flatten version of FSM of
                       an SMV model.]

   Description        [Prints on the specified file the flatten
   FSM of an SMV model, i.e. a list of restricted variables, defines, and all
   constrains (INIT, TRANS, INVAR, ASSIGNS, JUSTICE, COMPASSION) restricted to
   the set of variables in the FlatHierarchy.
   Specifications are NOT printed.

   layer_names is an array of names of layers that is typically
   obtained from the symbol table. fsm_name is a name of the output
   structure, usually it is "MODULE main".  ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_flat\_spec(FILE* out, const SymbTable\_ptr symb\_table, node\_ptr spec, const char* msg, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the given flatten specifications.]

   Description        [Prints into the specified file the flatten
   specifications.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_obfuscated\_flat\_spec(FILE* out, const SymbTable\_ptr symb\_table, node\_ptr spec, const char* msg, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the given flatten specifications.]

   Description        [Prints into the specified file the flatten
   specifications.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_flat\_specs(FILE* out, const SymbTable\_ptr st, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the flatten specifications of an SMV model.]

   Description        [Prints into the specified file the
   specifications of an SMV model.
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_obfuscated\_flat\_specs(FILE* out, const SymbTable\_ptr st, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr obfuscation\_map, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the obfuscated flatten specifications of an
   SMV model.]

   Description        []

   SideEffects        []

   SeeAlso            [compile_write_flat_specs]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_bool\_fsm(FILE* out, const SymbTable\_ptr symb\_table, NodeList\_ptr layers, const char* fsm\_name, BoolSexpFsm\_ptr bool\_sexp\_fsm, hash\_ptr dag\_info, hash\_ptr defines, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the boolean FSM of an SMV model.]

   Description        [Prints into the specified file the boolean FSM of an
   SMV model.
   bool_sexp_fsm should be a boolean Sexp FSM.
   layer_names is an array of layers whose variables will be printed,
   usually this parameter is a list of all layers committed to enc. The array
   should be ended by a NULL element.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_bool\_spec(FILE* out, BddEnc\_ptr enc, node\_ptr spec, const char* msg, SymbLayer\_ptr det\_layer, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private service to print a boolean specification]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_bool\_specs(FILE* out, BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the boolean specifications of an SMV model.]

   Description        [Prints into the specified file the booleanized
   specifications of an SMV model.

   NOTE: a temporary layer will be created during the dumping for
   determinization variables that derived from the booleanization of
   the specifications. These variable declarations will be printed
   after the specs.
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_convert\_to\_dag\_aux(SymbTable\_ptr symb\_table, node\_ptr expr, hash\_ptr hash, unsigned int num\_thres, unsigned int dep\_thres, hash\_ptr defines, const char* defines\_prefix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Private service of function Compile_convert_to_dag]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static hash\_ptr compile\_create\_dag\_info\_from\_hierarchy(SymbTable\_ptr st, FlatHierarchy\_ptr hierarchy, SymbLayer\_ptr det\_layer, BddEnc\_ptr enc, boolean force\_flattening, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [If det_layer is not NULL, then hierarchy is
   to be considered boolean, and specifications will be booleanized,
   If det_layer is null, then also enc can be null]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_make\_dag\_info\_aux(node\_ptr expr, hash\_ptr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Returns a node COLON(NUMBER count, NUMBER depth)]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_pack\_dag\_info(unsigned int count, unsigned int depth, boolean admissible)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Packs given count and depth into a node]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_unpack\_dag\_info(node\_ptr info, unsigned int* count, unsigned int* depth, boolean* admissible)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Unpacks given node to count and deptch]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_set\_dag\_info(node\_ptr info, unsigned int count, unsigned int depth, boolean admissible)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Sets count and depth]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval compile\_free\_node(char *key, char *data, char * arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Internal service of Compile_destroy_dag_info]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval compile\_free\_define(char *key, char *data, char * arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Internal service of Compile_destroy_dag_info]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_symbtype\_obfuscated\_print(SymbType\_ptr type, FILE* out, const SymbTable\_ptr symb\_table, hash\_ptr obfuscation\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the obfuscation of the given type]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_get\_rid\_of\_define\_chain(SymbTable\_ptr st, node\_ptr expr, hash\_ptr cdh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Get rids of chain of defines]

   Description        [Get rids of chain of defines until it reaches a
   DEFINE whose body is not atomic (i.e. a variable, a constant, or a
   complex expression). It assumes the expression being flattened.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_obfuscated\_dag\_defines(FILE* out, const SymbTable\_ptr st, hash\_ptr defines, hash\_ptr obfuscation\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr \_\_create\_define\_name(SymbTable\_ptr st, const char * prefix, node\_ptr body)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Creates a meaningful name for defines needed for dag printing]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{compileWriteUdg.c}
		
	\texttt{void Compile\_WriteFlattenModel\_udg(FILE* out, const SymbTable\_ptr st, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteFlattenFsm\_udg(FILE* out, const SymbTable\_ptr st, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the flatten version of FSM of an SMV model.]

   Description        [Prints on the specified file the flatten
   FSM of an SMV model, i.e. a list of all variable, defines, and all
   constrains (INIT, TRANS, INVAR, ASSIGNS, JUSTICE, COMPASSION).
   Specifications are NOT printed.

   layer_names is an array of names of layers that is typically
   obtained from the symbol table. fsm_name is a name of the output
   structure, usually it is "MODULE main".  ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteFlattenSpecs\_udg(FILE* out, const SymbTable\_ptr st, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the given flatten specifications.]

   Description        [Prints into the specified file the flatten
   specifications.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteBoolModel\_udg(FILE* out, BddEnc\_ptr enc, NodeList\_ptr layers, const char* fsm\_name, BoolSexpFsm\_ptr bool\_sexp\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the given boolean model ]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteBoolFsm\_udg(FILE* out, const SymbTable\_ptr st, NodeList\_ptr layers, const char* fsm\_name, BoolSexpFsm\_ptr bool\_sexp\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the boolean FSM of an SMV model.]

   Description        [Prints into the specified file the boolean FSM of an
   SMV model.
   bool_sexp_fsm should be a boolean Sexp FSM.
   layer_names is an array of layers whose variables will be printed,
   usually this parameter is a list of all layers committed to enc. The array
   should be ended by a NULL element.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_WriteBoolSpecs\_udg(FILE* out, BddEnc\_ptr enc, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the boolean specifications of an SMV model.]

   Description        [Prints into the specified file the booleanized
   specifications of an SMV model.

   NOTE: a temporary layer will be created during the dumping for
   determinization variables that derived from the booleanization of
   the specifications. These variable declarations will be printed
   after the specs.
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Compile\_make\_dag\_info\_udg(node\_ptr expr, hash\_ptr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Returns a node COLON(NUMBER count, NUMBER depth)]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_destroy\_dag\_info\_udg(hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Frees the content of given structures.]

   Description        [Warning: the hashes are not freed, only the content]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_write\_dag\_defines\_udg(FILE* out, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Compile\_convert\_to\_dag\_udg(SymbTable\_ptr symb\_table, node\_ptr expr, hash\_ptr dag\_hash, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Top level function to create dags from expressions]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Compile\_print\_array\_define\_udg(FILE* out, const node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints a array define node to out file.]

   Description        [Prints a array define node to out file.
   This function is exported so the hrc package can use it.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_write\_udg\_flatten\_array\_define(SymbTable\_ptr st, node\_ptr body, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes DEFINE declarations in SMV format on a
   file.]

   Description        [Writes DEFINE declarations in SMV format on a
   file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flat\_define(const SymbTable\_ptr symb\_table, FILE* out, const SymbLayer\_ptr layer, const SymbTableType sym\_mask, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes DEFINE declarations in SMV format on a
   file.]

   Description        [Writes DEFINE declarations in SMV format on a
   file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_flat\_array\_define\_udg(const SymbTable\_ptr symb\_table, FILE* out, const SymbLayer\_ptr layer, const SymbTableType sym\_mask, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes ARRAY DEFINE declarations in SMV format on a
   file.]

   Description        [Writes ARRAY DEFINE declarations in SMV format on a
   file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flat\_asgn(const SymbTable\_ptr symb\_table, FILE* out, const SymbLayer\_ptr layer, const SymbTableType sym\_mask, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened ASSIGN declarations in SMV format on a
   file.]

   Description        [Writes flattened ASSIGN declarations in SMV format on a
   file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_print\_assign\_udg(SymbTable\_ptr st, FILE * out, node\_ptr lhs, node\_ptr rhs, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints an assignement statement]

   Description        [Prints an assignement statement]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_vars(const SymbTable\_ptr symb\_table, FILE* out, const SymbLayer\_ptr layer, const SymbTableType var\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes VAR, FROZENVAR, and IVAR declarations in
   SMV format on a file.]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_bool\_vars(const SymbTable\_ptr symb\_table, const BoolEnc\_ptr bool\_enc, FILE* out, const SymbLayer\_ptr layer, const SymbTableType sym\_mask)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes boolean VAR, FROZENVAR and IVAR declarations in
   SMV format on a file. Non boolean vars are dumped as defines for the sake of
   readability of conterexamples. ]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_spec\_split(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, ModelSectionTag mst, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened spec in SMV format on a file.]

   Description        [Writes a generic spec prefixed by a given
   string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_spec(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, ModelSectionTag mst, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened spec in SMV format on a file.]

   Description        [Writes a generic spec prefixed by a given
   string in SMV format on a file.
   Returns true if at least one character was printed, and false otherwise.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_psl(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes PSL properties as they are.]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_bfexpr(BddEnc\_ptr enc, const SymbTable\_ptr symb\_table, SymbLayer\_ptr det\_layer, FILE* out, node\_ptr n, const char* s, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened expression in SMV format on a file.]

   Description        [Writes a generic expression prefixed by a given
   string in SMV format on a file. The given layer is intended to hold the
   determization variables that are created by the booleanization process of
   the properties, that are kept not booleanized within the system.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_expr\_split(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, ModelSectionTag mst, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened expression in SMV format on a file.]

   Description        [Writes a generic expression prefixed by a given
   string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_expr(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr n, ModelSectionTag mst, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes flattened expression in SMV format on a file.]

   Description        [Writes a generic expression prefixed by a given
   string in SMV format on a file.
   Returns true if at least one character was printed, and false otherwise.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_flatten\_expr\_pair(const SymbTable\_ptr symb\_table, FILE* out, node\_ptr l, ModelSectionTag mst, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Writes flattened expression pairs in SMV format on a
   file.]

   Description [Writes a list of flattened expression pairs prefixed by
   a given string in SMV format on a file.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_constants(const SymbTable\_ptr symb\_table, FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes the set of non-numeric constants as CONSTANTS
   statement]

   Description        [Returns 1 if at least one char have been written, 0
   otherwise]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_udg\_flat\_fsm(FILE* out, const SymbTable\_ptr symb\_table, const array\_t* layer\_names, const char* fsm\_name, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the flatten version of FSM of an SMV model.]

   Description        [Prints on the specified file the flatten
   FSM of an SMV model, i.e. a list of all variable, defines, and all
   constrains (INIT, TRANS, INVAR, ASSIGNS, JUSTICE, COMPASSION).
   Specifications are NOT printed.

   layer_names is an array of names of layers that is typically
   obtained from the symbol table. fsm_name is a name of the output
   structure, usually it is "MODULE main".  ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_udg\_flat\_specs(FILE* out, const SymbTable\_ptr st, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the flatten specifications of an SMV model.]

   Description        [Prints into the specified file the
   specifications of an SMV model.
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_udg\_bool\_fsm(FILE* out, const SymbTable\_ptr symb\_table, NodeList\_ptr layers, const char* fsm\_name, BoolSexpFsm\_ptr bool\_sexp\_fsm, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the boolean FSM of an SMV model.]

   Description        [Prints into the specified file the boolean FSM of an
   SMV model.
   bool_sexp_fsm should be a boolean Sexp FSM.
   layer_names is an array of layers whose variables will be printed,
   usually this parameter is a list of all layers committed to enc. The array
   should be ended by a NULL element.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_udg\_bool\_spec(FILE* out, BddEnc\_ptr enc, node\_ptr spec, const char* msg, SymbLayer\_ptr det\_layer, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private service to print a boolean specification]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_write\_udg\_bool\_specs(FILE* out, BddEnc\_ptr enc, SymbLayer\_ptr det\_layer, FlatHierarchy\_ptr hierarchy, hash\_ptr dag\_info, hash\_ptr defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints the boolean specifications of an SMV model.]

   Description        [Prints into the specified file the booleanized
   specifications of an SMV model.

   NOTE: a temporary layer will be created during the dumping for
   determinization variables that derived from the booleanization of
   the specifications. These variable declarations will be printed
   after the specs.
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_convert\_to\_dag\_aux\_udg(SymbTable\_ptr symb\_table, node\_ptr expr, hash\_ptr hash, unsigned int num\_thres, unsigned int dep\_thres, hash\_ptr defines, const char* defines\_prefix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Private service of function Compile_convert_to_dag_udg]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static hash\_ptr compile\_create\_dag\_info\_from\_hierarchy\_udg(SymbTable\_ptr st, FlatHierarchy\_ptr hierarchy, SymbLayer\_ptr det\_layer, BddEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [If det_layer is not NULL, then hierarchy is
   to be considered boolean, and specifications will be booleanized,
   If det_layer is null, then also enc can be null]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_make\_dag\_info\_aux\_udg(node\_ptr expr, hash\_ptr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Returns a node COLON(NUMBER count, NUMBER depth)]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr compile\_pack\_dag\_info\_udg(unsigned int count, unsigned int depth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Packs given count and depth into a node]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_unpack\_dag\_info\_udg(node\_ptr info, unsigned int* count, unsigned int* depth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Unpacks given node to count and deptch]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void compile\_set\_dag\_info\_udg(node\_ptr info, unsigned int count, unsigned int depth)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        [Sets count and depth]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval compile\_free\_node\_udg(char *key, char *data, char * arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Internal service of Compile_destroy_dag_info_udg]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval compile\_free\_define\_udg(char *key, char *data, char * arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Internal service of Compile_destroy_dag_info_udg]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean is\_array\_define\_cell\_udg(const SymbTable\_ptr st, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [ Print to the given file the array define represerntation ]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int compile\_write\_udg\_print\_node(FILE* out, node\_ptr n, boolean close, boolean shared, const char* style)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Menthod that prints the given node in udg format]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int insert\_assoc\_w (hash\_ptr hash, node\_ptr key, node\_ptr value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   TODO

   Synopsis    [Virtual menthod that prints the given node
   (core nodes are handled here)]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int compile\_write\_udg\_print\_2\_ary(FILE* buffer, node\_ptr code, const char* str, boolean close, boolean shared, const char* color1, const char* color2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Printer in udg format for a node with children arity equal to 2]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int compile\_write\_udg\_print\_2\_arya(FILE* buffer, node\_ptr code, const char* str, boolean close, boolean shared)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Printer in udg format for a node with children arity equal to 2]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int compile\_write\_udg\_print\_1\_ary(FILE* buffer, node\_ptr code, const char* str, boolean close, boolean shared, const char* color1)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Printer in udg format for a node with a child]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int compile\_write\_udg\_print\_3\_aryc(FILE* buffer, node\_ptr code, const char* str, node\_ptr fst, node\_ptr snd, node\_ptr trd, boolean close, boolean shared)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Printer in udg format for a node with children arity equal to 3]

   Description [The children are provided explicitly]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int compile\_write\_udg\_print\_3\_aryc\_color(FILE* buffer, node\_ptr code, const char* str, node\_ptr fst, node\_ptr snd, node\_ptr trd, boolean close, boolean shared, const char* color1, const char* color2, const char* color3)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Printer in udg format for a node with children arity equal to 3
   with different colors]

   Description [The children are provided explicitly]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{dag}
		
	\subsection{dagDfs.c}
		
	\texttt{void Dag\_Dfs(Dag\_Vertex\_t* current, Dag\_DfsFunctions\_t* dfs\_fun, char* dfs\_data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performs a generic, iterative, DFS on the dag.]

  Description [The parameters are:
               <ul>
               <li> current, the dag vertex where to start the DFS
               <li> dfs_fun, the functions to perform the DFS steps
               <li> dfs_data, a reference to generic data
               </ul>
               The function increments the DFS code for the dag manager owning
               dfsRoot. Increment of the code guarantees that each node is
               visited once and only once. dfs_fun->Set() may change the default
               behaviour by forcing the DFS to visit nodes more than once
               (by returning -1), or by preventing DFS to do a complete visit
               (by returning 1).]

  SideEffects [node->dag->dfsCode: is incremented by one.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Dag\_Dfs(Dag\_Vertex\_t* dfsRoot, Dag\_DfsFunctions\_t* dfsFun, char* dfsData)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performs a generic DFS on the dag.]

  Description [The parameters are:
               <ul>
               <li> dfsRoot, the dag vertex where to start the DFS
               <li> dfsFun, the functions to perform the DFS steps
               <li> dfsData, a reference to generic data
               </ul>
               The function increments the DFS code for the dag
               manager owning dfsRoot and starts the DFS. Increment of
               the code guarantees that each node is visited once and
               only once. dfsFun -> Set() may change the default behaviour by
               forcing to DFS to visit nodes more than once, or by preventing
               DFS to do a complete visit.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void DFS( Dag\_Vertex\_t * v, Dag\_DfsFunctions\_t * dfsFun, char * dfsData, nusmv\_ptrint vBit)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performs a generic (recursive) DFS on the dag.]

  Description [The parameters are:
               <ul>
               <li> v, the current dag vertex
               <li> dfsFun, the functions to perform the DFS
               <li> dfsData, a reference to generic data
               <li> vBit, the incoming link annotation (0 or not-0)
               </ul>]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int return\_zero(Dag\_Vertex\_t* f, char* cleanData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs SetVisit for cleaning.]

  Description [Dfs SetVisit for cleaning.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void clean\_first(Dag\_Vertex\_t* f, char* cleanData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for cleaning.]

  Description [Dfs FirstVisit for cleaning.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void do\_nothing(Dag\_Vertex\_t* f, char* cleanData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Back & Last visit for cleaning.]

  Description [Dfs Back & Last visit for cleaning.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{dagEnStat.c}
		
	\texttt{void PrintStat(Dag\_Vertex\_t* dfsRoot, FILE* statFile, char* prefix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Visit a DAG to compute some statistics]

  Description        [Calls Depth First Search on the DAG dfsRoot to populate
                      the struct Statistics.
                      Then calls _PrintStat to print out them.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void doNothingAndReturnVoid(Dag\_Vertex\_t* f, char* visData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dfs function doing nothing]

  Description        [Dfs function doing nothing]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int doNothingAndReturnZero(Dag\_Vertex\_t* f, char * visData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dfs function returning zero]

  Description        [Dfs function returning zero]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ResetStat(Statistics\_t* stat)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reset the statistics data]

  Description        [Reset the statistics data]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int ComputeFatherAndSonNum(Dag\_Vertex\_t* f, char * visData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dfs function]

  Description        [Dfs function]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ComputeDepth(Dag\_Vertex\_t* v, int p\_depth, Statistics\_t* stat)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dfs function]

  Description        [Dfs function]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void \_PrintStat(Statistics\_t* stat, FILE* statFile, char* prefix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Print out the number of nodes by degree and depth]

  Description        [Print these data:
                      1. Total nodes per number of children;
                      2. Total nodes and total leaves per depth.]

  SideEffects        [data are appended to statFile]

  SeeAlso            [PrintStat()]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{dagManager.c}
		
	\texttt{Dag\_Manager\_t * Dag\_ManagerAlloc()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a new DAG manager.]

  Description [Allocates the unique table (vTable) and the free list (gcList).
               Initializes the counters for various statistics (stats).
               Returns the pointer to the dag manager.]

  SideEffects [none]

  SeeAlso     [Dag_ManagerAllocWithParams Dag_ManagerFree]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Dag\_ManagerFree( Dag\_Manager\_t * dagManager, Dag\_ProcPtr\_t freeData, Dag\_ProcPtr\_t freeGen)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deallocates a DAG manager.]

  Description [Forces a total garbage collection and then deallocates the
               dag manager. `freeData' can be used to deallocate `data'
               fields (user data pointers) in the nodes, while `freeGen' 
               is applied to `gRef' fields (user generic pointers). 
               `freeData' and `freeGen' are in the form `void f(char * r)'.]

  SideEffects [none]

  SeeAlso     [Dag_ManagerGC] 

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Dag\_ManagerGC( Dag\_Manager\_t * dagManager, Dag\_ProcPtr\_t freeData, Dag\_ProcPtr\_t freeGen)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Garbage collects the DAG manager.]

  Description [Sweeps out useless vertices, i.e., vertices that are not 
               marked as permanent, that are not descendants
               of permanent vertices, or whose brother (if any) is neither
               permanent nor descendant of a permanent vertex.
               The search starts from vertices that are in the garbage
               bin and whose mark is 0. 
               `freeData' can be used to deallocate `data'
               fields (user data pointers) in the nodes, while `freeGen' 
               is applied to `gRef' fields (user generic pointers). 
               `freeData' and `freeGen' are in the form `void f(char * r)'.]

  SideEffects [none]

  SeeAlso     [Dag_ManagerFree]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void GC( Dag\_Vertex\_t * v, Dag\_ProcPtr\_t freeData, Dag\_ProcPtr\_t freeGen)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Depth-first garbage collection.]

  Description [Gets a vertex to be freed. If the vertex has permanent or 
               non-orphan brothers it is rescued. Otherwise the brother is
               unconnected and the sons marks are updated. GC is then 
               propagated to each fatherless son.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{dagStat.c}
		
	\texttt{void Dag\_PrintStats( Dag\_Manager\_t * dagManager, int clustSz, FILE * outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints various statistics.]

  Description [Prints the following:
               <ul>
               <li> the number of entries found in every chunk of
                    `clustSz' bins (if `clustSz' is 1 then the number
                    of entries per bin is given, if `clustSz' is 0 no
		    such information is displayed);
               <li> the number of shared vertices, i.e., the number
                    of v's such that v -> mark > 1;
	       <li> the average entries per bin and the variance;
	       <li> min and max entries per bin.
               </ul>]


  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{dagVertex.c}
		
	\texttt{Dag\_Vertex\_t * Dag\_VertexLookup( Dag\_Manager\_t * dagManager, int vSymb, char * vData, Dag\_Vertex\_t** vSons, unsigned numSons)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Vertex lookup.]

  Description [Uniquely adds a new vertex into the DAG and returns a
               reference to it:
               <ul>
               <li> vSymb is a NON-NEGATIVE  integer (vertex label);
               <li> vData is a pointer to generic user data;
               <li> vSons is a list of vertices (possibly NULL).
               </ul>
               Returns NIL(Dag_vertex_t) if there is no dagManager and 
               if vSymb is negative.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Dag\_Vertex\_t * Dag\_VertexInsert( Dag\_Manager\_t * dagManager, int vSymb, char * vData, Dag\_Vertex\_t ** vSons, unsigned numSons)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Vertex insert.]

  Description [Adds a vertex into the DAG and returns a
               reference to it:
               <ul>
               <li> vSymb is an integer code (vertex label);
               <li> vData is a generic annotation;
               <li> vSons must be a list of vertices (the intended sons).
               </ul>
               Returns NIL(Dag_vertex_t) if there is no dagManager and
               if vSymb is negative.]
               NOTICE: as opposed to Dag_VertexLookup, the unique table
               is not accessed, so there is no guarantee of uniqueness
               for vertices added with this mechanism.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Dag\_VertexMark( Dag\_Vertex\_t * v)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Marks a vertex as permanent.]

  Description [Increments the vertex mark by one, so it cannot be
               deleted by garbage collection unless unmarked.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Dag\_VertexUnmark( Dag\_Vertex\_t * v)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Unmarks a vertex (makes it volatile).]

  Description [Decrements the vertex mark by one, so it can be
               deleted by garbage collection when fatherless.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void DagVertexInit( Dag\_Manager\_t * dagManager, Dag\_Vertex\_t * v)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Vertex initialization.]

  Description [Performs several tasks:
               <ul>
               <li> connects the vertex to the sons by increasing the sons'
                    marks
               <li> removes sons from the free list if their mark
                    is increased to one for the first time;
               <li> clears the vertex mark and stores the vertex in the 
                    free list;
               <li> clears other internal fields.
               </ul>] 

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int DagVertexComp( const char * v1, const char * v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Compare two vertices.]

  Description [Gets two vertex pointers v1, v2, (as char pointers) and
               compares the symbol, the generic data reference and the
               pointers to the sons. Returns -1 if v1 < v2, 0 if v1 =
               v2 and 1 if v1 > v2, in lexicographic order of fields.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int DagVertexHash(char* v, int modulus)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Calculate the hash key of a vertex.]

  Description [Calculate a preliminary index as follows:
                  v -> symbol                            + 
                  8 low order bits of (int) (v -> data)  +
                 16 low order bits of each son up to MAXSON +
                  1 for each son whose edge is annotated
               Return the modulus of the index and the actual hash size.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{dd}
		
	\subsection{VarsHandler.c}
		
	\texttt{VarsHandler\_ptr VarsHandler\_create(DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The VarsHandler class constructor]

  Description        [The VarsHandler class constructor]

  SideEffects        []

  SeeAlso            [VarsHandler_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void VarsHandler\_destroy(VarsHandler\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The VarsHandler class destructor]

  Description        [The VarsHandler class destructor]

  SideEffects        []

  SeeAlso            [VarsHandler_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{DdManager* VarsHandler\_get\_dd\_manager(const VarsHandler\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the contained dd manager]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean VarsHandler\_can\_group(const VarsHandler\_ptr self, int level, int size, int chunk)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if currently it is possible to
  create/reuse the given group of levels]

  Description [This method can be used to check if a group can be
  created at given level.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{GroupInfo\_ptr VarsHandler\_reserve\_group(VarsHandler\_ptr self, int from\_lev, int size, int chunk, boolean can\_share, int* lev\_low)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Constructs a group, with minimal level from_level, size
  and chunk size. Returns a structure which has to be used to
  release the group later.]

  Description [The reservation does not necessarily create a group
  at given level, but may allocate it at a greater level (this is
  why the parameter is called from_level). Returns the group ID,
  and the actual minimal level allocated. When done with it, the
  caller has to release the returned groupinfo with
  VarsHandler_release_group or VarsHandler_dissolve_group]

  SideEffects        []

  SeeAlso [VarsHandler_release_group,
  VarsHandler_dissolve_group]
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean VarsHandler\_release\_group(VarsHandler\_ptr self, GroupInfo\_ptr gid)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Releases the group (previously created with
  reserve_group)]

  Description [The group is not necessarily released, at it (or
  part of it) may be shared with other created groups. After this
  method has been called, gid cannot be used anymore. Returns true
  iff the group is actually removed.]

  SideEffects        []

  SeeAlso            [VarsHandler_reserve_group]
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void VarsHandler\_dissolve\_group(VarsHandler\_ptr self, GroupInfo\_ptr gid)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Releases the given block (previously created with
  reserve_group). Differently from release_group, this method
  actually dissolves the group, all its children (contained groups)
  and all groups containing it (i.e. all parents).]

  Description [After this method has been called, gid cannot be
  used anymore. Also, all other GroupInfo instances possibly
  pointing to any of the removed groups will be invalidated, so
  later removals will be handled correctly.]

  SideEffects        []

  SeeAlso            [VarsHandler_reserve_group]
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void VarsHandler\_update\_levels(VarsHandler\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [After a reordering, levels in the dd package may do not
  correspond to the levels in the vars handler. This method re-align the 
  vars handler wrt the current levels.]

  Description [Realigns the whole internal groups structure, and
  all currently existing GroupInfo instances.]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void VarsHandler\_print(const VarsHandler\_ptr self, FILE* \_file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the content of the VarsHandler]

  Description        [This is used for debugging/verosity purposes]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int vars\_handler\_remove\_group(VarsHandler\_ptr self, Olist\_ptr list, const GroupInfo\_ptr ginfo)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal service for VarsHandler_release_group]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Oiter vars\_handler\_promote\_group(VarsHandler\_ptr self, Olist\_ptr list, const GroupInfo\_ptr ginfo)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Brings the given group at top level (along with all its
  children), splitting all the parents accordingly.]

  Description [Internal service of
  VarsHandler_dissolve_group, as before dissolving
  groups, they has to be brough to the top-level. Returns an
  iterator to the top level which contains the group.]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static VarsGroup* vars\_handler\_search\_group(const VarsHandler\_ptr self, int lev\_low, size\_t size, int chunk, enum GroupSearchRes* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Searches a good place where the group can be inserted.]

  Description [This method is used for searching a given group, or
  for searching a good place where a new group can be
  inserted. 

  There are four input parameters: The VarsHandler instances, the
  minimal level at which a group shall be searched from, the size
  of the searched group, and the chunk size (2 for state variables,
  1 for frozen and input).

  There are three output parameters: a group, the actual found
  minimal level, and a value identifying the result of the search.

  If a perfect match is found (the searched group is found), the
  group is returned, and lev_low will be kept untouched.

  If a root is found, it means that the searched group does not
  exist, but a group was found which can contain it. In this case
  the parent is returned.

  If not found, NULL is returned as VarsGroup, and lev_low will
  contain the first usable level which can be used to create a new
  top-level group (see how this case is used in
  VarsHandler_reserve_group)]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void vars\_handler\_add\_group(VarsHandler\_ptr self, VarsGroup* parent, VarsGroup* group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds the given group to the forest]

  Description        [If parent is NULL, group has to be a physical ]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int vars\_handler\_update\_levels(VarsHandler\_ptr self, VarsGroup* root)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Updates the levels of the root and all its children]

  Description        [Internal service of VarsHandler_update_levels]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static VarsGroup* vars\_group\_search\_group\_aux(const VarsGroup* in\_group, int lev\_low, size\_t size, int chunk, enum GroupSearchRes* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Searches the closest group]

  Description        [Internal service of vars_group_search_group]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void vars\_handler\_init(VarsHandler\_ptr self, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The VarsHandler class private initializer]

  Description        [The VarsHandler class private initializer]

  SideEffects        []

  SeeAlso            [VarsHandler_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void vars\_handler\_deinit(VarsHandler\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The VarsHandler class private deinitializer]

  Description        [The VarsHandler class private deinitializer]

  SideEffects        []

  SeeAlso            [VarsHandler_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static VarsGroup* VarsGroup\_create(int lev\_low, int lev\_high, int idx\_low, int chunk)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [VarsGroups cosntructor]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void VarsGroup\_destroy(VarsGroup* self, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [VarsGroups destroyer]

  Description        [Traverses all the tree, and frees it]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void VarsGroup\_add\_ginfo(VarsGroup* self, GroupInfo\_ptr gi)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds the given GroupInfo to the given VarsGroup]

  Description [Since internal list of group info is sorted for the
  sake of good performances, this method inserts in order.]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean VarsGroup\_remove\_ginfo(VarsGroup* self, GroupInfo\_ptr gi)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes the id if found.]

  Description [Returns: true if found, false otherwise.]

  SideEffects [Changes the gis internal list. Do not call when
  iterating on it.]

  SeeAlso     []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Oiter VarsGroup\_find\_ginfo(const VarsGroup* self, GroupInfo\_ptr gi)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Searches the given group information.]

  Description [Returns the iterator pointing to it in the internal list]

  SideEffects []

  SeeAlso     []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int vars\_group\_sort(void* \_g1, void* \_g2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal service used when sorting VarsGroup lists]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void vars\_group\_print(VarsGroup* group, FILE* \_file, int indent)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal service used when printing groups]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int vars\_handler\_get\_first\_free\_level(VarsHandler\_ptr self, int from\_lev, int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Searches among the available groups for holes, and
  return the first free level starting from given level.]

  Description [If needed, creates size new variables from the
  frontier, in particular, if from_lev is < 0.]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{dd.c}
		
	\texttt{DdManager* init\_dd\_package()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new DD manager.]

  Description [Creates a new DD manager, initializes the table, the
  basic constants and the projection functions.<br>
  \"maxMemory\" (the last parameter of the function \"Cudd_Init\")
  is set to 0. In such a way \"Cudd_Init\" decides suitables values
  for the maximum size of the cache and for the limit for fast unique
  table growth based on the available memory. Returns a pointer to the
  manager if successful; else abort depending the mode (interactive or
  batch) the system is used.]

  SideEffects        []

  SeeAlso            [quit_dd_package]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void quit\_dd\_package(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deletes resources associated with a DD manager.]

  Description        [Deletes resources associated with a DD manager and
  resets the global statistical counters. (Otherwise, another manager
  subsequently created would inherit the stats of this one.)]

  SideEffects        []

  SeeAlso            [init_dd_package]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_checkzeroref(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Checks the unique table for nodes with non-zero reference
  counts.]

  Description [Checks the unique table for nodes with non-zero
  reference counts. It is normally called before dd_quit to make sure
  that there are no memory leaks due to missing add/bdd_free's.
  Takes into account that reference counts may saturate and that the
  basic constants and the projection functions are referenced by the
  manager.  Returns the number of nodes with non-zero reference count.
  (Except for the cases mentioned above.)]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int get\_dd\_nodes\_allocated(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of nodes in the unique table.]

  Description        [Returns the total number of nodes currently in the unique
  table, including the dead nodes.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr map\_dd(DdManager * dd, NPFDD f, node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Applies function <code>f</code> to the list of BDD/ADD <code>l</code>.]

  Description [This function acts like the Lisp <tt>mapcar</tt>. It returns
  the list of the result of the application of function \code>f</code> to each
  element of list <code>l</code>.]

  SideEffects        []

  SeeAlso            [map walk walk_dd]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void walk\_dd(DdManager * dd, VPFDD f, node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Applies function <code>f</code> to the list of BDD/ADD <code>l</code>.]

  Description [This function acts like the <tt>map_dd</dd>. This functions
  applies the function <code>f</code> to each element of list
  <code>l</code>. Nothing is returned, performs side-effects on the elements.]

  SideEffects        []

  SeeAlso            [map walk map_dd]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void dd\_print\_stats(DdManager *mgr, FILE *file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints out statistic and setting of the DD manager.]

  Description [Prints out statistics and settings for a CUDD manager.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{dd\_block * dd\_new\_var\_block(DdManager * dd, int start\_index, int offset)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Builds a group of variables that should stay adjacent
  during reordering.]

  Description [Builds a group of variables that should stay adjacent
  during reordering. The group is made up of n variables. The first
  variable in the group is f. The other variables are the n-1
  variables following f in the order at the time of invocation of this
  function. Returns a handle to the variable group if successful else fail.]

  SideEffects [Modifies the variable tree.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_free\_var\_block(DdManager* dd, dd\_block* group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dissolves a group previously created by dd_new_var_block]

  Description [Dissolves a group previously created by
  dd_new_var_block.  Returns 0 if the group was actually removed, 1
  otherwise (that may be not due to an error)]

  SideEffects [Modifies the variable tree.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_get\_index\_at\_level(DdManager *dd, int level)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the index of the variable currently in the i-th
  position of the order.]

  Description [Returns the index of the variable currently in the i-th
  position of the order. If the index is MAX_VAR_INDEX, returns
  MAX_VAR_INDEX; otherwise, if the index is out of bounds fails.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_get\_level\_at\_index(DdManager *dd, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the current position of the i-th variable in the
  order.]

  Description [Returns the current position of the i-th variable in the
  order. If the index is CUDD_MAXINDEX, returns CUDD_MAXINDEX; otherwise,
  if the index is out of bounds returns -1.]

  SideEffects [None]

  SeeAlso     [Cudd_ReadInvPerm Cudd_ReadPermZdd]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_get\_size(DdManager *dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the number of BDD variables in existance.]

  Description [Returns the number of BDD variables in existance.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_set\_order(DdManager* dd, int* permutation)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Reorders variables according to given permutation.]

  Description [Reorders variables according to given permutation.
  The i-th entry of the permutation array contains the index of the variable
  that should be brought to the i-th level.  The size of the array should be
  equal or greater to the number of variables currently in use.
  Returns 1 in case of success; 0 otherwise.]

  SideEffects [Changes the variable order for all diagrams and clears
  the cache.]

  SeeAlso []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void dd\_autodyn\_enable(DdManager * dd, dd\_reorderingtype method)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Enables automatic dynamic reordering of BDDs and ADDs.]

  Description [Enables automatic dynamic reordering of BDDs and
  ADDs. Parameter method is used to determine the method used for
  reordering. If REORDER_SAME is passed, the method is
  unchanged.]

  SideEffects []

  SeeAlso     [dd_autodyn_disable dd_reordering_status]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void dd\_autodyn\_disable(DdManager *dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Disables automatic dynamic reordering of BDD and ADD.]

  Description [Disables automatic dynamic reordering of BDD and ADD.]

  SideEffects []

  SeeAlso     [dd_autodyn_enable dd_reordering_status]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_reordering\_status(DdManager *dd, dd\_reorderingtype * method)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Reports the status of automatic dynamic reordering of BDDs
  and ADDs.]

  Description [Reports the status of automatic dynamic reordering of
  BDDs and ADDs. Parameter method is set to the reordering method
  currently selected. Returns 1 if automatic reordering is enabled; 0
  otherwise.]

  SideEffects [Parameter method is set to the reordering method currently
  selected.]

  SeeAlso     [dd_autodyn_disable dd_autodyn_enable]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_reorder(DdManager *dd, int method, int minsize)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Main dynamic reordering routine.]

  Description [Main dynamic reordering routine.
  Calls one of the possible reordering procedures:
  <ul>
  <li>Swapping
  <li>Sifting
  <li>Symmetric Sifting
  <li>Group Sifting
  <li>Window Permutation
  <li>Simulated Annealing
  <li>Genetic Algorithm
  <li>Dynamic Programming (exact)
  </ul>

  For sifting, symmetric sifting, group sifting, and window
  permutation it is possible to request reordering to convergence.<p>

  Returns 1 in case of success; 0 otherwise. In the case of symmetric
  sifting (with and without convergence) returns 1 plus the number of
  symmetric variables, in case of success.<p>

  This functions takes as arguments:
  <ul>
  <li> <tt>dd</tt> the DD manager;
  <li> <tt>heuristics</tt> method used for reordering;
  <li> <tt>minsize</tt> bound below which no reordering occurs;
  </ul>
  ]

  SeeAlso     [Cudd_ReduceHeap]

  SideEffects [Changes the variable order for all diagrams and clears
  the cache.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_get\_reorderings(DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the number of times reordering has occurred.]

  Description [Returns the number of times reordering has occurred in
  the manager. The number includes both the calls to Cudd_ReduceHeap
  from the application program and those automatically performed by
  the package. However, calls that do not even initiate reordering are
  not counted. A call may not initiate reordering if there are fewer
  than minsize live nodes in the manager, or if CUDD_REORDER_NONE is
  specified as reordering method. The calls to Cudd_ShuffleHeap are
  not counted.]

  SeeAlso     []

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{dd\_reorderingtype dd\_get\_ordering\_method (DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Gets the internal reordering method used.]

  Description [Returns the internal reordering method used.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int StringConvertToDynOrderType(char *string)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a string to a dynamic ordering method type.]

  Description [Converts a string to a dynamic ordering method type. If string
  is not "sift" or "window", then returns REORDER_.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char * DynOrderTypeConvertToString(int method)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a dynamic ordering method type to a string.]

  Description [Converts a dynamic ordering method type to a string.  This
  string must NOT be freed by the caller.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_set\_parameters(DdManager *mgr, OptsHandler\_ptr opt, FILE *file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Sets the internal parameters of the package to the given values.]

  Description [The CUDD package has a set of parameters that can be assigned
  different values. This function receives a table which maps strings to
  values and sets the parameters represented by the strings to the pertinent
  values. Some basic type checking is done. It returns 1 if everything is
  correct and 0 otherwise.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_printminterm( DdManager * manager, dd\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints a disjoint sum of products.]

  Description [Prints a disjoint sum of product cover for the function
  rooted at node. Each product corresponds to a path from node a leaf
  node different from the logical zero, and different from the
  background value. Uses the standard output.  Returns 1 if successful;
  0 otherwise.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_dump\_dot( DdManager * dd /* manager */, int n /* number of output nodes to be dumped */, dd\_ptr * f /* array of output nodes to be dumped */, const char ** inames /* array of input names (or NULL) */, const char ** onames /* array of output names (or NULL) */, FILE * fp /* pointer to the dump file */)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes a dot file representing the argument DDs.]

  Description        [Writes a file representing the argument DDs in a format
  suitable for the graph drawing program dot.

  It returns 1 in case of success; 0 otherwise (e.g., out-of-memory,
  file system full).

  Cudd_DumpDot does not close the file: This is the caller
  responsibility. Cudd_DumpDot uses a minimal unique subset of the
  hexadecimal address of a node as name for it.

  If the argument inames is non-null, it is assumed to hold the pointers
  to the names of the inputs. Similarly for onames.
  Cudd_DumpDot uses the following convention to draw arcs:
    <ul>
    <li> solid line: THEN arcs;
    <li> dotted line: complement arcs;
    <li> dashed line: regular ELSE arcs.
    </ul>

  The dot options are chosen so that the drawing fits on a letter-size
  sheet.
  ]

  SideEffects        []

  SeeAlso            [dd_dump_davinci]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int dd\_dump\_davinci( DdManager * dd /* manager */, int n /* number of output nodes to be dumped */, dd\_ptr * f /* array of output nodes to be dumped */, const char ** inames /* array of input names (or NULL) */, const char ** onames /* array of output names (or NULL) */, FILE * fp /* pointer to the dump file */)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes a daVnci file representing the argument DDs.]

  Description        [Writes a daVnci file representing the argument
  DDs. For a better description see the \"Cudd_DumpDaVinci\" documentation
  in the CUDD package.]

  SideEffects        []

  SeeAlso            [dd_dump_davinci]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_true(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reads the constant TRUE ADD of the manager.]

  Description        [Reads the constant TRUE ADD of the manager.]

  SideEffects        []

  SeeAlso            [add_false]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_then(DdManager *dd, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Returns the then child of an internal node.]

  Description  [Returns the then child of an internal node. If
  <code>f</code> is a constant node, the result is
  unpredictable. Notice that the reference count of the returned node
  is not incremented.]

  SideEffects  [none]

  SeeAlso      [add_else]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int add\_index(DdManager *dd, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the index of the node.]

  Description [Returns the index of the node.]

  SideEffects [None]

  SeeAlso []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_else(DdManager *dd, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Returns the else child of an internal node.]

  Description  [Returns the else child of an internal node. If
  <code>f</code> is a constant node, the result is
  unpredictable. Notice that the reference count of the returned node
  is not incremented.]

  SideEffects  [none]

  SeeAlso      [add_else]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_false(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reads the constant FALSE ADD of the manager.]

  Description        [Reads the constant FALSE ADD of the manager.]

  SideEffects        []

  SeeAlso            [add_true]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int add\_is\_true(DdManager * dd, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the ADD is true.]

  Description        [Check if the ADD is true.]

  SideEffects        []

  SeeAlso            [add_true]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int add\_is\_false(DdManager * dd, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the ADD is false.]

  Description        [Check if the ADD is false.]

  SideEffects        []

  SeeAlso            [add_false]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_one(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reads the constant one ADD of the manager.]

  Description        [Reads the constant one ADD of the manager.]

  SideEffects        []

  SeeAlso            [add_false]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_zero(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reads the constant zero ADD of the manager.]

  Description        [Reads the constant zero ADD of the manager.]

  SideEffects        []

  SeeAlso            [add_true]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int add\_is\_one(DdManager * dd, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the ADD is one.]

  Description        [Check if the ADD is one.]

  SideEffects        []

  SeeAlso            [add_true]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int add\_is\_zero(DdManager * dd, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the ADD is zero.]

  Description        [Check if the ADD is zero.]

  SideEffects        []

  SeeAlso            [add_false]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void add\_ref(add\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reference an ADD node.]

  Description        [Reference an ADD node.]

  SideEffects        [The reference count of the node is incremented by one.]

  SeeAlso            [add_deref add_free]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void add\_deref(add\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dereference an ADD node.]

  Description        [Dereference an ADD node.]

  SideEffects        [The reference count of the node is decremented by one.]

  SeeAlso            [add_ref add_free]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void add\_free(DdManager * dd, add\_ptr dd\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dereference an ADD node. If it dies, recursively decreases
  the reference count of its children.]

  Description        [Decreases the reference count of node. If the node dies,
  recursively decreases the reference counts of its children. It is used to
  dispose off an ADD that is no longer needed.]

  SideEffects        [The reference count of the node is decremented by one,
  and if the node dies a recursive dereferencing is applied to its children.]

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_dup(add\_ptr dd\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of an ADD node.]

  Description        [Creates a copy of an ADD node.]

  SideEffects        [The reference count is increased by one unit.]

  SeeAlso            [add_ref add_free add_deref]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_leaf(DdManager * dd, node\_ptr leaf\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an returns an ADD for constant leaf_node.]

  Description        [Retrieves the ADD for constant leaf_node if it already
  exists, or creates a new ADD.  Returns a pointer to the
  ADD if successful; fails otherwise.]

  SideEffects        [The reference count of the node is incremented by one unit.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int add\_isleaf(add\_ptr dd\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns 1 if the ADD node is a constant node.]

  Description        [Returns 1 if the ADD node is a constant node (rather than an
  internal node). All constant nodes have the same index (MAX_VAR_INDEX).]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_isleaf(bdd\_ptr dd\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns 1 if the BDD node is a constant node.]

  Description        [Returns 1 if the BDD node is a constant node (rather than an
  internal node). All constant nodes have the same index (MAX_VAR_INDEX).]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr add\_get\_leaf(DdManager * dd, add\_ptr Leaf)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the value of a constant node.]

  Description        [Returns the value of a constant node. If <code>Leaf</code>
  is an internal node, a failure occurs.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_build(DdManager * dd, int level, add\_ptr t, add\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks the unique table of the DdManager for the
  existence of an internal node.]

  Description        [Checks the unique table for the existence of an internal
  node. If it does not exist, it creates a new one. The reference
  count of whatever is returned is increased by one unit. For a newly
  created node, increments the reference counts of what T and E point
  to.  Returns a pointer to the new node if successful; a failure
  occurs if memory is exhausted or if reordering took place.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_new\_var\_with\_index(DdManager * dd, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the ADD variable with index <code>index</code>.]

  Description        [Retrieves the ADD variable with index
  <code>index</code> if it already exists, or creates a new ADD
  variable. Returns a pointer to the variable if successful; a failure
  is generated otherwise.  An ADD variable differs from a BDD variable
  because it points to the arithmetic zero, instead of having a
  complement pointer to 1. The returned value is referenced.]

  SideEffects        []

  SeeAlso            [add_new_var_at_level]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_new\_var\_at\_level(DdManager * dd, int level)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new ADD variable at a specified level.]

  Description        [Creates a new ADD variable. The new variable has an
  index equal to the largest previous index plus 1 and is positioned at
  the specified level in the order.  Returns a pointer to the new
  variable if successful; a failure is generated otherwise. The
  returned value is referenced.]

  SideEffects        []

  SeeAlso            [add_new_var_with_index]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr add\_to\_bdd(DdManager * dd, add\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts an ADD to a BDD.]

  Description [Converts an ADD to a BDD. Only TRUE and FALSE leaves
  are admitted. Returns a pointer to the resulting BDD if successful;
  NULL otherwise.]

  SideEffects []

  SeeAlso     [bdd_to_add bdd_to_01_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr add\_to\_bdd\_strict\_threshold(DdManager * dd, add\_ptr fn, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts an ADD to a BDD according to a strict threshold]

  Description [Converts an ADD to a BDD by replacing all discriminants
  greater than value k with TRUE, and all other discriminants with
  FALSE. Returns a pointer to the resulting BDD if successful; a
  failure is generated otherwise.]

  SideEffects []

  SeeAlso     [add_to_bdd_threshold add_to_bdd bdd_to_01_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr bdd\_to\_add(DdManager * dd, bdd\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a BDD to a FALSE-TRUE ADD.]

  Description [Converts a BDD to a FALSE-TRUE ADD. Returns a pointer to the
  resulting ADD if successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [add_to_bdd bdd_to_01_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr bdd\_to\_01\_add(DdManager * dd, bdd\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a BDD to a 0-1 ADD.]

  Description [Converts a BDD to a 0-1 ADD. Returns a pointer to the
  resulting ADD if successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_to_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_and(DdManager * dd, add\_ptr a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies AND to the corresponding discriminants of f and g.]

  Description [Applies logical AND to the corresponding discriminants
  of f and g. f and g must have only FALSE or TRUE as terminal
  nodes. Returns a pointer to the result if successful; a failure is
  generated otherwise.]

  SideEffects []

  SeeAlso     [add_or add_xor add_not]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_or(DdManager * dd, add\_ptr a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies OR to the corresponding discriminants of f and g.]

  Description [Applies logical OR to the corresponding discriminants
  of f and g. f and g must have only FALSE or TRUE as terminal
  nodes. Returns a pointer to the result if successful; a failure is
  generated otherwise.]

  SideEffects []

  SeeAlso     [add_and add_xor add_not add_imply]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_xor(DdManager * dd, add\_ptr a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies XOR to the corresponding discriminants of f and g.]

  Description [Applies logical XOR to the corresponding discriminants
  of f and g. f and g must have only FALSE or TRUE as terminal nodes. Returns
  a pointer to the result if successful; a failure is generated
  otherwise.]

  SideEffects []

  SeeAlso     [add_or add_and add_not add_imply]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_xnor(DdManager * dd, add\_ptr a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies XNOR to the corresponding discriminants of f and g.]

  Description [Applies logical XNOR to the corresponding discriminants
  of f and g. f and g must have only FALSE or TRUE as terminal
  nodes. Returns a pointer to the result if successful; a failure is
  generated otherwise.]

  SideEffects []

  SeeAlso     [add_xor add_or add_and add_not add_imply]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_not(DdManager * dd, add\_ptr a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies NOT to the corresponding discriminant of f.]

  Description [Applies logical NOT to the corresponding discriminant
  of f.  f must have only FALSE or TRUE as terminal nodes. Returns a
  pointer to the result if successful; a failure is generated
  otherwise.]

  SideEffects []

  SeeAlso     [add_and add_xor add_or add_imply]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_implies(DdManager * dd, add\_ptr a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies IMPLY to the corresponding discriminants of f and g.]

  Description [Applies logical IMPLY to the corresponding
  discriminants of f and g.  f and g must have only FALSE or TRUE as
  terminal nodes. Returns a pointer to the result if successful; a
  failure is generated otherwise.]

  SideEffects []

  SeeAlso     [add_and add_xor add_or add_not]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_iff(DdManager * dd, add\_ptr a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies IFF to the corresponding discriminants of f and g.]

  Description [Applies logical IFF to the corresponding discriminants
  of f and g.  f and g must have only FALSE or TRUE as terminal
  nodes. Returns a pointer to the result if successful; a failure is
  generated otherwise.]

  SideEffects []

  SeeAlso     [add_and add_xor add_or add_not]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void add\_and\_accumulate(DdManager * dd, add\_ptr *a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies AND to the corresponding discriminants of f and g.]

  Description [Applies logical AND to the corresponding discriminants
  of f and g and stores the result in f. f and g must have only FALSE
  or TRUE as terminal nodes.]

  SideEffects [The result is stored in the first operand.]

  SeeAlso     [add_and]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void add\_or\_accumulate(DdManager * dd, add\_ptr *a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies OR to the corresponding discriminants of f and g.]

  Description [Applies logical OR to the corresponding discriminants
  of f and g and stores the result in f. f and g must have only FALSE
  or TRUE as terminal nodes.]

  SideEffects [The result is stored in the first operand.]

  SeeAlso     [add_and]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_apply(DdManager * dd, NPFNN op, add\_ptr f, add\_ptr g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies binary op to the corresponding discriminants of f and g.]

  Description [Returns a pointer to the result if successful; a failure is
  generated otherwise.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_monadic\_apply(DdManager * dd, NPFNN/*NPFCVT*/ op, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies unary op to the corresponding discriminant of f]

  Description [Returns a pointer to the result if successful; a failure is
  generated otherwise.

  NOTE: At the moment CUDD does not have unary 'apply', so you have
  to provide a binary op, which is actually unary and applies to
  the first operand only.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_exist\_abstract(DdManager* dd, add\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Abstracts away variables from an ADD.]

  Description        [Abstracts away variables from an ADD, summing up the values
                      of the merged branches.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_ifthenelse(DdManager * dd, add\_ptr If, add\_ptr Then, add\_ptr Else)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Implements ITE(f,g,h).]

  Description [Implements ITE(f,g,h). This procedure assumes that f is
  a FALSE-TRUE ADD.  Returns a pointer to the resulting ADD if
  successful; a failure is generated otherwise.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_cube\_diff(DdManager * dd, add\_ptr a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes the difference between two ADD cubes.]

  Description [Computes the difference between two ADD cubes, i.e. the
  cube of ADD variables belonging to cube a and not belonging to cube
  b. Returns a pointer to the resulting cube; a failure is generated
  otherwise.]

  SideEffects []

  SeeAlso     [bdd_cube_diff]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_permute(DdManager * dd, add\_ptr fn, int * permut)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Permutes the variables of an ADD.]

  Description [Given a permutation in array permut, creates a new ADD
  with permuted variables. There should be an entry in array permut
  for each variable in the manager. The i-th entry of permut holds the
  index of the variable that is to substitute the i-th variable.
  Returns a pointer to the resulting ADD if successful; a failure is
  generated otherwise. The reuslt is referenced.]

  SideEffects []

  SeeAlso     [bdd_permute]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_support(DdManager * dd, add\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finds the variables on which an ADD depends on.]

  Description [Finds the variables on which an ADD depends on.
  Returns an ADD consisting of the product of the variables if
  successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_support]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_simplify\_assuming(DdManager * dd, add\_ptr a, add\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [ADD restrict according to Coudert and Madre's algorithm (ICCAD90).]

  Description [ADD restrict according to Coudert and Madre's algorithm
  (ICCAD90). Returns the restricted ADD if successful; a failure is
  generated otherwise.
  If application of restrict results in an ADD larger than the input
  ADD, the input ADD is returned.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int add\_size(DdManager * dd, add\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Counts the number of ADD nodes in an ADD.]

  Description [Counts the number of ADD nodes in an ADD. Returns the number
  of nodes in the graph rooted at node.]

  SideEffects []

  SeeAlso     [add_count_minterm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double add\_count\_minterm(DdManager * dd, add\_ptr fn, int nvars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Counts the number of ADD minterms of an ADD.]

  Description [Counts the number of minterms of an ADD. The function is
  assumed to depend on nvars variables. The minterm count is
  represented as a double, to allow for a larger number of variables.
  Returns the number of minterms of the function rooted at node. The
  result is parameterized by the number of \"nvars\" passed as argument.]

  SideEffects []

  SeeAlso     [bdd_size bdd_count_minterm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr add\_value(DdManager * dd, add\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Given the result of add_if_then it returns the leaf corresponding.]

  Description [Given the result of add_if_then it returns the leaf
  corresponding. The ADD is traversed according to the rules given as
  a result of add_if_then. If it is costant, then the corresponding
  value is returned. The Else branch is recursively traversed, if the
  result of this travesring is an ELSE_CNST, then the result of the
  traversing of the Then branch is returned.]

  SideEffects []

  SeeAlso     [add_if_then]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr add\_if\_then(DdManager * dd, add\_ptr I, add\_ptr T)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Given a minterm, it returns an ADD indicating the rules
  to traverse the ADD.]

  Description [Given a minterm, it returns an ADD indicating the rules
  to traverse the ADD.]

  SideEffects []

  SeeAlso     [add_value]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void add\_walkleaves(VPFCVT op, add\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies a generic function to constant nodes.]

  Description [Applies a generic function <tt>VPFCVT op</tt> to the
  constants nodes of <tt>f</tt>.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_true(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reads the constant TRUE BDD of the manager.]

  Description        [Reads the constant TRUE BDD of the manager.]

  SideEffects        []

  SeeAlso            [bdd_false]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_false(DdManager * dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reads the constant FALSE BDD of the manager.]

  Description        [Reads the constant FALSE BDD of the manager.]

  SideEffects        []

  SeeAlso            [bdd_true]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_is\_true(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the BDD is TRUE.]

  Description        [Check if the BDD is TRUE.]

  SideEffects        []

  SeeAlso            [bdd_true]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_isnot\_true(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the BDD is not true.]

  Description        [Check if the BDD is not true.]

  SideEffects        []

  SeeAlso            [bdd_true]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_is\_false(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the BDD is false.]

  Description        [Check if the BDD is false.]

  SideEffects        []

  SeeAlso            [bdd_false]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_isnot\_false(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the BDD is not false.]

  Description        [Check if the BDD is not false.]

  SideEffects        []

  SeeAlso            [bdd_false]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_ref(bdd\_ptr dd\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reference an BDD node.]

  Description        [Reference an BDD node.]

  SideEffects        [The reference count of the node is incremented by one.]

  SeeAlso            [bdd_deref bdd_free]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_deref(bdd\_ptr dd\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dereference an BDD node.]

  Description        [Dereference an BDD node.]

  SideEffects        [The reference count of the node is decremented by one.]

  SeeAlso            [bdd_ref bdd_free]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_free(DdManager * dd, bdd\_ptr dd\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dereference an BDD node. If it dies, recursively decreases
  the reference count of its children.]

  Description        [Decreases the reference count of node. If the node dies,
  recursively decreases the reference counts of its children. It is used to
  dispose off a BDD that is no longer needed.]

  SideEffects        [The reference count of the node is decremented by one,
  and if the node dies a recursive dereferencing is applied to its children.]

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_dup(bdd\_ptr dd\_node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of an BDD node.]

  Description        [Creates a copy of an BDD node.]

  SideEffects        [The reference count is increased by one unit.]

  SeeAlso            [bdd_ref bdd_free bdd_deref]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_not(DdManager * dd, bdd\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies NOT to the corresponding discriminant of f.]

  Description [Applies logical NOT to the corresponding discriminant of f.
  f must be a BDD. Returns a pointer to the result if successful; a
  failure is generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_and bdd_xor bdd_or bdd_imply]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_and(DdManager * dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies AND to the corresponding discriminants of f and g.]

  Description [Applies logical AND to the corresponding discriminants
  of f and g. f and g must be BDDs. Returns a pointer to the result if
  successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_or bdd_xor bdd_not]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_or(DdManager * dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies OR to the corresponding discriminants of f and g.]

  Description [Applies logical OR to the corresponding discriminants
  of f and g. f and g must be BDDs. Returns a pointer to the result if
  successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_and bdd_xor bdd_not]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_xor(DdManager * dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies XOR to the corresponding discriminants of f and g.]

  Description [Applies logical XOR to the corresponding discriminants
  of f and g. f and g must be BDDs. Returns a pointer to the result if
  successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_or bdd_imply bdd_not]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_iff(DdManager * dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies IFF to the corresponding discriminants of f and g.]

  Description [Applies logical IFF to the corresponding discriminants
  of f and g. f and g must be BDDs. Returns a pointer to the result if
  successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_or bdd_xor bdd_not]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_imply(DdManager * dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies IMPLY to the corresponding discriminants of f and g.]

  Description [Applies logical IMPLY to the corresponding discriminants
  of f and g. f and g must be BDDs. Returns a pointer to the result if
  successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_or bdd_xor bdd_not]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_and\_accumulate(DdManager * dd, bdd\_ptr * a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies AND to the corresponding discriminants of f and g.]

  Description [Applies logical AND to the corresponding discriminants
  of f and g and stores the result in f. f and g must be two BDDs. The
  result is referenced.]

  SideEffects [The result is stored in the first operand and referenced.]

  SeeAlso     [bdd_and]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_or\_accumulate(DdManager * dd, bdd\_ptr * a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Applies OR to the corresponding discriminants of f and g.]

  Description [Applies logical OR to the corresponding discriminants
  of f and g and stores the result in f. f and g must be two BDDs. The
  result is referenced.]

  SideEffects [The result is stored in the first operand and referenced.]

  SeeAlso     [bdd_and]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_forsome(DdManager * dd, bdd\_ptr fn, bdd\_ptr cube)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Existentially abstracts all the variables in cube from fn.]

  Description [Existentially abstracts all the variables in cube from fn.
  Returns the abstracted BDD if successful; a failure is generated
  otherwise.]

  SideEffects []

  SeeAlso     [bdd_forall]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_forall(DdManager * dd, bdd\_ptr fn, bdd\_ptr cube)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Universally abstracts all the variables in cube from f.]

  Description [Universally abstracts all the variables in cube from f.
  Returns the abstracted BDD if successful; a failure is generated
  otherwise.]

  SideEffects []

  SeeAlso     [bdd_forsome]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_permute(DdManager * dd, bdd\_ptr fn, int * permut)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Permutes the variables of a BDD.]

  Description [Given a permutation in array permut, creates a new BDD
  with permuted variables. There should be an entry in array permut
  for each variable in the manager. The i-th entry of permut holds the
  index of the variable that is to substitute the i-th variable.
  Returns a pointer to the resulting BDD if successful; a failure is
  generated otherwise. The result is referenced.]

  SideEffects []

  SeeAlso     [bdd_permute]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_and\_abstract(DdManager *dd, bdd\_ptr T, bdd\_ptr S, bdd\_ptr V)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Takes the AND of two BDDs and simultaneously abstracts the
  variables in cube.]

  Description [Takes the AND of two BDDs and simultaneously abstracts
  the variables in cube. The variables are existentially abstracted.
  Returns a pointer to the result if successful; a failure is
  generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_and bdd_forsome]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_simplify\_assuming(DdManager *dd, bdd\_ptr fn, bdd\_ptr c)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [BDD restrict according to Coudert and Madre's algorithm
  (ICCAD90).]

  Description [BDD restrict according to Coudert and Madre's algorithm
  (ICCAD90). Returns the restricted BDD if successful; a failure is
  generated otherwise.
  If application of restrict results in an BDD larger than the input
  BDD, the input BDD is returned.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_minimize(DdManager *dd, bdd\_ptr fn, bdd\_ptr c)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Restrict operator as described in Coudert et al. ICCAD90.]

  Description [Restrict operator as described in Coudert et
  al. ICCAD90.  Always returns a BDD not larger than the input
  <code>f</code> if successful; a failure is generated otherwise. The
  result is referenced.]

  SideEffects []

  SeeAlso     [bdd_simplify_assuming]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_cofactor(DdManager * dd, bdd\_ptr f, bdd\_ptr g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes f constrain c.]

  Description [Computes f constrain c (f @ c).
  Uses a canonical form: (f' @ c) = ( f @ c)'.  (Note: this is not true
  for c.)  List of special cases:
    <ul>
    <li> F @ 0 = 0
    <li> F @ 1 = F
    <li> 0 @ c = 0
    <li> 1 @ c = 1
    <li> F @ F = 1
    <li> F @ F'= 0
    </ul>
  Returns a pointer to the result if successful; a failure is
  generated otherwise.]

  SideEffects []

  SeeAlso     [bdd_minimize bdd_simplify_assuming]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_between(DdManager *dd, bdd\_ptr f\_min, bdd\_ptr f\_max)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Return a minimum size BDD between bounds.]

  SideEffects []

  SeeAlso     [bdd_minimize bdd_simplify_assuming bdd_cofactor]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_entailed(DdManager * dd, bdd\_ptr f, bdd\_ptr g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Determines whether f is less than or equal to g.]

  Description        [Returns 1 if f is less than or equal to g; 0 otherwise.
  No new nodes are created.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_intersected(DdManager * dd, bdd\_ptr f, bdd\_ptr g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Determines whether an intersection between
  f and g is not empty]

  Description        [Returns 1 if an intersection between
  f and g is not empty; 0 otherwise.
  No new nodes are created.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_then(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the then child of a bdd node.]

  Description        [Returns the then child of a bdd node. The node
  must not be a leaf node. Notice that this funxction does not save
  the bdd. Is the responsibility of the user to save it if it is the case.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_else(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the else child of a bdd node.]

  Description        [Returns the else child of a bdd node. The node
  must not be a leaf node. Notice that this funxction does not save
  the bdd. Is the responsibility of the user to save it if it is the case.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_iscomplement(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns 1 if the BDD pointer is complemented.]

  Description        [Returns 1 if the BDD pointer is complemented.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_readperm(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Finds the current position of variable index in the
  order.]

  Description        [Finds the current position of variable index in the
  order.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_index(DdManager * dd, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the index of the node.]

  Description        [Returns the index of the node.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_ite(DdManager * dd, bdd\_ptr i, bdd\_ptr t, bdd\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements ITE(i,t,e).]

  Description        [Implements ITE(i,t,e). Returns a pointer to the
  resulting BDD if successful;  a failure is
  generated otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_size(DdManager * dd, bdd\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Counts the number of BDD nodes in an BDD.]

  Description [Counts the number of BDD nodes in an BDD. Returns the number
  of nodes in the graph rooted at node.]

  SideEffects []

  SeeAlso     [bdd_count_minterm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double bdd\_count\_minterm(DdManager * dd, bdd\_ptr fn, int nvars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Counts the number of BDD minterms of an BDD.]

  Description [Counts the number of minterms of an BDD. The function is
  assumed to depend on nvars variables. The minterm count is
  represented as a double, to allow for a larger number of variables.
  Returns the number of minterms of the function rooted at node. The
  result is parameterized by the number of \"nvars\" passed as argument.]

  SideEffects []

  SeeAlso     [bdd_size bdd_count_minterm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_support(DdManager *dd, bdd\_ptr fn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finds the variables on which an BDD depends on.]

  Description [Finds the variables on which an BDD depends on.
  Returns an BDD consisting of the product of the variables if
  successful; a failure is generated otherwise.]

  SideEffects []

  SeeAlso     [add_support]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_pick\_one\_minterm(DdManager * dd, bdd\_ptr fn, bdd\_ptr * vars, int n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Picks one on-set minterm deterministically from the given BDD.]

  Description [Picks one on-set minterm deterministically from the
  given DD. The minterm is in terms of vars. Builds a BDD for the
  minterm and returns a pointer to it if successful; a failure is
  generated otherwise. There are two reasons why the procedure may fail: It may
  run out of memory; or the function fn may be the constant 0. The
  result is referenced.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_pick\_one\_minterm\_rand(DdManager * dd, bdd\_ptr fn, bdd\_ptr * vars, int n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Picks one on-set minterm randomly from the given DD.]

  Description [Picks one on-set minterm randomly from the given DD. The
  minterm is in terms of vars. Builds a BDD for the minterm and returns a
  pointer to it if successful; a failure is generated otherwise. There
  are two reasons why the procedure may fail: It may run out of
  memory; or the function f may be the constant 0.]

  SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_pick\_all\_terms( DdManager * dd /* dd manager */, bdd\_ptr pick\_from\_set /* minterm from which to pick all term */, bdd\_ptr * vars /* The array of vars to be put in the returned array */, int vars\_dim /* The size of the above array */, bdd\_ptr * result /* The array used as return value */, int result\_dim /* The size of the above array */)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the array of All Possible Minterms]

  Description        [Takes a minterm and returns an array of all its terms,
  according to variables specified in the array vars[].  Notice that the array
  of the result has to be previously allocated, and its size must be greater
  or equal the number of the minterms of the "minterm" function. The array
  contains referenced BDD so it is necessary to dereference them after their
  use. Calls Cudd_PickAllTerms avoiding to pass it a true picking-from set of
        states.]

  SideEffects        []

  SeeAlso            [bdd_pick_one_minterm_rand bdd_pick_one_minterm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_new\_var\_with\_index(DdManager * dd, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the BDD variable with index <code>index</code>.]

  Description        [Retrieves the BDD variable with index <code>index</code>
  if it already exists, or creates a new BDD variable. Returns a
  pointer to the variable if successful; a failure is generated
  otherwise. The returned value is referenced.]

  SideEffects        []

  SeeAlso            [bdd_new_var_at_level add_new_var_at_level]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_cube\_diff(DdManager * dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes the difference between two BDD cubes.]

  Description [Computes the difference between two BDD cubes, i.e. the
  cube of BDD variables belonging to cube a and not belonging to cube
  b. Returns a pointer to the resulting cube; a failure is generated
  otherwise.]

  SideEffects []

  SeeAlso     [add_cube_diff]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_cube\_union(DdManager * dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes the union between two BDD cubes.]

  Description [Computes the union between two BDD cubes, i.e. the
  cube of BDD variables belonging to cube a OR to cube b.
  Returns a pointer to the resulting cube; a failure is generated
  otherwise.]

  SideEffects []

  SeeAlso     [bdd_cube_intersection,bdd_and]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_cube\_intersection(DdManager * dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes the intersection between two BDD cubes.]

  Description [Computes the difference between two BDD cubes, i.e. the
  cube of BDD variables belonging to cube a AND belonging to cube
  b. Returns a pointer to the resulting cube; a failure is generated
  otherwise.]

  SideEffects []

  SeeAlso     [bdd_cube_union,bdd_cube_diff]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_get\_lowest\_index(DdManager * dd, bdd\_ptr a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the index of the lowest variable in the BDD a.]

  Description        [Returns the index of the lowest variable in the
  BDD, i.e. the variable in BDD a with the highest position in the
  ordering. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_get\_one\_sparse\_sat(DdManager * dd, bdd\_ptr d)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Finds a satisfying path in the BDD d.]

  Description        [Finds a satisfying path in the BDD d. This path should
  not include all variabales. It only need ot include the levels needed to
  satify the BDD.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_make\_prime(DdManager *dd, bdd\_ptr cube, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Expands cube to a prime implicant of f.]

  Description [Expands cube to a prime implicant of f. Returns the prime
  if successful; NULL otherwise.  In particular, NULL is returned if cube
  is not a real cube or is not an implicant of f.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_largest\_cube(DdManager *dd, bdd\_ptr b, int *length)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finds a largest cube in a BDD.]

  Description [Finds a largest cube in a BDD b, i.e. an implicant of BDD b.
  Notice that, it is not guaranteed to be the largest implicant of b.]

  SideEffects [The number of literals of the cube is returned in length.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_compute\_prime\_low(DdManager * dd, bdd\_ptr b, bdd\_ptr low)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finds a prime implicant for a BDD.]

  Description [Finds the prime implicant of a BDD b based on the largest cube
  in low where low implies b.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t * bdd\_compute\_primes\_low(DdManager * dd, bdd\_ptr b, bdd\_ptr low)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finds a set of prime implicants for a BDD.]

  Description [Finds the set of prime implicants of a BDD b that are
  implied by low where low implies b.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t * bdd\_compute\_primes(DdManager * dd, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finds a set of prime implicants for a BDD.]

  Description [Finds the set of prime implicants of a BDD b.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_compute\_essentials(DdManager *dd, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finds the essential variables of a DD.]

  Description [Returns the cube of the essential variables. A positive
  literal means that the variable must be set to 1 for the function to be
  1. A negative literal means that the variable must be set to 0 for the
  function to be 1. Returns a pointer to the cube BDD if successful;
  NULL otherwise.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_leq(DdManager *dd, bdd\_ptr f, bdd\_ptr g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Determines whether f is less than or equal to g.]

  Description [Returns 1 if f is less than or equal to g; 0 otherwise.
  No new nodes are created.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_swap\_variables(DdManager *dd, bdd\_ptr f, bdd\_ptr *x\_varlist, bdd\_ptr *y\_varlist, int n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Swaps two sets of variables of the same size (x and y) in
  the BDD f.]

  Description [Swaps two sets of variables of the same size (x and y)
  in the BDD f. The size is given by n. The two sets of variables are
  assumed to be disjoint.  Returns a pointer to the resulting BDD if
  successful; an error (which either results in a jump to the last CATCH-FAIL
  block, or in a call to exit()) is triggered otherwise.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_DumpBlif( DdManager* dd /* manager */, int n /* number of output nodes to be dumped */, bdd\_ptr* f /* array of output nodes to be dumped */, char** inames /* array of input names (or NULL) */, char** onames /* array of output names (or NULL) */, char* mname /* model name (or NULL) */, FILE* fp /* pointer to the dump file */)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Writes a blif file representing the argument BDDs.]

  Description [Writes a blif file representing the argument BDDs as a
  network of multiplexers. One multiplexer is written for each BDD
  node. It returns 1 in case of success; 0 otherwise (e.g.,
  out-of-memory, file system full, or an ADD with constants different
  from 0 and 1).  bdd_DumpBlif does not close the file: This is the
  caller responsibility. bdd_DumpBlif uses a minimal unique subset of
  the hexadecimal address of a node as name for it.  If the argument
  inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames.]

  SideEffects [None]

  SeeAlso     [bdd_DumpBlifBody dd_dump_dot]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_DumpBlifBody( DdManager* dd /* manager */, int n /* number of output nodes to be dumped */, bdd\_ptr* f /* array of output nodes to be dumped */, char** inames /* array of input names (or NULL) */, char** onames /* array of output names (or NULL) */, FILE* fp /* pointer to the dump file */)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Writes a blif body representing the argument BDDs.]

  Description [Writes a blif body representing the argument BDDs as a
  network of multiplexers.  No header (.model, .inputs, and .outputs) and
  footer (.end) are produced by this function.  One multiplexer is written
  for each BDD node. It returns 1 in case of success; 0 otherwise (e.g.,
  out-of-memory, file system full, or an ADD with constants different
  from 0 and 1).  bdd_DumpBlifBody does not close the file: This is the
  caller responsibility. bdd_DumpBlifBody uses a minimal unique subset of
  the hexadecimal address of a node as name for it.  If the argument
  inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames. This function prints out only
  .names part.]

  SideEffects [None]

  SeeAlso     [bdd_DumpBlif dd_dump_dot]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr bdd\_compose(DdManager *dd, bdd\_ptr f, bdd\_ptr g, int v)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Substitutes g for x_v in the BDD for f.]

  Description [Substitutes g for x_v in the BDD for f. v is the index of the
  variable to be substituted. bdd_compose passes the corresponding
  projection function to the recursive procedure, so that the cache may
  be used.  Returns the composed BDD if successful; an error (which either
  results in a jump to the last CATCH-FAIL  block, or in a call to exit())
  is triggered otherwise.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int bdd\_ref\_count(bdd\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the reference count of a node.]

  Description [Returns the reference count of a node. The node pointer can be
  either regular or complemented.]

  SideEffects [None]

  SeeAlso []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int calculate\_bdd\_value(DdManager* mgr, bdd\_ptr f, int* values)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes the value of a function with given variable values.]

  Description [Computes the value (0 or 1) of the given function with the given
  values for variables. The parameter "values" must be an array, at least as
  long as the number of indices in the BDD.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void InvalidType(FILE *file, char *field, char *expected)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Function to print a warning that an illegal value was read.]

  SideEffects        []

  SeeAlso            [bdd_set_parameters]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ddCmd.c}
		
	\texttt{int CommandDynamicVarOrdering(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the dynamic_var_ordering command.]

  CommandName        [dynamic_var_ordering] 	   

  CommandSynopsis    [Deals with the dynamic variable ordering.]  

  CommandArguments   [\[-d\] \[-e &lt;method&gt;\] \[-f &lt;method&gt;\] \[-h\]]  

  CommandDescription [
  Controls the application and the modalities of (dynamic) variable
  ordering. Dynamic ordering is a technique to reorder the BDD variables
  to reduce the size of the existing BDDs. When no options are specified,
  the current status of dynamic ordering is displayed. At most one of the
  options <tt>-e</tt>, <tt>-f</tt>, and <tt>-d</tt> should be specified.<p>

  Dynamic ordering may be time consuming, but can often reduce the size of
  the BDDs dramatically. A good point to invoke dynamic ordering
  explicitly (using the <tt>-f</tt> option) is after the commands
  <tt>build_model</tt>, once the transition relation has been built.  It is
  possible to save the ordering found using <tt>write_order</tt> in order to
  reuse it (using <tt>build_model -i order-file</tt>) in the future.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-d</tt>
       <dd> Disable dynamic ordering from triggering automatically.
    <dt> <tt>-e &lt;method&gt;</tt>
       <dd> Enable dynamic ordering to trigger automatically whenever a
            certain threshold on the overall BDD size is reached.
            <tt>&lt;method&gt;</tt> must be one of the following:
            <ul>
            <li> <b>sift</b>: Moves each variable throughout the order to
                 find an optimal position for that variable (assuming all
                 other variables are fixed).  This generally achieves
                 greater size reductions than the window method, but is slower.
            <li> <b>random</b>: Pairs of variables are randomly chosen, and
                 swapped in the order. The swap is performed by a series of
                 swaps of adjacent variables. The best order among those
                 obtained by the series of swaps is retained. The number of
                 pairs chosen for swapping equals the number of variables
                 in the diagram.
            <li> <b>random_pivot</b>: Same as <b>random</b>, but the two
                 variables are chosen so that the first is above the
                 variable with the largest number of nodes, and the second
                 is below that variable.  In case there are several
                 variables tied for the maximum number of nodes, the one
                 closest to the root is used.
            <li> <b>sift_converge</b>: The <b>sift</b> method is iterated
                 until no further improvement is obtained.
            <li> <b>symmetry_sift</b>: This method is an implementation of
                 symmetric sifting. It is similar to sifting, with one
                 addition: Variables that become adjacent during sifting are
                 tested for symmetry. If they are symmetric, they are linked
                 in a group. Sifting then continues with a group being
                 moved, instead of a single variable.
            <li> <b>symmetry_sift_converge</b>: The <b>symmetry_sift</b>
                 method is iterated until no further improvement is obtained.
            <li> <b>window{2,3,4}</b>: Permutes the variables within windows
                 of "n" adjacent variables, where "n" can be either 2, 3 or 4,
                 so as to minimize the overall BDD size.<p>
            <li> <b>window{2,3,4}_converge</b>: The <b>window{2,3,4}</b> method
                 is iterated until no further improvement is obtained.
            <li> <b>group_sift</b>: This method is similar to
                 <b>symmetry_sift</b>, but uses more general criteria to
                 create groups.
            <li> <b>group_sift_converge</b>: The <b>group_sift</b> method is
                 iterated until no further improvement is obtained.
            <li> <b>annealing</b>: This method is an implementation of
                 simulated annealing for variable ordering. This method is
                 potentially very slow.
            <li> <b>genetic</b>: This method is an implementation of a
                 genetic algorithm for variable ordering. This method is
                 potentially very slow.
            <li> <b>exact</b>: This method implements a dynamic programming
                 approach to exact reordering. It only stores a BDD
                 at a time. Therefore, it is relatively efficient in
                 terms of memory. Compared to other reordering
                 strategies, it is very slow, and is not recommended
                 for more than 16 boolean variables.
            <li> <b>linear</b>: This method is a combination of
                 sifting and linear transformations.
            <li> <b>linear_converge</b>: The <b>linear</b> method is
                 iterated until no further improvement is obtained.
            </ul><br>
    <dt> <tt>-f &lt;method&gt;</tt>
     <dd> Force dynamic ordering to be invoked immediately. The values for
          <tt>&lt;method&gt;</tt> are the same as in option <tt>-e</tt>.
  </dl>]  

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandSetBddParameters(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Implements the set_bdd_parameters command.]

  SideEffects []

  CommandName [set_bdd_parameters]

  CommandSynopsis [Creates a table with the value of all currently
  active NuSMV flags and change accordingly the configurable parameters
  of the BDD package.]

  CommandArguments [\[-h\] \[-s\]]

  CommandDescription [Applies the variables table of the NuSMV environnement
  to the BDD package, so the user can set specific BDD parameters to the 
  given value. This command works in conjunction with the 
  <tt>print_bdd_stats</tt> and <tt>set</tt> commands.<p>

  <tt>print_bdd_stats</tt> first prints a report of the parameters and
  statistics of the current bdd_manager. By using the command <tt>set</tt>,
  the user may modify the value of any of the parameters of the
  underlying BDD package. The way to do it is by setting a value in
  the variable <tt>BDD.parameter name</tt> where <tt>parameter
  name</tt> is the name of the parameter exactly as printed by the
  <tt>print_bdd_stats</tt> command.<p>

  Command options:<p>

  <dl>
    <dt> -s
       <dd> Prints the BDD parameter and statistics after the modification.

  </dl>
  ]
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandPrintBddStats(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Implements the print_bdd_stats command.]

  SideEffects []

  CommandName [print_bdd_stats]

  CommandSynopsis [Prints out the BDD statistics and parameters]

  CommandArguments [\[-h\]]

  CommandDescription [Prints the statistics for the BDD package. The
  amount of information depends on the BDD package configuration
  established at compilation time. The configurtion parameters are
  printed out too. More information about statistics and parameters
  can be found in the documentation of the CUDD Decision Diagram
  package.]
  
******************************************************************************/

	\end{verbatimtab}
	
	\section{enc}
		
	\section{base}
		
	\subsection{BaseEnc.c}
		
	\texttt{VIRTUAL void BaseEnc\_destroy(BaseEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseEnc class destructor]

  Description        [The BaseEnc class destructor. Since this class is pure
  there is no constructor.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BaseEnc\_layer\_occurs(const BaseEnc\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true whether the given layer name is the
  name of a layer that is currently committed to self.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr BaseEnc\_get\_committed\_layers(const BaseEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of the committed layers]

  Description [Returned list is a list of SymbLayer instances. The
  returned list is ordered wrt to layers insert policy. The list and
  its content still belongs to self, do not destroy or change it]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const array\_t* BaseEnc\_get\_committed\_layer\_names(BaseEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of names of the committed layers]

  Description [Returned array belongs to self. Do not store it
  permanently, change or delete it. If you commit or remove a
  layer into self, any previoulsy returned array will become
  invalid.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr BaseEnc\_get\_symb\_table(const BaseEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the SymbTable that self uses]

  Description [Returns the SymbTable that self uses. Returned instance
  belongs to self, do not destroy it.]

  SideEffects        []

  SeeAlso            [BaseEnc_get_type_checker]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TypeChecker\_ptr BaseEnc\_get\_type\_checker(const BaseEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the type checker instance owned by the
                      SymbTable that self uses]

  Description        [Returns the type checker instance owned by the
                      SymbTable that self uses. Returned instance
                      belongs to self, do not destroy it.]

  SideEffects        []

  SeeAlso            [BaseEnc_get_symb_table]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void BaseEnc\_commit\_layer(BaseEnc\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to enter a new layer. All variables
  occurring in the layer, will be encoded as a result.]

  Description        [This method is virtual. The result of the encoding
  depends on the actual instance (its actual class) it is invoked on.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void BaseEnc\_remove\_layer(BaseEnc\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this method to remove an already committed layer.
  All variables occurring in the layer will be removed as a result. It will no
  longer allowed to use those variables within expressions encoded by self]

  Description        [This method is virtual. The result of the removal
  depends on the actual instance (its actual class) it is invoked on.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void base\_enc\_init(BaseEnc\_ptr self, SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseEnc class private initializer]

  Description        [The BaseEnc class private initializer]

  SideEffects        []

  SeeAlso            [BaseEnc_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void base\_enc\_deinit(BaseEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseEnc class private deinitializer]

  Description        [The BaseEnc class private deinitializer]

  SideEffects        []

  SeeAlso            [BaseEnc_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void base\_enc\_commit\_layer(BaseEnc\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Register and store a new layer to be committed]

  Description        [This method must always be called by derived classes]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void base\_enc\_remove\_layer(BaseEnc\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Unregister and remove from the list of layers
  the given layer.]

  Description [This method must always be called by derived methods,
  after they have done their work.

  WARNING: If the layer has been
  renamed after having been committed, it is the *new* name (the name
  the layer has when it is being removed) that must be used, and *not*
  the name that had been used when commiting it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void base\_enc\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The BaseEnc class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{BoolEncClient.c}
		
	\texttt{void BoolEncClient\_destroy(BoolEncClient\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolEncClient class destructor]

  Description [The BoolEncClient class destructor. Since this class is
  pure, only a virtual destructor is provided, and there is no
  constructor]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BoolEnc\_ptr BoolEncClient\_get\_bool\_enc(const BoolEncClient\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the contained (used) BoolEnc instance]

  Description        [REturned instance belongs to self, do not 
  destroy it.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_enc\_client\_init(BoolEncClient\_ptr self, SymbTable\_ptr symb\_table, BoolEnc\_ptr bool\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolEncClient class private initializer]

  Description        [The BoolEncClient class private initializer]

  SideEffects        []

  SeeAlso            [BoolEncClient_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_enc\_client\_deinit(BoolEncClient\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolEncClient class private deinitializer]

  Description        [The BoolEncClient class private deinitializer]

  SideEffects        []

  SeeAlso            [BoolEncClient_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_enc\_client\_commit\_layer(BaseEnc\_ptr base\_enc, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks that the given layer occurs within the used bool 
  encoder, and then adds this layer to the set of committed layers. ]

  Description        [This method must always be called by derived classes]

  SideEffects        []

  SeeAlso            [BoolEncClient_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_enc\_client\_remove\_layer(BaseEnc\_ptr base\_enc, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        [This method must always be called by the derived classes 
  overrode method]

  SideEffects        []

  SeeAlso            [BoolEncClient_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bool\_enc\_client\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The BoolEncClient class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{bdd}
		
	\subsection{BddEnc.c}
		
	\texttt{BddEnc\_ptr BddEnc\_create(SymbTable\_ptr symb\_table, BoolEnc\_ptr bool\_enc, VarsHandler\_ptr dd\_vars\_hndr, OrdGroups\_ptr ord\_groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The BddEnc class constructor]

   Description [The BddEnc class constructor. ord_groups can be NULL if
   ordering is not used. self become the owner of the given ord_groups
   instance]

   SideEffects        []

   SeeAlso            [BddEnc_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void BddEnc\_destroy(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The BddEnc class destructor]

   Description        [The BddEnc class destructor]

   SideEffects        []

   SeeAlso            [BddEnc_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VarsHandler\_ptr BddEnc\_get\_dd\_vars\_handler(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Gets the DD vars handler this encoding refers to.]

   Description        [Gets the DD vars handler this encoding refers to.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{DdManager* BddEnc\_get\_dd\_manager(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Gets the DD manager this encoding refers to.]

   Description        [Gets the DD manager this encoding refers to.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{OrdGroups\_ptr BddEnc\_get\_ord\_groups(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns the internally used order that was specified
   when creating the instance. Order is used when committing a layer and
   when forcing a reordering]

   Description [Can be NULL. The returned instance belongs to
   self. Do not change it if you do not know well what you are
   doing.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddVarSet\_ptr BddEnc\_get\_state\_vars\_cube(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Gets the support of the set of state variables]

   Description        [Returned bdd is referenced, the caller must free it after
   it is no longer used. Result is cached if not previously converted from
   internal ADD representation.  Returns NULL if an error occurred.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddVarSet\_ptr BddEnc\_get\_next\_state\_vars\_cube(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Gets the support of the set of next-state variables]

   Description        [Returned bdd is referenced, the caller must free it after
   it is no longer used.  Result is cached if not previously converted from
   internal ADD representation. Returns NULL if an error occurred. ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddVarSet\_ptr BddEnc\_get\_frozen\_vars\_cube(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Gets the support of the set of frozen variables]

   Description        [Returned bdd is referenced, the caller must free it after
   it is no longer used.  Result is cached if not previously converted from
   internal ADD representation. Returns NULL if an error occurred. ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddVarSet\_ptr BddEnc\_get\_state\_frozen\_vars\_cube(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Gets the support of the set of state and frozen variables]

   Description        [The result is a conjunct of BddEnc_get_state_vars_cube and
   BddEnc_get_frozen_vars_cube.

   Returned bdd is referenced, the caller must free it after
   it is no longer used.  Result is cached if not previously converted from
   internal ADD representation. Returns NULL if an error occurred. ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddVarSet\_ptr BddEnc\_get\_input\_vars\_cube(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Gets the support of the set of input variables]

   Description        [Returned bdd is referenced, the caller must free it after
   it is no longer used.  Result is cached if not previously converted from
   internal ADD representation.  Returns NULL if an error occurred. ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddVarSet\_ptr BddEnc\_get\_layer\_vars\_cube(const BddEnc\_ptr self, SymbLayer\_ptr layer, SymbFilterType vt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a layer the function produces a cube of all
   layer's variables]

   Description [vt can be a combination of VFT_CURRENT, VFT_NEXT, VFT_FROZEN,
   VFT_INPUT (see SymbFilterType for combination shortcuts). Returned
   bdd is referenced, the caller must free it after it is no longer
   used.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddVarSet\_ptr BddEnc\_get\_vars\_cube(const BddEnc\_ptr self, Set\_t vars, SymbFilterType vt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Given a set of variables the function produces a cube of
                them filtering out some of them]

   Description [vt is a filter and can be a combination of
   VFT_CURRENT, VFT_NEXT, VFT_FROZEN, VFT_INPUT (see SymbFilterType
   for combination shortcuts).
   vars has to contain variables only without NEXT or anything else.
   E.g. if vars contains state var V and vt includes VFT_CURRENT and
   VFT_NEXT then the result will contains both current and next bits
   of V.

   Returned bdd is referenced, the caller must free it after it is no
   longer used.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddVarSet\_ptr BddEnc\_get\_unfiltered\_vars\_cube(const BddEnc\_ptr self, Set\_t vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Given a set of variables the function produces a cube of
                all of them]

   Description [this function is similar to BddEnc_get_vars_cube
   with 2 differences:
   1. all variables in 'vars' are put into the result cube
   2. in order to compute next-state variable bits of variable V
     'vars' has to contain NEXT(V).

   Returned bdd is referenced, the caller must free it after it is no
   longer used.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddEnc\_is\_var\_in\_cube(const BddEnc\_ptr self, node\_ptr name, add\_ptr cube)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true if the variable is in the cube and false
   otherwise]

   Description [ Parameter name is a fully-resolved name of variable.
   The cube of this variable is subtracted from the cube given in
   'cube' parameter, and the result is compared with the original
   'cube'. If they are different then at least a part (one bit, for
   example) of the variable is in the input cube. Therefore true is
   returned.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_expr\_to\_add(BddEnc\_ptr self, const Expr\_ptr expr, const node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the ADD representing the expression expr, in
   the given context]

   Description         [Returned add is referenced. A NULL value of the
   provided expression (expr) corresponds to a true ADD returned as result.

   NOTE: Mostly expressions must be type checked before being
   evaluated. For example, use TypeChecker_is_expression_wellformed to
   type check generated expression. FSM should be checked with
   TypeCheckingPkg_check_constrains, and a property should be checked
   with TypeCheckingPkg_check_property]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr BddEnc\_expr\_to\_addarray(BddEnc\_ptr self, const Expr\_ptr expr, const node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the ADD array representing the
   expression expr, in the given context]

   Description         [Each element of the returned add array is
   referenced. A NULL value of the provided expression (expr)
   corresponds to a true ADD array returned as result.

   The returned array will belong to the invoker.

   NOTE: Mostly expressions must be type checked before being
   evaluated. For example, use TypeChecker_is_expression_wellformed to
   type check generated expression. FSM should be checked with
   TypeCheckingPkg_check_constrains, and a property should be checked
   with TypeCheckingPkg_check_property]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_expr\_to\_bdd(BddEnc\_ptr self, const Expr\_ptr expr, const node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the BDD representing the expression expr, in
   the given contex]

   Description        [Returned bdd is referenced.

   NOTE: Mostly expressions must be type checked before being
   evaluated. For example, use TypeChecker_is_expression_wellformed to
   type check generated expression. FSM should be checked with
   TypeCheckingPkg_check_constrains, and a property should be checked
   with TypeCheckingPkg_check_property]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BddEnc\_add\_to\_expr(BddEnc\_ptr self, const add\_ptr add, SymbLayer\_ptr det\_layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Converts a ADD into the corresponding (boolean)
   expression.]

   Description        [Takes an ADD with leaves FALSE, TRUE, or {FALSE,TRUE}.

   The case of {FALSE,TRUE} leaves is determinized if a valid layer is
   passed, otherwise it is preserved.

   Important: if a valid determinization layer is given, the layer
   cannot be alreay commited to the encoder, and will have to be
   possibly committed later if the returned expression is intended to
   be used by this encoder in terms of ADD or BDD.

   Recurs down on the structure of the ADD, and maps each non terminal
   node into an if-then-else expression, maps FALSE and TRUE terminal nodes
   into true and false expressions, and maps {FALSE,TRUE} into a newly
   introduced variable to determinize the expression.]

   SideEffects        [A new boolean variable can be declared within det_layer]

   SeeAlso            [bdd_enc_add2expr_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BddEnc\_add\_to\_scalar\_expr(BddEnc\_ptr self, const add\_ptr add, SymbLayer\_ptr det\_layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Converts a ADD into the corresponding (possibly scalar)
   expression.]

   Description [Takes an ADD and converts it to the corresponding
   scalar expression.

   Non deterministic leaves will be determinized only if a valid layer is passed.
   Important: if a valid determinization layer is given, the layer cannot
   be alreay commited to the encoder, and will have to be possibly committed
   later if the returned expression is intended to be used by this encoder in
   terms of ADD or BDD.

   Recurs down on the structure of the ADD, and maps each non terminal
   node into an if-then-else expression]

   SideEffects        [A new scalar variable may be declared within det_layer]

   SeeAlso            [bdd_enc_add2expr_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BddEnc\_bdd\_to\_expr(BddEnc\_ptr self, const bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Converts a BDD into the corresponding (boolean)
   expression.]

   Description        []

   SideEffects        []

   SeeAlso            [bdd_enc_add2expr_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_state\_var\_to\_next\_state\_var\_add(const BddEnc\_ptr self, add\_ptr add)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis            [Exchange next state variables for state variables, in
   terms of ADD]

   Description         [Given an ADD whose variables are STATE variables,
   returns an isomorphic ADD where NEXT-STATE
   variables have been substituted for the
   corrisponding STATE variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_next\_state\_var\_to\_state\_var\_add(const BddEnc\_ptr self, add\_ptr add)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Exchange state variables for next state variables in terms
   of ADD]

   Description        [Given an ADD whose variables are NEXT-STATE variables,
   returns an isomorphic ADD where STATE variables
   have been substituted for the corrisponding
   STATE variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_state\_var\_to\_next\_state\_var(const BddEnc\_ptr self, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Exchange next state variables for state variables]

   Description        [Given a BDD whose variables are STATE variables,
   returns an isomorphic BDD where NEXT-STATE
   variables have been substituted for the
   corrisponding STATE variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_next\_state\_var\_to\_state\_var(const BddEnc\_ptr self, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Exchange state variables for next state variables]

   Description        [Given a BDD whose variables are NEXT-STATE variables,
   returns an isomorphic BDD where STATE variables
   have been substituted for the corrisponding
   STATE variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_print\_bdd\_begin(BddEnc\_ptr self, NodeList\_ptr symbols, boolean changes\_only)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Call before a group of BddEnc_print_bdd calls]

   Description [This sets some fileds used by BddEnc_print_bdd.  Also
   clears the table used when printing only changed states.  After
   having called BddEnc_print_bdd, call BddEnc_print_bdd_end.  If
   <tt>changes_only</tt> is true, than only state and frozen variables which
   assume a different value from the previous printed one are printed
   out.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_print\_bdd\_end(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Must be called after each call to
   BddEnc_print_bdd_begin]

   Description        [Must be called after each call to
   BddEnc_print_bdd_begin, in order to clean up some internal structure]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddEnc\_print\_bdd(BddEnc\_ptr self, bdd\_ptr bdd, VPFNNF p\_fun, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis        [Prints the given bdd. In particular prints only the
   symbols occuring in the symbols list passed to print_bdd_begin. Individual
   assignments may be printed using a user-defined function, passed as a
   parameter]

   Description     [Before calling this method, you must call
   print_bdd_begin. Then you can call this method once or more, but
   eventually you will have to call print_bdd_end to commit.
   Returns the number of symbols actually printed]

   SideEffects     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_print\_set\_of\_states(BddEnc\_ptr self, bdd\_ptr states, boolean changes\_only, boolean show\_defines, VPFNNF p\_fun, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints a set of states. Individual assignments may be
   printed using a user-defined function, passed as a parameter]

   Description        [Note: states are represented by state and frozen variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_print\_set\_of\_inputs(BddEnc\_ptr self, bdd\_ptr inputs, boolean changes\_only, VPFNNF p\_fun, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints a set of input pairs. Individual assignments may
   be printed using a user-defined function, passed as a parameter]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_print\_set\_of\_state\_input\_pairs (BddEnc\_ptr self, bdd\_ptr state\_input\_pairs, boolean changes\_only, VPFNNF p\_fun, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints a set of state-input pairs. Individual
   assignments may be printed using a user-defined function, passed as a
   parameter]

   Description        [Note: states are represented by state and frozen variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_print\_set\_of\_trans\_models(BddEnc\_ptr self, bdd\_ptr bdd\_to\_print, FILE *file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a set of models for given trans]

  Description        []

  SideEffects        [none]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BddEnc\_assign\_symbols(BddEnc\_ptr self, bdd\_ptr bdd, NodeList\_ptr symbols, boolean onlyRequiredSymbs, bdd\_ptr* resultAssignment)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [This function is similar to
   BddEnc_print_set_of... functions except that instead of
   printing values of variables, this funtion creates a list of pairs
   var-itsValue.
   ]

   Description [
   This functions takes a BDD and a list of symbols (variables or
   defines, both can be wrapped in NEXT), and returns a list of
   (symb, symb_value) which makes BDD not false (input BDD) should not
   be false constant).  Returned list is a list of AND nodes with Nil
   at the end. Every element is a EQUAL node with symbol on the left
   and its value on the right.

   Order of symbols in the returned list is the same of provided
   symbols list. If parameter 'onlyRequiredSymbs' is true then
   symbols whose values are not constrained by provided BDD will be
   skipped. Otherwise, some legal arbitrary values for such symbols
   will be created and returned list will contain all the symbols
   from 'symbols'.

   If parameter resultAssignment is not null pointer, then it
   returns the produced assignments in the form of BDD, i.e. a
   conjunct of all generated equations "symbol = itsValue".

   The input BDD may or may not be a complete assignment. The invoker
   should free the returned list (with free_list) and returned BDD (if any).
   Note, that EQUAL nodes should not be freed/modified as created with find_node.
   ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_print\_vars\_in\_cube(BddEnc\_ptr self, bdd\_ptr cube, node\_ptr list\_of\_sym, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints out the symbolic names of boolean
   variables stored in a cube.]

   Description        [Given a cube of boolean BDD variables, this
   function prints out the symbolic names of the corresponding
   variables. The symbolic name of the variables to be printed out are
   listed in <tt>list_of_sym</tt>.]

   SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t* BddEnc\_ComputePrimeImplicants(BddEnc\_ptr self, const array\_t* layer\_names, bdd\_ptr formula)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Finds a set of prime implicants for a formula
   represented as a BDD.]

   Description [Finds the set of prime implicants of a BDD b. Each
   element of the resulting array is a prime implicant of the BDD
   b. The prime implicant is represented as a list of pairs

   (: <vname> <value>)

   The meaning is that the variable <vname> is equal to <value>,
   i.e. <vname> = <value>. A further post-process of the result can
   write it in a better way, expecially for non boolean variables,
   where several prime implicants can be combined by writing complex
   predicates instead of simple equalities.

   The list of layers can be declared for instance as:

   char ** layers = {MODEL_LAYER_NAME, "BA_ABSTRACTION", NULL};

   Where MODEL_LAYER_NAME is the name of the model layer,
   "BA_ABSTRACTION" is the name of a new user created layer.
   Very inportant is the NULL at the end to terminate the list.]

   SideEffects [None]

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double BddEnc\_count\_states\_of\_add(const BddEnc\_ptr self, add\_ptr add)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Return the number of states of a given ADD.]

   Description        [Return the number of minterms (i.e. states)
   represented by an ADD.
   Note: states are represented by state and frozen variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double BddEnc\_count\_states\_of\_bdd(const BddEnc\_ptr self, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Return the number of states of a given BDD.]

   Description        [Return the number of states represented by a BDD.
   Note: states are represented by state and frozen variables.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double BddEnc\_count\_inputs\_of\_bdd(const BddEnc\_ptr self, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Return the number of inputs of a given BDD.]

   Description        [Return the number of inputs represented by a BDD.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double BddEnc\_count\_states\_inputs\_of\_bdd(const BddEnc\_ptr self, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Return the number of states inputs of a given BDD.]

   Description        [Return the number of states inputs represented by a BDD.
   Note: states are represented by state and frozen variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double BddEnc\_get\_minterms\_of\_add(const BddEnc\_ptr self, add\_ptr add)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Return the number of minterms of a given ADD.]

   Description        [Return the number of minterms
   represented by a ADD.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double BddEnc\_get\_minterms\_of\_bdd(const BddEnc\_ptr self, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Return the number of minterms of a given BDD.]

   Description        [Return the number of minterms
   represented by a BDD.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_pick\_one\_state(const BddEnc\_ptr self, bdd\_ptr states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Extracts a minterm from a given BDD.]

   Description        [Extracts a minterm from a given BDD. Returned
   bdd is referenced.
   Note: states are represented by state and frozen variables.]

   SideEffects        []

   SeeAlso            [bdd_pick_one_minterm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_pick\_one\_input(const BddEnc\_ptr self, bdd\_ptr inputs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Extracts a minterm from a given BDD.]

   Description        [Extracts a minterm from a given BDD. Returned
   bdd is referenced]

   SideEffects        []

   SeeAlso            [bdd_pick_one_minterm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddEnc\_pick\_all\_terms\_states\_inputs(const BddEnc\_ptr self, bdd\_ptr bdd, bdd\_ptr* result\_array, const int array\_len)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the array of All Possible Minterms]

   Description        [Takes a minterm and returns an array of all its terms,
   according to internally kept vars. Notice that
   the array of the result has to be previously allocated, and its size
   must be greater or equal the number of the minterms.
   The returned array contains referenced BDDs so it is necessary to
   dereference them after their use. Returns true if an error occurred.

   Note: states are represented by state and frozen variables.
   ]

   SideEffects        [result_array will change]

   SeeAlso            [bdd_pick_all_terms]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddEnc\_pick\_all\_terms\_states(const BddEnc\_ptr self, bdd\_ptr bdd, bdd\_ptr* result\_array, const int array\_len)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the array of All Possible Minterms]

   Description        [Takes a minterm and returns an array of all its terms,
   according to internally kept vars. Notice that
   the array of the result has to be previously allocated, and its size
   must be greater or equal the number of the minterms.
   The returned array contains referenced BDD so it is necessary to
   dereference them after their use. Returns true if an error occurred.

   Note: states are represented by state and frozen variables.]

   SideEffects        [result_array will change]

   SeeAlso            [bdd_pick_all_terms]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddEnc\_pick\_all\_terms\_inputs(const BddEnc\_ptr self, bdd\_ptr bdd, bdd\_ptr* result\_array, const int array\_len)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the array of All Possible Minterms]

   Description        [Takes a minterm and returns an array of all its terms,
   according to internally kept vars. Notice that
   the array of the result has to be previously allocated, and its size
   must be greater or equal the number of the minterms.
   The returned array contains referenced BDD so it is necessary to
   dereference them after their use. Returns true if an error occurred]

   SideEffects        [result_array will change]

   SeeAlso            [bdd_pick_all_terms]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_pick\_one\_state\_rand(const BddEnc\_ptr self, bdd\_ptr states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Extracts a random minterm from a given BDD.]

   Description        [Extracts a random minterm from a given BDD.
   Returned bdd is referenced.

   Note: states are represented by state and frozen variables.]

   SideEffects        []

   SeeAlso            [bdd_pick_one_minterm_rand]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_pick\_one\_input\_rand(const BddEnc\_ptr self, bdd\_ptr inputs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Extracts a random minterm from a given BDD.]

   Description        [Extracts a random minterm from a given BDD.
   Returned bdd is referenced]

   SideEffects        []

   SeeAlso            [bdd_pick_one_minterm_rand]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BddEnc\_get\_var\_name\_from\_index(const BddEnc\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a variable index, this method return the
   symbolic name of the correpsonding variable]

   Description        []

   SideEffects        [required]

   SeeAlso            [BddEnc_get_var_index_from_name]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddEnc\_has\_var\_at\_index(const BddEnc\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a variable index, this method return true iff
   the given variable belongs to the encoder]

   Description        []

   SideEffects        [required]

   SeeAlso            [BddEnc_get_var_name_from_index]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddEnc\_get\_var\_index\_from\_name(const BddEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the DD index of the given variable]

   Description        [The input variable should be boolean]

   SideEffects        [required]

   SeeAlso            [BddEnc_get_var_name_from_index]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_constant\_to\_add(const BddEnc\_ptr self, node\_ptr constant)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the ADD leaf corresponding to the given atom]

   Description        [Returns the ADD leaf corresponding to the given atom,
   if defined, NULL otherwise. The returned ADD - if any - is referenced.
   If the inner flag enforce_constant is set,

   Suppose to have a declaration of this kind:<br>
   <pre>
   VAR
   condition : {idle, stopped}
   </pre>
   then in the constant hash for the atom <tt>idle</tt> there is the
   corresponding leaf ADD, i.e. the ADD whose value is the symbol
   <tt>idle</tt>.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_eval\_sign\_add(BddEnc\_ptr self, add\_ptr a, int flag)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Complements an ADD according to a flag.]

   Description        [Given the ADD <code>a</code>, this function returns
   the negation of ADD <code>a</code> or <code>a</code> itself according the
   value of <code>flag</code>. If <code>flag = -1</code> then returns <code>not
   a</code>, else returns <code>a</code>. It is important that the ADD is a
   FALSE/TRUE ADD (i.e. it has only FALSE or TRUE as leaf).]

   SideEffects        []

   SeeAlso            [bdd_enc_eval]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_eval\_sign\_bdd(BddEnc\_ptr self, bdd\_ptr a, int flag)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Complements a BDD according to a flag.]

   Description [Given the BDD <code>a</code>, this function returns
   the negation of BDD <code>a</code> or <code>a</code> itself
   according the value of <code>flag</code>. If <code>flag =
   -1</code> then returns <code>not a</code>, else returns
   <code>a</code>. It is important that the BDD has only FALSE or
   TRUE as leaves.

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddEnc\_eval\_num(BddEnc\_ptr self, node\_ptr e, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Evaluates a number in a context.]

   Description        [Evaluate the <em>NUMBER</em> represented by <code>e</code>
   in context <code>context</code>. <em>NUMBERS</em> can be encoded in
   different ways in different processes.]

   SideEffects        []

   SeeAlso            [bdd_enc_eval]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_eval\_constant(BddEnc\_ptr self, Expr\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Evaluates a constant expression.]

   Description        [Evaluate a constant expression. If the
   expression does not evaluate to a constant, then an internal error
   is generated. Returned add is referenced.]

   SideEffects        []

   SeeAlso            [eval eval_num]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr BddEnc\_get\_symbol\_add(BddEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a variable, define or process constant
   the corresponding ADD array is returned.]

   Description        [Given an identifier (as an expanded identifier
   <code>name</code>), this function returns the ADD array of its
   definition, or NULL if not defined. If the variable is
   of a Word type then the returned array may contain several elements (ADDs).
   For all other kinds of expressions only one element can be in the
   array.  Errors occurs if the identifier is a define which is
   circularly declared. The returned array will belong to the invoker.]

   SideEffects        []

   SeeAlso            [BddEnc_expr_to_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_get\_state\_frozen\_vars\_mask\_add(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the mask (as an ADD) in terms of frozen and
   state variables]

   Description        [Returned add is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_get\_input\_vars\_mask\_add(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the mask (as an ADD) in terms of input variables]

   Description        [Returned add is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_get\_state\_frozen\_input\_vars\_mask\_add(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the mask (as ADD) in terms of state, frozen and
   input variables]

   Description        [Returned add is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_get\_state\_frozen\_vars\_mask\_bdd(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the mask (as BDD) in terms of frozen and state
   variables]

   Description        [Returned bdd is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_get\_input\_vars\_mask\_bdd(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the mask (as BDD) in terms of input variables]

   Description        [Returned bdd is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddEnc\_get\_state\_frozen\_input\_vars\_mask\_bdd(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the mask (as BDD) in terms of frozen, state and input
   variables]

   Description        [Returned bdd is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_apply\_state\_frozen\_vars\_mask\_add(BddEnc\_ptr self, add\_ptr states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies a mask to the given add which must contain only
   frozen and state variables]

   Description        [Returned add is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_apply\_input\_vars\_mask\_add(BddEnc\_ptr self, add\_ptr inputs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies a mask to the given add which must contain only
   input variables]

   Description [Returned add is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_apply\_state\_frozen\_input\_vars\_mask\_add(BddEnc\_ptr self, add\_ptr states\_inputs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies a mask to the given add which must contain
   frozen, state and input variables]

   Description [Returned add is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddEnc\_apply\_state\_frozen\_vars\_mask\_bdd(BddEnc\_ptr self, BddStates states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies a mask to the given BDD which must contain only
   frozen and state variables]

   Description [Returned bdd is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddInputs BddEnc\_apply\_input\_vars\_mask\_bdd(BddEnc\_ptr self, BddInputs inputs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies a mask to the given BDD which must contain only
   input variables]

   Description [Returned bdd is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddEnc\_apply\_state\_frozen\_input\_vars\_mask\_bdd(BddEnc\_ptr self, BddStatesInputs states\_inputs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies a mask to the given BDD which must contain
   frozen, state and input variables]

   Description [Returned bdd is referenced. Calculated mask will be
   cached for future use. The mask will be applicable only to variable that
   occur within the layers committed to self]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEnc\_get\_var\_mask(BddEnc\_ptr self, node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a variable, it returns the mask of its encoding]

   Description        [Returns the mask that removes repetitions of leaves in
   a variable encoding. Returned ADD is
   referenced. Automatic reordering, if enabled, is
   temporary disabled during this computation.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr BddEnc\_get\_var\_ordering(const BddEnc\_ptr self, const VarOrderingType ord\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Return the list of variables corresponding
   to the current order of variables in the encoding]

   Description [It returns the list of variables corresponding to the
   current order of variables in the encoding. The list will not
   contain NEXT variables (for state variables) and boolean NEXT
   variables are assumed to be close to the corresponding current
   variable.  Notice that in scalar variables current and next bits are
   interleaved (i.e. in current/next pair bits). The returned list must
   be destroyed by the caller.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_write\_var\_ordering(const BddEnc\_ptr self, const char* output\_order\_file\_name, const VarOrderingType dump\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Writes on a file the variable order.]

   Description [This function writes the variable order currently in
   use in the system in the specified output file. The file generated
   as output can be used as input order file for next computations. If
   the specified output file is an empty string ("" or NULL, see
   util_is_string_null) output is redirected to stdout.  The output
   content depends on the value of dump_type, and can be either pure
   scalar (for backward compatibility) or single bits]

   SideEffects        []

   SeeAlso            [Compile_ReadOrder]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddEnc\_get\_reordering\_count(const BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns the number of reorderings that have been carried
   out since either the self construction or the last call to method
   reset_reordering_count]

   Description [Returns the number of reorderings performed by CUDD
   since the instance creation, or since the last call to method
   reset_reordering_count. Explicit and auto-triggered reorderings are
   counted. Notice that forced ordering due to layers commitment may
   increment the orderings count.]

   SideEffects        []

   SeeAlso            [BddEnc_reset_reordering_count]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_reset\_reordering\_count(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Resets the reordering count. The value returned by any
   following call to method get_reordering_count will be relative to
   the moment this method had been called]

   Description [Resets the reordering count. The value returned by any
   following call to method get_reordering_count will be relative to
   the moment this method had been called.]

   SideEffects        []

   SeeAlso            [BddEnc_get_reordering_count]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_force\_order(BddEnc\_ptr self, OrdGroups\_ptr new\_po\_grps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Forces a variable ordering in the BDD encoding.]

   Description        [It takes an OrdGroups structure representing the
   possibly partial ordering and the routine complete it with the
   possible missing variables. It is assumed all the variables in the
   given ordering group have been previously allocated within the BDD
   package.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_force\_order\_from\_file(BddEnc\_ptr self, FILE * orderfile)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [Forces a variable ordering in the BDD encoding
   reading it from a file.]

   Description        [It reads an order file and then forces it
   within the BDD package. The order file may be partial. Thanks to
   <tt>BddEnc_force_order</tt> the ordering is  completed with the
   possible missing variables.]

   SideEffects        []

   SeeAlso            [BddEnc_force_order]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_clean\_evaluation\_cache(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Clean the internal cache which contains the results
   of evaluation of expressions to ADD or BDD form.]

   Description        [
   NB: NuSMV option "enable_sexp2bdd_caching" allows to disable the cache
   completely]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddEnc\_dump\_addarray\_dot(BddEnc\_ptr self, AddArray\_ptr addarray, const char** labels, FILE* outfile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the given AddArray in DOT format]

  Description [Labels is an array of strings to be used as roots
  labels. The size of the array must be equal to the size of the
  AddArray.
  Returns 0 in case of success, 1 otherwise]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddEnc\_dump\_addarray\_davinci(BddEnc\_ptr self, AddArray\_ptr addarray, const char** labels, FILE* outfile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the given AddArray in DAVINCI format]

  Description [Labels is an array of strings to be used as roots
  labels. The size of the array must be equal to the size of the
  AddArray.
  Returns 0 in case of success, 1 otherwise]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_enc\_init(BddEnc\_ptr self, SymbTable\_ptr symb\_table, BoolEnc\_ptr bool\_enc, VarsHandler\_ptr dd\_vars\_hndr, OrdGroups\_ptr ord\_groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The BddEnc class private initializer]

   Description        [The BddEnc class private initializer]

   SideEffects        []

   SeeAlso            [BddEnc_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_enc\_deinit(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The BddEnc class private deinitializer]

   Description        [The BddEnc class private deinitializer]

   SideEffects        []

   SeeAlso            [BddEnc_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_enc\_commit\_layer(BaseEnc\_ptr enc\_base, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Encodes all variables within the given layer. If the
   given layer has an associated boolean layer (created by the BoolEnc), that
   boolean layer will be encoded as well.]

   Description        []

   SideEffects        []

   SeeAlso            [bdd_enc_remove_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_enc\_remove\_layer(BaseEnc\_ptr enc\_base, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Removes the encoding of all variables occurring within
   the given layer, and those that had been created within the corresponding
   boolean layer during the boolean encoding (if there was any).
   Then releases both the layers.]

   Description        [  WARNING: If the layer has been
   renamed after having been committed, it is the *new* name (the name
   the layer has when it is being removed) that must be used, and *not*
   the name that had been used when commiting it.]

   SideEffects        []

   SeeAlso            [bdd_enc_commit_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_enc\_shuffle\_variables\_order(BddEnc\_ptr self, NodeList\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Reshuffle the ordering of bdds. The ordering is
   taken from the provided list.]

   Description        [The given list can be partial wrt the total number of
   variables within the dd manager. All remaining vars are moved *after* the
   last variable occurring within the provided list of vars.]

   SideEffects        []

   SeeAlso            [bdd_enc_commit_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [The BddEnc class virtual finalizer]

   Description [Called by the class destructor]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bdd\_enc\_int\_qsort(const void* e1, const void* e2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private service of bdd_enc_reserve_consecutive_vars,
   to perform quicksort on integer arrays.]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bdd\_enc\_reserve\_consecutive\_vars(BddEnc\_ptr self, const SymbLayer\_ptr layer, size\_t block\_size, size\_t idx\_chunk\_size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns a first level of the created group]

   Description [The list of gaps is searched, and a position is
   used if there is an available gap. Otherwise a new index is
   taken. The returned level is guaranteed to be the first of
   block_size levels, already grouped.

   Furthermore, the set of levels is guarantees to contain repeated
   chunks of 'idx_chunk_size' consecutive indices.

   The list of indices is chosen by looking at fist at the possible
   list of previoulsy removed variables (gaps). A set of chunks of
   consecutive levels is searched and collected taking into account the
   index chunk size. Then the smaller set is chosen to be returned as
   variable indices.

   An error will occur if the maximum number of variables is reached.]

   SideEffects [If the indices are taken from the list of gaps,
   those indices will be removed from the list.]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bdd\_enc\_create\_block(BddEnc\_ptr self, SymbLayer\_ptr layer, int lev\_min, size\_t block\_size, size\_t idx\_chunk\_size, boolean shared)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Allocates a block by reserving their respective
   levels, and associating the block to the respective layer.]

   Description [Returns a first level of the created
   group. Returned level may be different from the requested one.
   This is a private service used only when dealing with groups.]

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_add\_input\_var(BddEnc\_ptr self, node\_ptr name, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds a new boolean input variable to the DD package.]

   Description [This function is used to create the boolean variables
   needed to encode input variables. Both an ADD and a BDD will be created.
   The variable will be created at the given index.
   Minterms arrays will be updated, as well as ADD cubes. ]

   SideEffects        []

   SeeAlso            [bdd_enc_add_state_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_add\_state\_var(BddEnc\_ptr self, SymbLayer\_ptr layer, node\_ptr name, int curr\_index, int next\_index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds a new boolean state variable to the DD package.]

   Description [This function is used to create the boolean variables
   needed to encode state variables. Two ADDs and two BDDs will be
   created, to represent current and next state variables. These two
   pairs are garanteeded to live close each other, and a group will be
   created to prevent dynamic reordering to separate them. The created group
   will be associated to the given layer. No group will be created if
   layer is NULL.

   Minterms arrays will be updated, as well as ADD cubes. ]

   SideEffects        []

   SeeAlso            [bdd_enc_add_input_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_add\_frozen\_var(BddEnc\_ptr self, node\_ptr name, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds a new boolean frozen variable to the DD package.]

   Description [This function is used to create the boolean variables
   needed to encode a frozen variables. Both ADD and BDD will be
   created, to represent the varriable.
   The variable will be created at the given index.
   Minterms arrays will be updated, as well as ADD cubes.]

   SideEffects        []

   SeeAlso            [bdd_enc_add_input_var, bdd_enc_add_state_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_add\_input\_var\_to\_minterm(BddEnc\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Adds an input variable to the arrays necessary to extract
   minterms from a BDD containing either both inputs and states, or
   inputs only.]

   Description [Adds an input variable to the arrays necessary to
   extract minterms from a BDD containing either both inputs and
   states, or inputs only. The minterms arrays are assumed to be always
   compacted, that means that its size directly depends on the number
   of vars currently allocated.

   index is the same index that has been used to create the
   corresponding ADD, typically returned by the method
   get_avail_input_var_index]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_add\_state\_var\_to\_minterm(BddEnc\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Adds a state boolean variable to the arrays necessary to extract
   minterms from a BDD containing either input-state-frozen, state-frozen or state
   variables only.
   ]

   Description [The minterms arrays are assumed to be always
   compacted, that means that its size directly depends on the number
   of vars currently allocated.

   index is the same index that has been used to create the
   corresponding ADD, typically returned by the method
   get_avail_state_var_index]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_add\_next\_state\_var\_to\_minterm(BddEnc\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Adds a next state boolean variable to the array necessary to
   extract minterms from a BDD containing next states]

   Description [Adds a next state variable to the array necessary to
   extract minterms from a BDD containing next states.
   The minterm array is assumed to be always
   compacted, that means that its size directly depends on the number
   of next state vars currently allocated.

   index is the same index that has been used to create the
   corresponding next state var ADD, typically the value returned by
   the method get_avail_state_var_index + 1 ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_add\_frozen\_var\_to\_minterm(BddEnc\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Adds a state boolean variable to the arrays necessary to extract
   minterms from a BDD containing either only frozen, state-frozen or
   state-frozen-input variables.]

   Description [The minterms arrays are assumed to be always
   compacted, that means that its size directly depends on the number
   of vars currently allocated.

   index is the same index that has been used to create the
   corresponding ADD, typically returned by the method
   get_avail_state_var_index]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_accumulate\_state\_var\_cube(BddEnc\_ptr self, add\_ptr curr, add\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Accumulates given adds representing the curr and next
   state var encoding to the internal cubes of current and next state
   vars]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_accumulate\_frozen\_var\_cube(BddEnc\_ptr self, add\_ptr frozen)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Accumulates given adds representing the frozen var encoding
   to the internal cube of frozen vars]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_accumulate\_input\_var\_cube(BddEnc\_ptr self, add\_ptr input)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Accumulates given adds representing the input var encoding
   to the internal cube of input vars]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_remove\_input\_var(BddEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Removes the given input variable from the internal cubes
   of input vars]

   Description        [This is a service of method remove_var. DO NOT call
   this directly.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_remove\_state\_var(BddEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Removes the given state variable (and the corresponding next var)
   from the internal cubes]

   Description        [This is a service of method remove_var. DO NOT call
   this directly.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_remove\_frozen\_var(BddEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Removes the given frozen variable from the internal cubes
   of frozen vars]

   Description        [This is a service of method remove_var. DO NOT call
   this directly.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_remove\_var(BddEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Removes the given var from the encoder]

   Description        [A bunch of calls to this method, must be followed by
   a call to compact_minterms_array, to compact the minterms arrays]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_remove\_var\_from\_minterm(BddEnc\_ptr self, int var\_idx, array\_t* minterms\_array, int minterms\_array\_len)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Searches linearly within the given array (up to
   the given limit) for the given var index, and remove it]

   Description        [The array must be compacted after all the vars have
   been removed]

   SideEffects        []

   SeeAlso            [bdd_enc_compact_minterms_array]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bdd\_enc\_get\_next\_state\_var\_name(node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Builds the name of the next state variable corresponding
   to the current state variable name passed as an argument.]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static NodeList\_ptr bdd\_enc\_append\_bool\_vars\_from\_layers(BddEnc\_ptr self, NodeList\_ptr layers, boolean* layers\_interleaved)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Private service of method sort_variables_and_groups, that
   takes a list of scalar layers and appends all the variables
   declared within them to the returned list.]

   Description [Creates a list of all the variables
   declared within the given layers, that cannot be layers deriving
   from the booleanization process. Iterates on the variables declared
   within the given layers. If a variable is boolean, it is appended to
   the list as it is; if the variable is scalar, its bits are taken and
   pushed in the order they occur.

   'layers' is a list of SymbLayer_ptr.

   The returned list will be ordered accordingly to the value of
   system variable 'vars_order_type'. If bit-interleaving is
   involved, it is applied among variables in all layers. In this
   case output parameter layers_interleaved gets assigned to true,
   but only of there are two or more layers involved.

   It is the responsibility of an invoker to free the returned list.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static NodeList\_ptr bdd\_enc\_get\_var\_booleanizations(BddEnc\_ptr self, Set\_t vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Private service of method BddEnc_get_vars_cube, that
   takes a set of varioables and returns their booleanization]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static NodeList\_ptr bdd\_enc\_sort\_variables\_and\_groups\_according(BddEnc\_ptr self, OrdGroups\_ptr old\_group, OrdGroups\_ptr res\_group, boolean* interleaved)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns the ordered list of variables, and a groups set of
   variables that must be created]

   Description [It takes an OrdGroup representing a partial order to be
   followed, and build a new OrdGroup and the ordered list of
   variables. The caller is responsible for the disposal of the
   returned list. Output parameter needs_reshuffle is set to false if a
   reshuffle is _not_ needed because the ordering will not change from
   the default (implemented for the sake of performances). res_group
   will contain the groups of the variables that will have to be
   created, whereas the returned list is the 'flat' version
   (i.e. without grouping information) of those variables.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static NodeList\_ptr bdd\_enc\_sort\_variables\_and\_groups(BddEnc\_ptr self, SymbLayer\_ptr layer, OrdGroups\_ptr res\_group, boolean* needs\_reshuffle, boolean* interleaved)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns the ordered list of variables, and a groups set of
   variables that must be created]

   Description [The given layer (and the associated boolean layer if
   exists) contains the variables that must be created. As this method is
   called when a layer is committed, the parameter layer represent just
   the layer that is being committed. The caller is responsible for the
   disposal of the returned list. Output parameter needs_reshuffle is
   set to false if a reshuffle is _not_ needed because the ordering
   will not change from the default (implemented for the sake of
   performances). res_group will contain the groups of the variables
   that will have to be created, whereas the returned list is the
   'flat' version (i.e. without grouping information) of those
   variables.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bdd\_enc\_compact\_minterms\_array(BddEnc\_ptr self, array\_t* minterms\_array, int minterms\_array\_len)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Compacts the given array (i.e. intermediate
   gaps are removed)]

   Description        [Returns the actual length of the compacted array]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_lock\_reordering(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [If dynamic reordering is enabled, it is temporarily
   disabled]

   Description        [If dynamic reordering is enabled, it is temporarily
   disabled]

   SideEffects        []

   SeeAlso            [bdd_enc_unlock_reordering]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_unlock\_reordering(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Re-enable a previously disabled reordering, if it was
   enabled when locked.]

   Description        []

   SideEffects        []

   SeeAlso            [bdd_enc_lock_reordering]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_insert\_gap(BddEnc\_ptr self, int index, size\_t gap\_size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Inserts a new gap within the list of gaps]

   Description        [This method guarantees that the list of gaps
   is ordered]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_remove\_gap(BddEnc\_ptr self, int index, size\_t size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Removes a previoulsy inserted gap from the list of gaps]

   Description [This method guarantees that the list of gaps keeps its
   order. If found, a gap might be either removed, reduced in size, or
   splitted into to smaller gaps. If the gap is not found, an internal
   error occurs.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bdd\_enc\_name\_to\_index(const BddEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given a var name, it returns the corresponding index
   in the dd manager]

   Description        [An assertion will occur whether the given name does not
   correspond to any variable. If name is a next variable, then it is checked
   that a corresponding current state var exists. If it does not, again an
   assertion will be thrown.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval hash\_node\_free(char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private service]

   Description        [Used when destroying node list containing node_ptr]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval hash\_add\_key\_free(char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private service]

   Description        [Used when destroying hash containing add_ptr as key]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static add\_ptr bdd\_enc\_get\_vars\_list\_mask(BddEnc\_ptr self, const SymbLayer\_ptr layer, SymbLayerIter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Given a list of variables, it returns the corresponding
   mask]

   Description        [Private service used by higher level mask-related
   methods]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static add\_ptr bdd\_enc\_get\_var\_mask\_recur(BddEnc\_ptr self, add\_ptr var\_encoding, add\_ptr cube)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Calculates the mask of the var encoding passed as
   argument]

   Description        [Private method that recursively calculates the mask of
   the var encoding passed as argument. Passed cube is the cube of
   the encoding, used while visiting the encoding, in order to find
   indexes of sub-variable. Returned add is referenced, and the
   automatic reordering *must* be disabled before calling this
   method. ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_eval(BddEnc\_ptr self, Expr\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Given an expression the corresponding hybrid ADD is
   returned back.]

   Description        [This function takes an expression in input and
   returns the corresponding list of ADD. This list may contain several
   elements for Word expressions, but only one element for all other
   kinds of expressions.<p>

   If a domain variables is received as input, the returned value is
   the ADD representing its boolean encoding. It has as
   leaves the value associated to that path.<br>
   For instance consider the declaration:<br>
   <code>VAR x : 1..6;</code><br>
   it is encoded with three boolean variables as below:
   <pre>

   x1
   /\\
   T/  \\F
   /    \\
   /      \\
   x2       x2
   /\\        / \\
   /  \\       |  \\
   x3    \\      x3  \\
   /  \\   \\    /  \\  \\
   /    \\  \\   /    \\  \\
   1    5    3   2     6   4

   </pre>

   A Word variable is encoded as a list of its boolean elements.<br>
   For example:<br>
   <code>VAR x : word[3];</code><br>
   is encoded with three boolean variables and represented as a list of
   three ADD as below:
   <pre>
   x2        x1         x0
   / \\      / \\       / \\
   F   T     F   T      F   T

   </pre>

   If the expression is complex, then the function is recursively applied to the
   operands, and then the operation is applied to the obtained values, returning
   the resulting (hybrid) ADD. All returned ADD are referenced]

   SideEffects        []

   SeeAlso            [eval_recur, AddArray_ptr]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_eval\_recur\_case\_atom(BddEnc\_ptr self, Expr\_ptr expr, node\_ptr ctx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Performs the <code>eval</code>
   function on an atom-expression.]

   Description        [The atom-expression <code>expr</code> is
   compiled in ADD:
   <ul>
   <li> If it is a program parameter, then its actual name is
   extracted from the parameter hash, and it is evaluated. The
   result of evaluation is returned.</li>
   <li> If it is a constant, then the corresponding ADD is returned
   back.</li>
   <li> If it is a variable, then it is converted to node_ptr
   binary encoding and then the corresponding ADD is returned.
   back.</li>
   </ul>
   ]

   SideEffects        []

   SeeAlso            [eval get_definition]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_eval\_recur\_case\_dot\_array(BddEnc\_ptr self, Expr\_ptr expr, node\_ptr ctx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Performs the <code>eval</code>
   function on an atom-expression representing a variable, define or constant
   representing the name of a process]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_eval\_recur(BddEnc\_ptr self, Expr\_ptr expr, node\_ptr ctx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Recursive subroutine of bdd_enc_eval]

   Description        [The returned list belongs to the invoker.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean bdd\_enc\_is\_bit\_vector(BddEnc\_ptr self, node\_ptr expr, node\_ptr context, boolean* isSigned)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true, if an expression is a bit verctor, i.e.
   of type Word. They are encoded as arrays of ADD (not as single ADD).
   Otherwise false is returned.]

   Description        [the expression should already be checked by the
   type-checker associated with the given BDD Encoder.
   If the function returns true and isSigned parameter is not NULL then
   *isSigned is set to:
   true -- if the expression is of signed word type, and
   false -- if the expression if of unsigned word type.]

   SideEffects        []

   SeeAlso            [bdd_enc_eval, bdd_enc_binary_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_unary\_add\_op(BddEnc\_ptr self, FP\_A\_DA op, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies unary operation.]

   Description        [Takes in input the expression <code>n</code> and a
   unary operation <code>op</code>. Evaluates <code>n</n> and applies to this
   partial result the unary operator <code>op</code>.

   If the operand have more than one ADD, then the operation is consecutively
   applied to every its ADD.

   NB: The size of both given arrays should be the same (and positive).
   ]

   SideEffects        []

   SeeAlso            [bdd_enc_eval, bdd_enc_binary_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_binary\_add\_op(BddEnc\_ptr self, FP\_A\_DAA op, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies binary add operation.]

   Description        [Takes in input the expression <code>n</code> and a
   binary operation <code>op</code>. Extracts from <code>n</n> the
   operands and evaluates them.]

   SideEffects        []

   SeeAlso            [bdd_enc_eval, bdd_enc_unary_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_unary\_node\_op(BddEnc\_ptr self, NPFNN/*NPFCVT*/ op, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies unary operation.]

   Description        [Takes in input the expression <code>n</code> and a
   unary operation <code>op</code>. Evaluates <code>n</n> and applies to this
   partial result the unary operator <code>op</code>.

   NOTE: At the moment CUDD does not have unary 'apply', so you have
   to provide a binary op, which is actually unary and applies to
   the first operand only.

   If the operand have more than one ADD, then the operation is consecutively
   applied to every its ADD.

   NB: The size of both given arrays should be the same (and positive).

   ]

   SideEffects        []

   SeeAlso            [bdd_enc_eval, bdd_enc_binary_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_binary\_node\_op(BddEnc\_ptr self, NPFNN op, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies binary operation.]

   Description        [Takes in input the expression <code>n</code> and a
   binary operation <code>op</code>. Extracts from <code>n</n> the
   operands and evaluates them.
   The binary operator <code>op</code> is then applied to these partial
   results with the help of add_apply, i.e. op should be a function
   which can be applied on two constant nodes.

   If the operands have more than one ADD, then the operation is consecutively
   applied to every corresponding pair of ADDs (one from left operand, and
   one from the right operand).

   ]

   SideEffects        []

   SeeAlso            [bdd_enc_eval, bdd_enc_unary_node_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_if\_then\_else\_op(BddEnc\_ptr self, node\_ptr node, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Evaluates if_then_else expressions returning
   the ADDs representing <em>IF ifarg THEN thenarg ELSE elsarg</em>.]

   Description        [Evaluates if_then_else expressions returning the
   ADD representing <em>IF ifarg THEN thenarg ELSE elsarg</em>, where
   <code>ifarg</code>, <code>thenarg</code>, <code>elsearg</code> are the ADD
   obtained by evaluating <code>ifexp</code>, <code>thenexp</code>,
   <code>elseexp</code> respectively in context <code>context</code>.
   THEN and ELSE part can be an array of ADDs, then of-then-else is
   applied to every pair of corresponding ADDs.]

   SideEffects        []

   SeeAlso            [add_ifthenelse]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_unary\_vector\_op(BddEnc\_ptr self, ADD\_ARRAY\_UNARY\_OP op, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies a unary operation to an array of ADDs.]

   Description        [Takes the expression <code>n</code> and a
   unary array operation <code>op</code>. Extracts from <code>n</n> the
   operand and evaluates it.
   The unary operator <code>op</code> is then applied to this partial
   result.]

   SideEffects        []

   SeeAlso            [bdd_enc_eval, bdd_enc_binary_vector_op, bdd_enc_binary_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr bdd\_enc\_binary\_vector\_op(BddEnc\_ptr self, ADD\_ARRAY\_BINARY\_OP op, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Applies a binary operation to an array of ADDs.]

   Description        [Takes the expression <code>n</code> and a
   binary array operation <code>op</code>. Extracts from <code>n</n> the
   operands and evaluates them.
   The binary operator <code>op</code> is then applied to these partial
   results.]

   SideEffects        []

   SeeAlso            [bdd_enc_eval, bdd_enc_unary_vector_op, bdd_enc_binary_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bdd\_enc\_add2expr\_recur(BddEnc\_ptr self, SymbLayer\_ptr det\_layer, add\_ptr add\_expr, hash\_ptr lc, boolean is\_scalar)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Converts a ADD into the corresponding expression.]

   Description [Auxiliary function for bdd_enc_add2expr.  if is_scalar
   is false, then the add is assumed to be boolean, and the result
   will be a boolean expression. If det_layer is NULL, if the add
   contains undeterministic leaves, the returned expression will still
   contain undeterministic values. If det_layer is not NULL, then the
   expression will be determinized, and the returned layer will
   contain new determinization variables.]

   SideEffects        [A new boolean variable might be introduced.]

   SeeAlso            [bdd_enc_add2expr]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean bdd\_enc\_is\_index\_not\_allocated(const BddEnc\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true if given variable index is not currently
   allocated]

   Description        [Used internally to check indices]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_dissolve\_committed\_groups(BddEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Used when it is needed to dissolve the variable blocks
   created by this encoder. This is needed when interleaving
   variables among several layers.]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int bdd\_enc\_dump\_addarray\_dot\_davinci(BddEnc\_ptr self, AddArray\_ptr addarray, const char** labels, FILE* outfile, boolean use\_dot)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the given AddArray.]

  Description [Labels is an array of strings to be used as roots
  labels. The size of the array must be equal to the size of the
  AddArray.

  Returns 0 in case of success, 1 otherwise]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{BddEncBddPrintWff.c}
		
	\texttt{void BddEnc\_print\_formula\_info(BddEnc\_ptr self, Expr\_ptr formula, boolean print\_models, boolean print\_formula, FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Prints statistical information of a formula.]

   Description  [Prints statistical information about a given formula.
                 It is computed taking care of the encoding and of the
                 indifferent variables in the encoding.]

   SideEffects  []

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEnc\_print\_bdd\_wff(BddEnc\_ptr self, bdd\_ptr bdd, /* the input bdd */ NodeList\_ptr vars, /* variables */ boolean do\_sharing, /* requires dag sharing */ boolean do\_indent, /* requires indentation */ int start\_at\_column, /* align to column (indent only) */ FILE* out /* the stream to write to */ )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Prints a BDD as a Well Formed Formula using optional
  sharing]

  Description [The bdd representing the formula to be printed is first
  converted to a wff.

  If sharing is required optimizations are performed on the printout.

  If indentation is required, the start_at_column integer offset is
  used to determine the starting indenting offset to print the
  expression.]

  SideEffects        [prints the expression on the given stream. ]

  SeeAlso            [BddEnc_bdd_to_wff]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BddEnc\_bdd\_to\_wff( BddEnc\_ptr self, bdd\_ptr bdd, /* the input bdd */ NodeList\_ptr vars /* variables */ )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Converts a bdd into a Well Formed Formula representing
  it.]

  Description [A new expression is built, that represents the formula
  given as the input bdd.

  The list of variables is used to compute the scalar essentials. Note
  that only the following kinds of variables are allowed in this list.

  1. Pure booleans (i.e. not part of an encoding)
  2. Finite scalars (both ranged and words).

  State, frozen and input variables are all allowed, no NEXT. (It will
  be part of this function's responsibility to add state variables' NEXTs
  as needed.

  SideEffects        [none]

  SeeAlso            [Bddenc_print_wff_bdd]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval bdd\_enc\_hash\_free\_bdd\_counted (char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Used to deref bdds in the sharing hashtable]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr bdd\_enc\_get\_scalar\_essentials( BddEnc\_ptr self, /* current encoding */ bdd\_ptr bdd, /* the formula */ NodeList\_ptr vars /* variables */ )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compute scalar essentials of a bdd.]

  Description [Computes the scalar essentials of a bdd, picking
  identifiers from the variables in vars list. Used as part of
  bdd_enc_bdd_to_wff_rec implementation.]

  SeeAlso            [bdd_enc_bdd_to_wff]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static NodeList\_ptr bdd\_enc\_get\_preprocessed\_vars( BddEnc\_ptr self, /* current encoding */ NodeList\_ptr vars /* variables to be preprocessed */ )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Preprocesses variables list, as part of the
  bdd_enc_bdd_to_wff implementation.]

  Description [This function is used to preprocess variables list to
  provide to bddenc_print_wff_bdd. As the algorithm implemented in the
  latter does not support word variables, word variables (if any)
  shall be substituted with their bit variables
  representatives. Moreover, this function takes care of adding NEXT
  variables for state variables. For this reason no NEXT nor BITS are
  allowed as input to this function.

  The result NodeList must be destroyed by the caller.]

  SideEffects        [none]

  SeeAlso            [BddEnc_bdd_to_wff]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_debug\_bdd\_to\_wff (BddEnc\_ptr self, bdd\_ptr bdd, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Debug code for BddEnc_bdd_to_wff]

  SideEffects [Halts NuSMV if the expression is not a correct
  representation of bdd.]

  SeeAlso            [BddEnc_bdd_to_wff]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bdd\_enc\_bdd\_to\_wff\_rec( BddEnc\_ptr self, /* The encoding manager */ NodeList\_ptr vars, /* Variables list (see below) */ bdd\_ptr bdd, /* the BDD to be represented*/ hash\_ptr cache /* memoization hashtable for DAG traversal */ )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Recursively build a sexp representing a formula encoded as
  a BDD]

  Description [This function accepts a list of variables as part of
its inputs.The present algorithm assumes that a variable in vars list
is a boolean only in two distinct cases:

1. Pure booleans
2. Boolean

variables belonging to words (i.e. Boolean variables belonging to a
scalar encoding are _not_ allowed in the input list of this
function. This would invariably cause this implementation to
fail). This assumptions are enforced by its public top-level caller.]

  SideEffects        [none]

  SeeAlso            [BddEnc_bdd_to_wff]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{BddEncCache.c}
		
	\texttt{BddEncCache\_ptr BddEncCache\_create(SymbTable\_ptr symb\_table, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class constructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_destroy(BddEncCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class destructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_new\_constant(BddEncCache\_ptr self, node\_ptr constant, add\_ptr constant\_add)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call to associate given constant to the relative add]

  Description        [This methods adds the given constant only if it 
  does not exist already, otherwise it only increments a reference counter, 
  to be used when the constant is removed later.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_remove\_constant(BddEncCache\_ptr self, node\_ptr constant)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the given constant from the internal hash]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddEncCache\_is\_constant\_encoded(const BddEncCache\_ptr self, node\_ptr constant)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true whether the given constant has been encoded]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEncCache\_lookup\_constant(const BddEncCache\_ptr self, node\_ptr constant)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the ADD corresponding to the given constant, or 
  NULL if not defined]

  Description   [Returned ADD is referenced, NULL is returned if the given 
  constant is not currently encoded]
  
  Notes         []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_new\_boolean\_var(BddEncCache\_ptr self, node\_ptr var\_name, add\_ptr var\_add)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call this to insert the encoding for a given boolean
  variable]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_remove\_boolean\_var(BddEncCache\_ptr self, node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the given variable from the internal hash]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddEncCache\_is\_boolean\_var\_encoded(const BddEncCache\_ptr self, node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true whether the given boolean variable has 
  been encoded]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr BddEncCache\_lookup\_boolean\_var(const BddEncCache\_ptr self, node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the add associated with the given boolean 
  variable, if previously encoded. ]

  Description        [Returned add is referenced. NULL is returned if the 
  variable is not encoded.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_set\_evaluation(BddEncCache\_ptr self, node\_ptr expr, AddArray\_ptr add\_array)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This method is used to remember the result of evaluation,
  i.e. to keep the association between the expression in node_ptr form
  and its ADD representation.]

  Description [The provided array of ADD will belong to "self"
  and will be freed during destruction of the class or setting a new 
  value for the same node_ptr.

  NOTE: if NuSMV option "enable_sexp2bdd_caching" is unset to 0 then no
  result is kept and the provided add_array is immediately freed]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_remove\_evaluation(BddEncCache\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This method is used to remove the result of evaluation
  of an expression]

  Description [If a given node_ptr is associated already with
  some AddArray then the array is freed. Otherwise nothing happens]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr BddEncCache\_get\_evaluation(BddEncCache\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieve the evaluation of a given symbol, 
  as an array of ADD]

  Description        [ If given symbol has not been evaluated, NULL is returned.
  If the evaluation is in the process, BDD_ENC_EVALUATING is returned.
  Otherwise an array of ADD is returned.

  The returned array must be destroyed by the invoker!

  NB: For all expressions except of the Word type the returned 
  array can contain only one element.
  NB: If NuSMV option enable_sexp2bdd_caching is unset to 0 then the hash
  may be empty.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_clean\_evaluation\_about(BddEncCache\_ptr self, NodeList\_ptr symbs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Cleans those hashed entries that are about a symbol that
  is being removed]

  Description [This is called by the BddEnc class when a layer is
  begin removed and the cache has to be cleaned up]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddEncCache\_clean\_evaluation(BddEncCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Cleans up the cache from all the evaluated expressions]

  Description [Note that hashed encoding of boolean variables and constants
  (added by BddEncCache_new_boolean_var and BddEncCache_new_constant, resp.)
  remains intact.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_cache\_init(BddEncCache\_ptr self, SymbTable\_ptr symb\_table, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private initializer]

  Description        [Private initializer, called by the constructor]

  SideEffects        []

  SeeAlso            [bdd_enc_cache_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_enc\_cache\_deinit(BddEncCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private deinitializer]

  Description        [Private deinitializer, called by the destructor]

  SideEffects        []

  SeeAlso            [bdd_enc_cache_init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval hash\_free\_add(char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private micro function used when destroying caches of
  adds]

  Description        [Called when pushing the status, and during
  deinitialization]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval hash\_free\_add\_array(char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private micro function used when destroying caches of
  adds]

  Description        [Called when pushing the status, and during
  deinitialization]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval hash\_free\_add\_counted(char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private micro function used when destroying caches of
  adds]

  Description        [Called when pushing the status, and during
  deinitialization. The kind of nodes that must be removed here is 
  CONS(integer, add). Of course it is the add that must be freed.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{be}
		
	\subsection{BeEnc.c}
		
	\texttt{static inline int be\_enc\_get\_untimed\_block\_size(const BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns the size of the untimed vars block]

Description [Returns the sum of input, frozen, current state and next state
variables]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int be\_enc\_get\_timed\_block\_size(const BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns the size of one single timed vars block]

Description [Returns the sum of input and state variables]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int be\_enc\_index\_phy\_to\_log(BeEnc\_ptr self, int phy\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Converts a physical index to a logical index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int be\_enc\_index\_log\_to\_phy(BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Converts a logical index to a physical index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline boolean be\_enc\_is\_log\_index\_untimed(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns true if the given logical index is within the
untimed block]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline boolean be\_enc\_is\_log\_index\_timed(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns true if the given logical index is within the
timed blocks set]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline boolean be\_enc\_is\_log\_index\_untimed\_curr\_state(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns true if the given logical index is within the
untimed block, and it is a current state variable index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline boolean be\_enc\_is\_log\_index\_untimed\_frozen(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns true if the given logical index is within the
untimed block, and it is a frozen variable index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline boolean be\_enc\_is\_log\_index\_untimed\_input(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns true if the given logical index is within the
untimed block, and it is an input variable index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline boolean be\_enc\_is\_log\_index\_untimed\_curr\_state\_frozen\_input(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns true if the given logical index is within the
untimed block, and it is a current state, frozen or input variable index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline boolean be\_enc\_is\_log\_index\_untimed\_next\_state(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns true if the given logical index is within the
untimed block, and it is a next state variable index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline BeVarType be\_enc\_type\_of\_log\_index\_untimed(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Given a logical index within the
untimed block the function returns a type indicating whether the index is
a current state, frozen, input or next state variable.]

Description [if the index is outside of the untimed block, BE_VAR_TYPE_ERROR
is returned]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BeEnc\_ptr BeEnc\_create(SymbTable\_ptr symb\_table, BoolEnc\_ptr bool\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [The BeEnc class constructor]

Description        [The BeEnc class constructor]

SideEffects        []

SeeAlso            [BeEnc_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BeEnc\_destroy(BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [The BeEnc class destructor]

Description        [The BeEnc class destructor]

SideEffects        []

SeeAlso            [BeEnc_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_get\_state\_vars\_num(const BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis  [Returns the <tt>number of state variables currently
handled by the encoder</tt>]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_get\_frozen\_vars\_num(const BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis  [Returns the <tt>number of frozen variables currently
handled by the encoder</tt>]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_get\_input\_vars\_num(const BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis  [Returns the <tt>number of input variables currently
handled by the encoder</tt>]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_get\_vars\_num(const BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns the <tt>number of input and state variables
currently handled by the encoder</tt>]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_get\_max\_time(const BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [<b>Returns</b> the <tt>maximum allocated time </tt>]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Be\_Manager\_ptr BeEnc\_get\_be\_manager(const BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [<b>Returns</b> the
<tt>Boolean Expressions manager</tt> contained into the variable manager,
to be used by any operation on BEs]

Description        [Warning: do not delete the returned instance of
Be_Manager class, it belongs to self]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_name\_to\_untimed(const BeEnc\_ptr self, const node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given the variable name, returns the corresponding BE
untimed variable]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BeEnc\_index\_to\_name(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given the index of a be var, returns the symbolic variable
name.]

Description        [Current implementation requires that the variable belongs
to the untimed block]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_name\_to\_index(const BeEnc\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given the name of a be var, returns the untimed index that
variable is allocated at.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BeEnc\_var\_to\_name(const BeEnc\_ptr self, be\_ptr be\_var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given a be variable, returns the correponding
variable name]

Description [Current implementation requires the given be variable
to be untimed ]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_index\_to\_var(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given a variable index, returns the corresponding be variable]

Description [Current implementation requires that the variable index
belongs to the untimed block]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_var\_to\_index(const BeEnc\_ptr self, const be\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given a be variable, returns the corresponding be index]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_index\_to\_timed(const BeEnc\_ptr self, const int index, const int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given an untimed variable index, returns the corresponding
BE variable at the given time]

Description [This method expands the maximum allocated time if necessary.

WARNING: If the given index corresponds to an untimed next state
var, the returned timed var will be instantitated at time+1

NOTE: Frozen variables are returned untimed as timed frozen
variables are never instantiated.
]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_index\_to\_untimed\_index(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given a timed variable index, returns the corresponding
untimed BE variable index]

Description [Returned index will refer either to an untimed current
state variable, an untimed frozen variable or an untimed input variable.]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_index\_to\_time(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Given a state or input variable index this returns the time
the variable is allocated]

Description [The given state or input variable index must refer a timed
variable.

If the given index refer to a frozen variable then BE_CURRENT_UNTIMED
constant is returned (frozen variables are only allocated in the
untimed block).]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_var\_to\_timed(const BeEnc\_ptr self, const be\_ptr var, const int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given an untimed variable, returns the corresponding
BE variable at the given time]

Description [This method expands the maximum allocated time if necessary.

WARNING: If the given variable is an untimed next state, the
returned index will be instantitated at time+1

NOTE: Frozen variables are returned untimed as they are always untimed.
]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_var\_to\_untimed(const BeEnc\_ptr self, const be\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Given a timed or untimed variable, returns the corresponding
BE variable in the current state untimed block (current state, frozen
and input vars).]

Description []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_name\_to\_timed(const BeEnc\_ptr self, const node\_ptr name, const int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given the name of an untimed variable, returns the
corresponding BE variable at the given time]

Description [This method expands the maximum allocated time if necessary.

WARNING: If the given variable name corresponds to an untimed next
state var, the returned index will be instantitated at time+1

NOTE: Frozen variables are returned untimed as they are never allocated as
timed variables.
]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_var\_curr\_to\_next(const BeEnc\_ptr self, const be\_ptr curr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Converts an untimed current state variable to the corresponding
untimed variable in the next state untimed block.]

Description [Given variable must be a current state untimed variable]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_var\_next\_to\_curr(const BeEnc\_ptr self, const be\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Converts an untimed next state variable to the corresponding
untimed variable in the current state untimed block.]

Description [Given variable must be a next state untimed variable]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_state\_var(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Checks whether given index corresponds to a state variable]

Description        [Valid state variables are in current and next state
blocks, and in timed state areas.]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_input\_var(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Checks whether given index corresponds to an input variable]

Description        [Input variables are in the input untimed block,
or in timed input areas.]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_frozen\_var(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks whether given index corresponds to a frozen variable]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_untimed(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Checks whether given index corresponds to an untimed variable]

Description        [Note: frozen variables are always untimed.]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_untimed\_curr(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Checks whether given index corresponds to an untimed
current state variable]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_untimed\_frozen(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Checks whether given index corresponds to an untimed
frozen variable]

Description        [Frozen variables are always untimed. So this function is
exactly the same as BeEnc_is_index_frozen_var]

SideEffects        []

SeeAlso            [BeEnc_is_index_frozen_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_untimed\_input(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Checks whether given index corresponds to an untimed input
variable]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_untimed\_curr\_frozen\_input(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Checks whether given index corresponds to an untimed
current state variable, or an untimed frozen, or an untimed input variable]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_index\_untimed\_next(const BeEnc\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Checks whether given index corresponds to an untimed
next state variable]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_get\_first\_untimed\_var\_index(const BeEnc\_ptr self, BeVarType type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Call this to begin an iteration between a given
category of variables]

Description [Use this method to begin an iteration between a given
category of variables, for example the set of input variables, or
the set of current and next state variables. The type is a bitwise
OR combination of types. When the first index is obtained, following
indices can be obtained by calling get_next_var_index, until
is_var_index_valid returns false, that means that the
iteration is over and must be given up.]

SideEffects        [None]

SeeAlso            [BeEnc_get_next_var_index, BeEnc_get_var_index_with_offset,
BeEnc_is_var_index_valid]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_get\_next\_var\_index(const BeEnc\_ptr self, int var\_index, BeVarType type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Use to sequentially iterate over a selected category of
variables.]

Description [Use this method to obtain the index of the variable
that follows the variable whose index is provided. If the iteration
is over, an invalid index will be returned. Use the method
is_var_index_valid to check the validity of the returned index.]

SideEffects        [None]

SeeAlso            [BeEnc_get_first_untimed_var_index,
BeEnc_is_var_index_valid, BeEnc_get_var_index_with_offset]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BeEnc\_get\_var\_index\_with\_offset(const BeEnc\_ptr self, int from\_index, int offset, BeVarType type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Use to randomly iterate over a selected category
of variables within the untimed block.]

Description [Use this method to obtain the index of the variable
that follows the variable whose index is provided, after offset
positions. If the iteration is over, an invalid index will be
returned. Use the method is_var_index_valid to check the validity of
the returned index.]

SideEffects        [None]

SeeAlso            [BeEnc_get_first_untimed_var_index,
BeEnc_is_var_index_valid, BeEnc_get_next_var_index]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BeEnc\_is\_var\_index\_valid(const BeEnc\_ptr self, int var\_index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Use to check whether an iteration over a set of variables
is over.]

Description [This method returns true whether the index returned by
methods get_first_untimed_var_index, get_next_var_index and
get_var_index_with_offset is valid and can be used later in the
iteration. If false is returned, then the iteration is over.]

SideEffects        [None]

SeeAlso            [BeEnc_get_first_untimed_var_index,
BeEnc_get_next_var_index, BeEnc_get_var_index_with_offset]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_shift\_curr\_to\_next(BeEnc\_ptr self, const be\_ptr exp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [<b>Shifts</b> given <i>current</i> <b>expression at
next time</b>]

Description [Warning: argument 'exp' must contain only untimed
current state variables and untimed frozen variables,
otherwise results will be unpredictible]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_untimed\_expr\_to\_timed(BeEnc\_ptr self, const be\_ptr exp, const int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [<b>Shifts</b> given <i>untimed</i> <b>expression at
the given time</b>]

Description [All next state variables will be shifted to time+1.
Maximum time is extended if necessary.
WARNING:
argument 'exp' must contain only untimed variables, otherwise
results will be unpredictible]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_untimed\_expr\_to\_times(BeEnc\_ptr self, const be\_ptr exp, const int ctime, const int ftime, const int itime, const int ntime)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given an untimed expression, shifts current, frozen, input and
next variables to given times]

Description        [Shifts untimed current state vars to time ctime, frozen
untimed vars to ftime, input untimed vars to itime, and untimed next
state vars to ntime.]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_untimed\_to\_timed\_and\_interval(BeEnc\_ptr self, const be\_ptr exp, const int from, const int to)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [<b>Makes an AND interval</b> of given expression using
<b>range \[<tt>from</tt>, <tt>to</tt>\]</b>]

Description        [Maximum time is extended if necessary.]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeEnc\_untimed\_to\_timed\_or\_interval(BeEnc\_ptr self, const be\_ptr exp, const int from, const int to)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [<b>Makes an OR interval</b> of given expression using
<b>range \[<tt>from</tt>, <tt>to</tt>\]</b>]

Description        [Maximum time is extended if necessary.]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void be\_enc\_init(BeEnc\_ptr self, SymbTable\_ptr symb\_table, BoolEnc\_ptr bool\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [The BeEnc class private initializer]

Description        [The BeEnc class private initializer]

SideEffects        []

SeeAlso            [BeEnc_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void be\_enc\_deinit(BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [The BeEnc class private deinitializer]

Description        [The BeEnc class private deinitializer]

SideEffects        []

SeeAlso            [BeEnc_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void be\_enc\_commit\_layer(BaseEnc\_ptr enc\_base, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Encodes all the boolean variables within the given
layer. If the given layer has an associated boolean layer (created
by the BoolEnc), that boolean layer will be encoded as well.]

Description        []

SideEffects        []

SeeAlso            [be_enc_remove_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void be\_enc\_remove\_layer(BaseEnc\_ptr enc\_base, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Removes the encoding of all variables occurring within
the given layer, and those that had been created within the corresponding
boolean layer during the boolean encoding (if there was any).
Then releases both the layers.]

Description        [Cleans up the shifting cache, as well as the memoizing
cache for the CNF-ization, that become potentially invalid.

WARNING: If the layer has been
renamed after having been committed, it is the *new* name (the name
the layer has when it is being removed) that must be used, and *not*
the name that had been used when commiting it.]

SideEffects        []

SeeAlso            [bdd_enc_commit_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [The BeEnc class virtual finalizer]

Description [Called by the class destructor]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_add\_vars(BeEnc\_ptr self, const SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Re-arranges the entire logical level in order to have the
boolean variables contained in the passed layer added to the
encoder. ]

Description [Timed blocks will get resized as well, and new
variables will be created accordingly. Names of added variables cannot occur
already within self.]

SideEffects []

SeeAlso     [be_enc_remove_vars]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void be\_enc\_remove\_var\_aux(BeEnc\_ptr self, int phy\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Private service of be_enc_remove_var]

Description [Remove any reference to the variable whose physical
index is provided. Sets the logical level to an invalid index where
the removed variable index was contained. This method has been
implemented to factorize code, and it is called only by
be_enc_remove_var]

SideEffects []

SeeAlso     [be_enc_remove_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void be\_enc\_remove\_var(BeEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Removes a variable whose name is provided]

Description [If it is a state var, it is not requested to explicitly
remove the corresponding next variable, as this operation is
automatically performed. Important: this method removes the variable
from both the logical and physical levels, and makes the
corresponding physical indices available for later new
instantiations. But this method does NOT side effect on the number of
variables, and the logical level have to be compacted be the caller,
that will have to calculate the new size as well.

This method should be called by be_enc_remove_vars only, and a
series of calls to this method must be followed by a call to
be_enc_compact_log_level]

SideEffects []

SeeAlso     [be_enc_remove_vars, be_enc_compact_log_level]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_remove\_vars(BeEnc\_ptr self, const SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Removes the sets of boolean variables in layer, and compacts the
logical level.]

Description [At the end of this call, the boolean variables of the
layer will be removed and the internal status will be ok]

SideEffects []

SeeAlso     [be_enc_add_vars]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_compact\_log\_level(BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Called after a serie of calls to be_enc_remove_var have
been done, to compact the logical level and fix the level's size. ]

Description [This method compacts the logical level, actually
removing all the unused indices, and making all the valid logical
indices close each other on the lowest logical indices. It also
adjusts fields input_vars_num and state_vars_num in order to make
them contain the real number of variables currently allocated. See
comments of be_enc_remove_var]

SideEffects []

SeeAlso     [be_enc_remove_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_instantiate\_var(BeEnc\_ptr self, node\_ptr name, int input\_vars\_delta, int state\_vars\_delta, int frozen\_vars\_delta, int ofs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Private service of method be_enc_add_vars]

Description [Allocates the given variable within a newly created
logical block (at given offset within that block). This function
factorizes code that whould be otherwise mostly duplicated within
be_enc_add_vars to build input, state and frozen vars.  deltas are the size
of the newly created blocks for input and state variables, i.e. the
number of newly created state and input variables. Notice that space within
the untimed and timed blocks must be already re-arranged. ]

SideEffects []

SeeAlso     [be_enc_remove_vars]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_allocate\_new\_log\_space(BeEnc\_ptr self, int input\_vars\_num, int state\_vars\_num, int frozen\_vars\_num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Rearranges (increasing) the logical level in order to host
the given number of new input and state variables]

Description [This method cannot be used to decrease the number of
variables. Use method remove_var instead. This method creates
(allocates) the needed space to hold a set of new variables, and
rearranges the logical level in order to contain the new variables
in the right order and place.  Notice that this method does not
create actual BE variables, that later will have to be created by
calling the method create_be_var passing to it the newly
allocated logical addresses. The new logical addresses comes from
the way logical indices are organized, following an internal rule
that the caller well knows.]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_move\_log\_block(BeEnc\_ptr self, int src\_idx, int dest\_idx, size\_t block\_size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Moves forward of backward a block of logical indices
within the logical level. The movement is carried out of a certain
block size.]

Description [src_idx and dest_idx provides the left starting
position and the destination position respectively. Source and
destination blocks can overlap. This method is a service of
be_enc_allocate_new_log_space ]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_extend\_timed\_blocks(BeEnc\_ptr self, int maxtime)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Extends the memory dedicated to the timed variables, in order
to host at least maxtime times. Then instantiates the variables and
sets up the physical<->logical conversion tables for all the necessary
timed blocks. ]

Description [The capacity might be chosen to be greater than the actual
needed size]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_allocate\_space\_for\_new\_vars(BeEnc\_ptr self, int vars\_num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Extends internal blocks of memory (those who keep the be
variables and the logical/physical level conversions).  After this
method is called, it is assured that there is enough space to hold
vars_num new variables, so vars_num is a delta wrt the currently
existing vars. ]

Description [This method allocates only the necessary space. It is a
task of the caller to actually create the new variables. Use the method
be_enc_create_be_var to actually create the variables.]

SideEffects []

SeeAlso     [be_enc_create_be_var]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_create\_be\_var(BeEnc\_ptr self, int logical\_idx, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Allocates a new be variable at the given logical index]

Description [Before calling this method make sure there exists
enough space to hold the new variable (see the method
be_enc_allocate_space_for_new_vars). If name is not NULL, the newly
created var will be associated to name]

SideEffects []

SeeAlso     [be_enc_allocate_space_for_new_vars]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int be\_enc\_index\_log\_untimed\_to\_timed(const BeEnc\_ptr self, int log\_idx, int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Converts an untimed logical index to a timed logical index
instantiated at given time]

Description [WARNING: If the given index corresponds to an untimed
next state var, the returned index will correspond to the
corresponding current state variable instantitated at time+1.

Frozen variables are shifted the same way as state variables with the
exception that physical indexes of a timed frozen variable and the
corresponding untimed one are the same.]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int be\_enc\_index\_log\_timed\_to\_untimed(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Converts a timed logical index to an untimed logical index]

Description [The returned index will be an untimed current state index,
an untimed frozen index or an untimed input index]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int be\_enc\_index\_log\_to\_time(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns the time at which given logical index is allocated]

Description [Value BE_CURRENT_UNTIMED is returned for untimed indices]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int be\_enc\_index\_log\_curr\_to\_next(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Converts a current state untimed logical index to a next
state untimed logical index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int be\_enc\_index\_log\_next\_to\_curr(const BeEnc\_ptr self, int log\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Converts a next state untimed logical index to a curr
state untimed logical index]

Description []

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int be\_enc\_get\_next\_avail\_phy\_index(BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Returns the first available physical index for a BE variable]

Description [Takes the index from the removed variables list, or
from the maximum allocated index if the list is empty. If the index
is taken from the list of removed vars, the index is also removed
from the list before returning it.]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_realloc\_subst\_array(BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Reallocates the substitution array if needed]

Description [The substitution array is used when a substitution operation
is required to be performed on a BE expr. The array is allocated on demand
when necessary, i.e. when the size of the array changed wrt the previous
allocation.]

SideEffects []

SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr be\_enc\_shift\_exp\_at\_time(BeEnc\_ptr self, const be\_ptr exp, int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Shifts the given expression exp by shifting
at logical level all the variables in exp at the given time.]

Description        [This is an internal (private) service of
the BE encoding. Memoizing associates the given exp with the given time.
time can be >= 0 for timed shifting, or can be a constant of the family
BE_ENC_*_TIME for untimed shifting.

Note: the expression has to contain only untimed vars otherwise the
behaviour is undefined.]

SideEffects        []

SeeAlso            [be_enc_shift_exp_at_times]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static be\_ptr be\_enc\_shift\_exp\_at\_times(BeEnc\_ptr self, const be\_ptr exp, int c\_time, int f\_time, int i\_time, int n\_time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Shifts the given expression exp by shifting
the variables in exp by the given times at logical level.]

Description        [An absolute time is given for every type:
current state, frozen, input and next state variables, respectively.
This is an internal (private) service of the BE encoding.

Note: the function implements memoizing. Memoizing assocates the given
exp with the given times.

Note: This function is less efficient than be_enc_shift_exp_at_time
because here an array of the size of the untimed block is created and
initialized. There are no other slowdowns.

Note: the expression have to contain only untimed vars otherwise the
behaviour is undefined.
]

SideEffects        []

SeeAlso            [be_enc_shift_exp_at_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_enc\_clean\_shift\_hash(BeEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Empties the content of the shifting cache]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{bool}
		
	\subsection{BitValues.c}
		
	\texttt{BitValues\_ptr BitValues\_create(BoolEnc\_ptr enc, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BitValues class constructor]

  Description        [The BitValues class constructor]

  SideEffects        []

  SeeAlso            [BitValues_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BitValues\_destroy(BitValues\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BitValues class destructor]

  Description        [The BitValues class destructor]

  SideEffects        []

  SeeAlso            [BitValues_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{size\_t BitValues\_get\_size(const BitValues\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of bits inside self]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BitValues\_get\_scalar\_var(const BitValues\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the scalar variable self is a value for]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr BitValues\_get\_bits(const BitValues\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of names of internal bits]

  Description [Returned list belongs to self, do not destroy or
  change it. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BitValues\_reset(BitValues\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Resets the values of bits to BIT_VALUE_DONTCARE]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BitValues\_set(BitValues\_ptr self, size\_t index, BitValue val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets ith bit value to the given value]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BitValues\_set\_from\_expr(BitValues\_ptr self, size\_t index, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Sets ith bit value to the given value that is given as
  node_ptr]

  Description        [expr can be either TRUE or FALSE]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BitValue BitValues\_get(const BitValues\_ptr self, size\_t index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the value of ith bit]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BitValues\_set\_from\_values\_list(BitValues\_ptr self, const BoolEnc\_ptr enc, node\_ptr vals)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a list of assignments (IFF or EQUAL) to bits,
  sets values]

  Description        [The list can be partial, unspecified values are set to
  BIT_VALUE_DONCARE]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BitValue BitValues\_get\_value\_from\_expr(const BitValues\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a TRUE or FALSE expression, returns the
  corresponding BitValue]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bit\_values\_array\_init(BitValues\_ptr self, BoolEnc\_ptr enc, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BitValues class private initializer]

  Description        [The BitValues class private initializer]

  SideEffects        []

  SeeAlso            [BitValues_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bit\_values\_array\_deinit(BitValues\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BitValues class private deinitializer]

  Description        [The BitValues class private deinitializer]

  SideEffects        []

  SeeAlso            [BitValues_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{BoolEnc.c}
		
	\texttt{BoolEnc\_ptr BoolEnc\_create(SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolEnc class constructor]

  Description        [The BoolEnc class constructor]

  SideEffects        []

  SeeAlso            [BoolEnc_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void BoolEnc\_destroy(BoolEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolEnc class destructor]

  Description        [The BoolEnc class destructor]

  SideEffects        []

  SeeAlso            [BoolEnc_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BoolEnc\_is\_var\_bit(const BoolEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is the name of
  a bit variable that is part of a scalar var]

  Description        []

  SideEffects        []

  SeeAlso            [BoolEnc_get_scalar_var_of_bit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BoolEnc\_is\_var\_scalar(const BoolEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given symbol is the name of
  a scalar (non-boolean) variable]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BoolEnc\_get\_scalar\_var\_from\_bit(const BoolEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the name of the scalar variable whose
  the given bit belongs]

  Description        [Returns the name of the scalar variable whose
  the given bit belongs. The given var MUST be a bit]

  SideEffects        []

  SeeAlso            [BoolEnc_is_var_bit, BoolEnc_get_index_from_bit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BoolEnc\_make\_var\_bit(const BoolEnc\_ptr self, node\_ptr name, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a scalar variable name, construct the name for
                      the nth-indexed bit.]

  Description        [Constructs and returns the name of the nth-indexed bit
                      of the given scalar variable]

  SideEffects        []

  SeeAlso            [BoolEnc_is_var_bit, BoolEnc_get_index_from_bit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BoolEnc\_get\_index\_from\_bit(const BoolEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the index of given bit.]

  Description        [The given var MUST be a bit]

  SideEffects        []

  SeeAlso            [BoolEnc_is_var_bit, BoolEnc_get_scalar_var_from_bit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr BoolEnc\_get\_var\_bits(const BoolEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the list of boolean vars used in the encoding of
  given scalar var]

  Description        [Returned list must be destroyed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BoolEnc\_get\_var\_encoding(const BoolEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a variable, returns its boolean encoding]

  Description        [Given variable must have been encoded by self]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BoolEnc\_get\_values\_bool\_encoding(const BoolEnc\_ptr self, node\_ptr values, Set\_t* bits)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given a set of constants values (for example, the domain
                    of a scalar variable), calculates its boolean
                    encoding by introducing boolean symbols that
                    are returned along with the resulting
                    encoding.]

Description        [This method can be used to retrieve the boolean
                    encoding of a given set of symbols.

                    For example, it may be used to calculate the
                    boolean encoding representing the domain of a
                    scalar variable which has not been added to any
                    layer. It returns the boolean encoding
                    (typically a ITE node) and the set of boolean
                    symbols (bits) that have been introduced in the
                    encoding. Important: the introduced boolean
                    symbols are not variables, as they are not
                    declared into the symbol table. It is up to the
                    caller later to declare them if needed.

                    The introduced symbol names are guaranteed to
                    be not among the currently declared symbols.

                    To retrieve the boolean encoding of an existing
                    (and committed) variable, use method
                    get_var_encoding instead.]

SideEffects        [Passed set is filled with symbol bits occurring in the
                     encoding. No memoization or change is performed.]

SeeAlso            [BoolEnc_get_var_encoding]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BoolEnc\_get\_var\_mask(const BoolEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a variable, it returns the mask of its encoding]

  Description        [Returns an expression representing the mask that
  removes repetitions of leaves in a variable encoding by assigning
  value false to don't care boolean variables.Forr Boolean variables
  it returns the expression TRUE. Similarly for Word variables (since
  for words there are non redundant assignments).

  As an example of what this function does, let us consider a variable
  x having range 0..4. It can be encoded with 3 bits are needed to
  encode it: x0, x1, x2. The encodeding performed by NuSMV is

     ITE(x0, ITE(x1, 1, 3), ITE(x1, 2, ITE(x2, 4,  0))).

  Thus x=2 corresponds to assignment !x0&x1 where x2 is a dont'care.
  Similarly for x=1 and x=3 (for x=0 and x=4) there is a unique
  complete assignment to the x0, x1, x2 variables that represent the
  respective encoding). This function fixes a value for x2 in the
  assignments representing x=2, x=1 and x=3 respectively (it force x2
  to be false). Thus it builds the formula in this case:

     ITE(x0, ITE(x2, 0, 1), ITE(x1, 1, ITE(x2, 0,  1)))

  that removes the redundant assignments where needed.

  Result is memoized. See issue 0925 for further details.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BoolEnc\_get\_value\_from\_var\_bits(const BoolEnc\_ptr self, const BitValues\_ptr bit\_values)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given a BitValues instance already set with an
  assigments for its bits, returns the corresponding value for the
  scalar or word variable whose bits are onctained into the
  BitValues instance]

  Description [Returns an ATOM, a NUMBER, an NUMBER_UNSIGNED_WORD,
  etc. depending on the kind of variable. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_enc\_init(BoolEnc\_ptr self, SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolEnc class private initializer]

  Description        [The BoolEnc class private initializer]

  SideEffects        []

  SeeAlso            [BoolEnc_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_enc\_deinit(BoolEnc\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolEnc class private deinitializer]

  Description        [The BoolEnc class private deinitializer]

  SideEffects        []

  SeeAlso            [BoolEnc_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void bool\_enc\_commit\_layer(BaseEnc\_ptr base\_enc, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Encodes all variables within the given layer]

  Description [A new layer will be constructed if there is not yet
  any.  The new layer will be called ${layer_name}_bool and will be
  added to the symbol table that self uses. The new layer will be
  locked by self either until the layer is was originally created from
  is released or until self is destroyed. Given a committed layer, it
  is always possible to obtain the corresponding created boolean layer
  by calling BoolEnc_scalar_layer_to_bool_layer. ]

  SideEffects        [A new layer will be created if not already existing]

  SeeAlso            [bool_enc_remove_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void bool\_enc\_remove\_layer(BaseEnc\_ptr base\_enc, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the encoding of all variables occurring within
  the given layer, and those that had been created within the corresponding
  boolean layer during the boolean encoding. Then releases both the layers,
  and removes the boolean layer from the symbol table.]

  Description        [  WARNING: If the layer has been
  renamed after having been committed, it is the *new* name (the name
  the layer has when it is being removed) that must be used, and *not*
  the name that had been used when commiting it.]

  SideEffects        []

  SeeAlso            [bool_enc_commit_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* BoolEnc\_scalar\_layer\_to\_bool\_layer(const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given the name of a scalar layer, a name of the
  corresponding boolean layer is returned.]

  Description        [Returned string should NOT be modified or freed.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BoolEnc\_is\_bool\_layer(const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Determines if a layer name corresponds to a bool layer]

  Description [Given the name of a layer, returns true if it is the
  name of a boolean layer.]

  SideEffects  [None]

  SeeAlso      [BoolEnc_scalar_layer_to_bool_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static VIRTUAL void bool\_enc\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The BoolEnc class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bool\_enc\_encode\_var(BoolEnc\_ptr self, node\_ptr var, SymbLayer\_ptr src\_layer, SymbLayer\_ptr dest\_layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Encodes a single variable ]

  Description [If it is a scalar variable, its values are expanded and a
  set of bits (new boolean variables) will be created within the
  dest_layer. All leaves (constant values of the values) will be
  created within the src_layer, it they are not defined yet.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bool\_enc\_encode\_scalar\_var(BoolEnc\_ptr self, node\_ptr name, int suffix, node\_ptr values, SymbLayer\_ptr src\_layer, SymbLayer\_ptr dest\_layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Encodes a scalar variable, by creating all boolean vars
  (bits) needed to encode the var itself. Created bool vars are pushed
  within the given destination layer. ]

  Description [The returned structure is a tree, whose internal nodes
  are ITE nodes or BITS variables, and leaves are constants values.

  <expr> :: ITE ( COLON (bit, left), right) |
            constant

  where bit is a variable name (a bit), and left and right are <expr>.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean bool\_enc\_is\_boolean\_range(node\_ptr values)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return true if the given list is {TRUE,FALSE}]

  Description        [Return true if the given list is {TRUE,FALSE}]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{/* this is the default encoding */ static node\_ptr bool\_enc\_compute\_set\_encoding(const BoolEnc\_ptr self, node\_ptr set, node\_ptr bit\_prefix, int bit\_suffix, Set\_t* out\_bits, boolean top)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Computes the boolean encoding of which can be used to
            represent a set of values.]

            Description [Constructs a ITEs tree whose leaves are
            the values occurring in the input set, in a logarithmic
            boolean encoding. Conditions of the ITEs are BIT nodes
            whose name is constructed by using bit_prefix and
            bit_suffix values.

            Returns the containing the boolean logarithmic
            encoding, and as output parameter the set of BITs nodes
            used in the encoding.]

  SideEffects        [BITs nodes are added to the out_bits set]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bool\_enc\_set\_var\_encoding(BoolEnc\_ptr self, node\_ptr name, node\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Associates the given variable with the specified
  boolean encoding]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bool\_enc\_get\_var\_encoding(const BoolEnc\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a variable, returns its boolean encoding, or NULL
  if not encoded]

  Description        [Private service]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bool\_enc\_traverse\_encoding(const BoolEnc\_ptr self, node\_ptr enc, NodeList\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Fills the given list with the BIT vars which
  occurs into the given var encoding]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr bool\_enc\_get\_var\_mask\_recur(const BoolEnc\_ptr self, node\_ptr enc, NodeList\_ptr cube, ListIter\_ptr cube\_iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a variable, it returns the mask of its encoding]

  Description        [Returns an expression representing the mask that
  removes repetitions of leaves in a variable encoding.  This function
  assumes that the order in which we encounter variables in the
  expression representing the boolean encoding is the same as cube.

  As an example of what this function does, let us consider a variable
  x having range 0..4. It can be encoded with 3 bits are needed to
  encode it: x0, x1, x2. The encodeding performed by NuSMV is

     ITE(x0, ITE(x1, 1, 3), ITE(x1, 2, ITE(x2, 4,  0))).

  Thus x=2 corresponds to assignment !x0&x1 where x2 is a dont'care.
  Similarly for x=1 and x=3 (for x=0 and x=4) there is a unique
  complete assignment to the x0, x1, x2 variables that represent the
  respective encoding). This function fixes a value for x2 in the
  assignments representing x=2, x=1 and x=3 respectively (it force x2
  to be false). Thus it builds the formula in this case:

     ITE(x0, ITE(x2, 0, 1), ITE(x1, 1, ITE(x2, 0,  1)))

  that removes the redundant assignments where needed. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{utils}
		
	\subsection{AddArray.c}
		
	\texttt{AddArray\_ptr AddArray\_create(int number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [constructor. Create an array of "number" ADDs]

  Description        [number must be positive. The index of the
  array goes from 0 to (number - 1).]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_from\_word\_number(DdManager* dd, WordNumber\_ptr wn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a new AddArray from given WordNumber]

  Description [Returned add array has the same width as the given word
  number]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_from\_add(add\_ptr add)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [given an ADD create an AddArray consisting of
  one element]

  Description        [Given ADD must already be referenced.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_duplicate(AddArray\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [create a new AddArray, a copy of a given one]

  Description        [During duplication all ADD will be referenced.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void AddArray\_destroy(DdManager* dd, AddArray\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [destructor of the class]

  Description        [The memory will be freed and all ADD will be
  de-referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int AddArray\_get\_size(AddArray\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns the size (number of elements) of the array]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr AddArray\_get\_add(AddArray\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This function returns the first element of
  the array]

  Description        [The array should contain exactly one element]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr AddArray\_get\_n(AddArray\_ptr self, int number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the element number "n" from
  the array.]

  Description        ["n" can be from 0 to (size-1).
  The returned ADD is NOT referenced.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t* AddArray\_get\_array(AddArray\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the AddArray represented as an array of ADDs.]

  Description        [Do not change the returned array, which belongs to self]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{size\_t AddArray\_get\_add\_size(const AddArray\_ptr self, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the sum of the sizes of the ADDs within self]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void AddArray\_set\_n(AddArray\_ptr self, int number, add\_ptr add)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the element number "number" to "add".]

  Description        [The given ADD "add" must already be referenced.
  The previous value should already be de-referenced if it is necessary.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_apply\_unary(DdManager* dd, AddArray\_ptr arg1, FP\_A\_DA op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Applies unary operator to each bit of given argument, and
  returns resulting add array]

  Description        [Returned AddArray must be destroyed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_apply\_binary(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2, FP\_A\_DAA op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Applies binary operator to each bits pair of given
  arguments, and returns resulting add array]

  Description        [Returned AddArray must be destroyed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr AddArray\_make\_disjunction(DdManager* dd, AddArray\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns an ADD that is the disjunction of all bits of arg]

  Description        [Returned ADD is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{add\_ptr AddArray\_make\_conjunction(DdManager* dd, AddArray\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns an ADD that is the conjunction of all bits of arg]

  Description        [Returned ADD is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_plus(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the addition operations
  on two Word expressions represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The size of both arguments should be the same.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_minus(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the subtraction operations
  on two Word expressions represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The size of both arguments should be the same.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unary\_minus(DdManager* dd, AddArray\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Changes the sign of the given word.]

  Description        [The return expression is equal to (0 - arg) ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_times(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the multiplication operations
  on two Word expressions represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The size of both arguments should be the same.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_divide(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the division operations
  on two unsigned Word expressions represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The size of both arguments should be the same.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_mod(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the remainder operations
  on two unsigned Word expressions represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The size of both arguments should be the same.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_divide(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the division operations
  on two singed Word expressions represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The size of both arguments should be the same.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_mod(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the remainder operations
  on two signed Word expressions represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The size of both arguments should be the same.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_left\_shift(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs left shift operations
  on a Word expression represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The "number" argument represent
  the number of bits to shift. "number" can be a usual integer (and
  consist of one ADD) or be an unsigned word (and consist of many ADDs).
  NB: The invoker should destroy the returned array.

  NB for developers:
  Every i-th bit of returned array will be:
       ITE(number=0 , arg[i],
           ITE(number=1, arg[i-1],
            ...
             ITE(number=i, arg[0],
              ITE(number >=0 && number <= width, zero, FAILURE)
   Does anyone know a better encoding?
]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_right\_shift(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Invokes add_array_word_right_shift with isSigned set to
  false]

  Description        [See add_array_word_right_shift.]

  SideEffects        []

  SeeAlso            [add_array_word_right_shift]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_right\_shift(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Invokes add_array_word_right_shift with isSigned set to
  true]

  Description        [See add_array_word_right_shift.]

  SideEffects        []

  SeeAlso            [add_array_word_right_shift]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_left\_rotate(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs left rotate operations
  on a Word expression represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The "number" argument represent
  the number of bits to rotate. "number" should have only one ADD.
  NB: The invoker should destroy the returned array.

  NB for developers:
  Every i-th bit  of returned array will be:
       ITE(number=0 , arg[i],
           ITE(number=1, arg[i-1],
            ...
             ITE(number=i, arg[0],
              ITE(number=i+1, arg[width-1],
               ...
               ITE(number=width-1, arg[i+1],
                ITE(number=width, arg[i], FAILURE]
   Does anyone have a better encoding?
]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_right\_rotate(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs right rotate operations
  on a Word expression represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The "number" argument represent
  the number of bits to rotate. "number" should have only one ADD.
  NB: The invoker should destroy the returned array.

  NB for developers:
  Every i-th bit of returned array will be:
       ITE(number=0 , arg[i],
           ITE(number=1, arg[i+1],
            ...
             ITE(number=width-1-i, arg[width-1],
              ITE(number=width-2-i, arg[0],
               ...
               ITE(number=width-1, arg[i-1],
                ITE(number=width, arg[i], FAILURE]
   Does anyone have a better encoding?
]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_less(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs less-then operation
  on two unsigned Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.
]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_less\_equal(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs less-or-equal operation
  on two unsigned Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_greater(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs greater-then operation
  on two unsigned Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.
]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_greater\_equal(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs greater-or-equal operation
  on two unsigned Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.
]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_less(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs _signed_ less-then operation
  on two Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_less\_equal(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs _signed_ less-equal-then operation
  on two Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_greater(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs _signed_ greater-then operation
  on two Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_greater\_equal(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs _signed_ greater-equal-then operation
  on two Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_extend(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr arg\_repeat)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Extends the width of a signed Word expression keeping
  the value of the expression]

  Description        [This extension means that the sign (highest) bit
  is added 'arg_repeat' times on the left.
  'arg_repeat' has to be a constant number.
  ]

  SideEffects        []

  SeeAlso            [AddArray_word_extend]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_extend(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr arg\_repeat)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Extends the width of an unsigned Word expression keeping
  the value of the expression]

  Description        [This extension means that the zero bit
  is added 'arg_repeat' times on the left.
  'arg_repeat' has to be a constant number.
  ]

  SideEffects        []

  SeeAlso            [AddArray_word_signed_extend]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_equal(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs equal-operation
  on two Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_not\_equal(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs not-equal-operation
  on two Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [the size of arguments should be the same
  The returned array will constain only one (boolean) ADD.
  NB: The invoker should destroy the returned array.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_ite(DdManager* dd, AddArray\_ptr \_if, AddArray\_ptr \_then, AddArray\_ptr \_else)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Creates a ITE word array:
  {ITE(_if, _then[N-1], _else[N-1]),
   ITE(_if, _then[N-2], _else[N-2]),
   ...
   ITE(_if, _then[1], _else[1]),
   ITE(_if, _then[0], _else[0])}

  If _else consist of 1 ADD but _then does not then the same _else[0] is used
  in all ITE. (this is used to pass FAILURE ADD). Otherwise size of _then and _else
  have to be the same.
  _if has to be of 1 bit width.
  Returned array width is as large as _then.]

  Description        [The invoker should destroy the returned array.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_bit\_selection(DdManager* dd, AddArray\_ptr word, AddArray\_ptr range)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs bit-selection operation
  on a Word expression represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The high-bit and low-bit of selections
  are specified by "range". "range" must
  be ADD leafs with a RANGE node (holding two integer constants,
  and these constant must be in the range [width-1, 0]).
  NB: The invoker should destroy the returned array.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_signed\_resize(DdManager* dd, AddArray\_ptr word, AddArray\_ptr new\_size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Performs signed resize operation on a Word expression
  represented as arrays of ADD.  Every ADD corresponds to a bit of a
  Word expression]

  signed resize semantics. "new_size" must be ADD leafs with a NUMBER
  node.NB: The invoker should destroy the returned array.]

  SideEffects        []

  SeeAlso            [AddArray_word_unsigned_resize]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_unsigned\_resize(DdManager* dd, AddArray\_ptr word, AddArray\_ptr new\_size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Performs signed resize operation on a Word expression
  represented as arrays of ADD.  Every ADD corresponds to a bit of a
  Word expression]

  signed resize semantics. "new_size" must be ADD leafs with a NUMBER
  node.NB: The invoker should destroy the returned array.]

  SideEffects        []

  SeeAlso            [AddArray_word_signed_resize]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr AddArray\_word\_concatenation(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs concatenation operation
  on two Word expressions represented as arrays of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [
  NB: The invoker should destroy the returned array.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void add\_array\_full\_adder(DdManager* dd, add\_ptr arg1, add\_ptr arg2, add\_ptr carry\_in, add\_ptr* sum, add\_ptr* carry\_out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performes the full-adder operation on the arguments arg1, arg2
  and carry_in. The returned sum-bit and carry-bit are returned in
  sum and carry_out.]

  Description [The returned ADD (sum and carry_out) are referenced.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void add\_array\_adder(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2, add\_ptr carry\_in, AddArray\_ptr* res, add\_ptr* carry\_out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performes the addition of two Word expressions and
  a carry-in bit.]

  Description [The sum is returned by the parameter res (the invoker
  must destroy this array), and the final carry-bit is returned by the
  parameter carry_out (the ADD is referenced).
  The size of input arrays must be equal(and positive). ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr add\_array\_word\_plus\_negated\_and\_one(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2, add\_ptr* carry)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform "arg1 + (not arg2) + 1"
  of two Word expressions represented as an array of ADD.
  This operation correspond to the subtraction operations.
  ]

  Description        [The size of both arguments should be the same.
  'carry' must be not zero and is used to return carry bit of
  performed operation.
  Note the overflow or underflow can be detected by checking (not
  carry-bit).]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void add\_array\_unsigned\_division\_remainder(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2, AddArray\_ptr* quotient, AddArray\_ptr* remainder)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performs division operations on two unsigned Word expressions
  (which are encoded as arrays of bits)]

  Description [The quotient and the remainder is returned in the
  parameters "quotient" and "remainder" respectively.
  The invoker should free the returned arrays.

  The size of arguments should be the same (and positive).

  Every bit of the resulting arrays is wrapped in ITE which check
  the second argument (of the operation) for not being zero.]

  SideEffects []

  SeeAlso     [add_array_signed_division_remainder]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void add\_array\_signed\_division\_remainder\_simple(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2, AddArray\_ptr* quotient, AddArray\_ptr* remainder)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performs division operations on two unsigned Word expressions
  (which are encoded as arrays of bits)]

  Description [The quotient and the remainder is returned in the
  parameters "quotient" and "remainder" respectively.
  The invoker should free the returned arrays.

  The size of arguments should be the same (and positive).

  Every bit of the resulting arrays is wrapped in ITE which check
  the second argument (of the operation) for not being zero.

  NOTE FOR DEVELOPER: the provided functionality was implemented in
  two forms: as function add_array_signed_division_remainder_simple
  (which is the simplest) and as function
  add_array_signed_division_remainder_harware (which resembles the
  hardware implemenation of signed division). Preliminary benchmarking
  showed that add_array_signed_division_remainder_harware runs quicker
  (so it is used now).  Proper benchmarks are still needed to choose
  one and remove the other one.  ]

  SideEffects []

  SeeAlso     [add_array_unsigned_division_remainder,
  add_array_signed_division_remainder_harware]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void add\_array\_signed\_division\_remainder\_hardware(DdManager* dd, AddArray\_ptr arg1, AddArray\_ptr arg2, AddArray\_ptr* quotient, AddArray\_ptr* remainder)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performs division operations on two unsigned Word expressions
  (which are encoded as arrays of bits)]

  Description [The quotient and the remainder is returned in the
  parameters "quotient" and "remainder" respectively.
  The invoker should free the returned arrays.

  The size of arguments should be the same (and positive).

  Every bit of the resulting arrays is wrapped in ITE which check
  the second argument (of the operation) for not being zero.

  NOTE FOR DEVELOPER: the provided functionality was implemented in
  two forms: as function add_array_signed_division_remainder_simple
  (which is the simplest) and as function
  add_array_signed_division_remainder_harware (which resembles the
  hardware implemenation of signed division). Preliminary benchmarking
  showed that add_array_signed_division_remainder_harware runs quicker
  (so it is used now).  Proper benchmarks are still needed to choose
  one and remove the other one.  ]

  SideEffects []

  SeeAlso     [add_array_signed_division_remainder_simple]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static add\_ptr add\_array\_create\_default\_value\_of\_shift\_operation(DdManager* dd, AddArray\_ptr number, int width, add\_ptr defaultBit, const char* errMessage)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Create an ADD of the default case in shift operations, i.e. ADD of
  ITE(nubmer >=0 && number <= width, zero, FAILURE).
  ]

  Description [This function is used in shift operations.
  See, for example, AddArray_word_left_shift.

  The 'number' is ADD of the number of bit the Word is shifted.
  'width' is the width of the given Word expression.
  'defaultBit' is a bit which pads the shifted bit.
  'errMessage' is the error message to print if number is out of range,
  for example, "Right operand of left-shift is out of range".

  NB: The returned ADD is referenced.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr add\_array\_negate\_bits(DdManager* dd, AddArray\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [A function takes an array and negates every bit of it]

  Description [the result of the functions is a new array
        [!arg[0], !arg[1],  ..., !arg[width-1]].

  NB: The invoker should free the returned array.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr add\_array\_word\_extend(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr arg\_repeat, add\_ptr paddingBit)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Extends the width of a Word expression by padding the
  expression with a padding bit on the left (i.e. highest bits)]

  Description [This extension means that a padding bit (paddingBit) is
  added 'arg_repeat' times on the left.  'arg_repeat' has to be a
  constant number.]

  SideEffects []

  SeeAlso     [AddArray_word_signed_extend, AddArray_word_unsigned_extend]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{AddArray\_ptr add\_array\_word\_right\_shift(DdManager* dd, AddArray\_ptr arg, AddArray\_ptr number, boolean isSigned)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs right shift operations
  on a Word expression represented as an array of ADD.
  Every ADD corresponds to a bit of a Word expression]

  Description        [The "number" argument represent
  the number of bits to shift. "number" should have only one ADD.
  "isSigned" is a flag that the word is signed or unsigned.

  NB: The invoker should destroy the returned array.

  Every i-th bit of returned array will be:
       ITE(number=0 , arg[i],
           ITE(number=1, arg[i+1],
            ...
             ITE(number=width-1-i, arg[width-1],
              ITE(number >=0 && number <= width, SpecBit, FAILURE)
   where SpecBit is zero for unsigned words (isSigned==false) and
   arg[width-1] for signed words (isSigned==true).

   Does anyone have a better encoding?
]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static AddArray\_ptr add\_array\_word\_signed\_comparison(DdManager* dd, APFDAA op, AddArray\_ptr arg1, AddArray\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Private service]

  Description [op can be: any signed relational functions such as
  AddArray_word_less, AddArray_word_less_equal, etc]

  SideEffects []

  SeeAlso     [AddArray_word_signed_less, AddArray_word_signed_less_equal,
  AddArray_word_signed_greater, AddArray_word_signed_greater_equal]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline boolean add\_array\_is\_word(DdManager* dd, const AddArray\_ptr number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Private service]

  Description [Checks whether the given AddArray is a word or not.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{OrdGroups.c}
		
	\texttt{OrdGroups\_ptr OrdGroups\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class constructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{OrdGroups\_ptr OrdGroups\_copy(const OrdGroups\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class copy constructor]

  Description        [Returned instance is a copy of self]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void OrdGroups\_destroy(OrdGroups\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class destructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int OrdGroups\_create\_group(OrdGroups\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new group, and returns the group ID for 
  future reference]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void OrdGroups\_add\_variable(OrdGroups\_ptr self, node\_ptr name, int group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Adds a new variable to the groups set.]

  Description [The addition is performed only if the variable has not
  been already added to the same group.  If the variable has been
  already added but to a different group, an error occurs. The group 
  must be already existing.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void OrdGroups\_add\_variables(OrdGroups\_ptr self, NodeList\_ptr vars, int group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Adds a list of variable to the groups set.]

  Description [The addition of each variable is performed only if the
  variable has not been already added to the same group.  If the
  variable has been already added but to a different group, an error
  occurs. The group must be already existing.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr OrdGroups\_get\_vars\_in\_group(const OrdGroups\_ptr self, int group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the set of variables that belong to a given group]

  Description        [Returned list instance still belongs to self.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int OrdGroups\_get\_var\_group(const OrdGroups\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given a var name, it returns the group that variable
  belongs to.]

  Description [-1 is returned if the variable does not belong to any
  group.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int OrdGroups\_get\_size(const OrdGroups\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of available groups]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ord\_groups\_init(OrdGroups\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private class initializer]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ord\_groups\_copy(const OrdGroups\_ptr self, OrdGroups\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private class copier]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ord\_groups\_deinit(OrdGroups\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private deinitializer]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int ord\_groups\_allocate\_new\_group(OrdGroups\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new group, and returns its ID]

  Description [Extends the array of groups if needed. Extension is
  performed with a grow factor.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int ord\_groups\_name\_to\_group(OrdGroups\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a variable name, it returns the group that variable 
  belongs to, or -1 if the variable has not been added.]

  Description        [use this method to access the hash table name_to_group, 
  as the way goups are stored within it is very tricky.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ord\_groups\_associate\_name\_to\_group(OrdGroups\_ptr self, node\_ptr name, int group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Associates a var name to an existing group, but only if
  not already associated. An error occurs if the given name is already
  associated to a different group]

  Description        [Use this method to access to the hash name_to_group, 
  as values are stored in a tricky way.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{utils.c}
		
	\texttt{OrdGroups\_ptr enc\_utils\_parse\_ordering\_file(const char* order\_filename, const BoolEnc\_ptr bool\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Parses the given ordering file, and produces an OrdGroups 
  instance.]

  Description [The returned instance belongs to the caller. It is a
  caller's responsability to destroy it. order_filename can be NULL]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{OrdGroups\_ptr enc\_utils\_create\_vars\_ord\_groups(BoolEnc\_ptr bool\_enc, NodeList\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given a list of variables representing a new variable ordering, 
  produces an OrdGroups instance.]

  Description [The returned instance belongs to the caller. It is a
  caller's responsability to destroy it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{enc.c}
		
	\texttt{void Enc\_init\_encodings()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the encoding package]

  Description        [This function initializes only data-structures
  global to all encoding.
  To initialize particular incoding, you have to invoke corresponding
  init-functions, such as Enc_init_bool_encoding, etc.]

  SideEffects        []

  SeeAlso            [Enc_init_bool_encoding, Enc_init_bdd_encoding,
  Enc_reinit_bdd_encoding, Enc_quit_encodings]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_add\_commands()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds commands related to Enc package]

  Description        [

  SideEffects        []

  SeeAlso            [Enc_init_encodings]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_init\_bool\_encoding()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the boolean encoding for this session]

  Description        [Call it to initialize for the current session the
  encoding, before flattening. In the current implementation, you must
  call this *before* the flattening phase. After the flattening,
  you must initialize the bdd encoding as well, and after you created the
  boolean sexp fsm, you must reinitialize the bdd encodings by calling
  Enc_reinit_bdd_encoding. Don't forget to call Enc_quit_encodings when
  the session ends. ]

  SideEffects        []

  SeeAlso            [Enc_init_bdd_encoding, Enc_reinit_bdd_encoding,
  Enc_quit_encodings]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_init\_bdd\_encoding()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the bdd enc for this session]

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_init\_be\_encoding()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the be enc for this session]

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_quit\_encodings()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call to destroy all encodings, when session ends]

  Description        [Call to destroy encodings, when session ends.
  Enc_init_encodings had to be called before calling this function.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BoolEnc\_ptr Enc\_get\_bool\_encoding(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddEnc\_ptr Enc\_get\_bdd\_encoding(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BeEnc\_ptr Enc\_get\_be\_encoding(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_set\_bool\_encoding(BoolEnc\_ptr benc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the global boolean encoding]

  Description [Set the global boolean encoding. If benc is NULL
  previous encoder is detroyed before the new assignment]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_set\_bdd\_encoding(BddEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the global bdd encoding]

  Description [Set the global bdd encoding. If enc is NULL,
  previously set encoder is detroyed before the new assignment]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_set\_be\_encoding(BeEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the global be encoding]

  Description [Set the global be encoding. If enc is NULL,
  previoulsy set encoder is detroyed before the new assignment]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Enc\_append\_bit\_to\_sorted\_list(SymbTable\_ptr symb\_table, NodeList\_ptr sorted\_list, node\_ptr var, node\_ptr* sorting\_cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Given a boolean variable or a bit the function inserts it
   into the sorted list at proper position]

   Description [
   The higher bits are added to the beginning of the
   list and lower bits are added at the end. The boolean variables
   are added at the beginning of the list before the bits.

   A new element is added at the end of the group of equal elements,
   e.g. a boolean var is added after existing boolean vars but before
   the bit vars.

   Parameter 'sorting_cache' is used to speed up insertion (sorting a
   list will be linear instead of quadratic).  Initially
   'sorting_cache' has to point to a pointer which points to Nil and
   sorted_list has to be an empty list. It is the invoker
   responsibility to free the sorted list and cache (with free_list)
   after last invoking Enc_append_bit_to_sorted_list (the same
   sorting_cache and sorted_list can be used for several runs of this
   function).
   ]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Enc\_vars\_ord\_to\_string(VarsOrdType vot)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the string corresponding to give parameter]

  Description        [Returned string does not have to be freed]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VarsOrdType Enc\_string\_to\_vars\_ord(const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts a string to the corresponding var order type.]

  Description        [VARS_ORD_UNKNOWN is returned when the string does not
  match the given string]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Enc\_get\_valid\_vars\_ord\_types()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a string of all possible values for
  vars_ord_type]

  Description        [Returned string does not have to be freed]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Enc\_bdd\_static\_order\_heuristics\_to\_string(BddSohEnum value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the string corresponding to give parameter]

  Description        [Returned string does not have to be freed]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddSohEnum Enc\_string\_to\_bdd\_static\_order\_heuristics(const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Converts a string to the corresponding BDD Static Order Heuristics.]

  Description [BDD_STATIC_ORDER_HEURISTICS_ERROR is returned when the
  string does not match the given string]

  SideEffects []

  SeeAlso     []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Enc\_get\_valid\_bdd\_static\_order\_heuristics()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a string of all possible values for
  bdd_static_order_heuristics]

  Description        [Returned string does not have to be freed]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void enc\_construct\_bdd\_order\_statically(FlatHierarchy\_ptr flat\_hierarchy, OrdGroups\_ptr ord\_groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The function is trying to construct a BDD var order using
  heuristics by analyzing the flattened model]

  Description [Shell variable vars_order_type is use to infer the initial order
  to begin the analysis. Then analyzing the flattened model and using heuristics
  the order is tried to improve.
  The kind of heuristics to be used is defined by shell variable
  bdd_static_order_heuristics.

  The final order is returned in ord_groups which has to be empty at
  the beginning.]

  SideEffects []

  SeeAlso     []
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{encCmd.c}
		
	\texttt{static int CommandCleanSexp2BDDCache(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements the cleaning BDD cache]

  CommandName        [clean_sexp2bdd_cache]

  CommandSynopsis    [Cleans the cache used during evaluation of 
  expressions to ADD and BDD representations.]  

  CommandArguments   [\[-h\] ]  

  CommandDescription [ During conversion of symbolic (node_ptr)
  expressions to ADD and BDD representations the results of
  evaluations are normally cached (see additionally NuSMV option
  enable_sexp2bdd_caching). This allows to save time by avoid the
  construction of BDD for the same expression several time.
  
  In some situations it  may be preferable to clean the cache and
  free collected ADD and BDD. This operation can be done, for example,
  to free some memory. Another possible reason is that dynamic
  reordering may modify all existing BDDs, and cleaning the cache
  thereby freeing the BDD may speed up the reordering.

  This command is designed specifically to free the internal cache of
  evaluated expressions and their ADDs and BDDs.
  
  Note that only the cache of exp-to-bdd evaluator is freed.  BDDs of
  variables, constants and expressions collected in BDD FSM or
  anywhere else are not touched.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandPrintFormula(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a formula in canonical format.]

  CommandName        [print_formula]

  CommandSynopsis    [Prints a formula]

  CommandArguments   [\[-h\] | \[-v\] | \[-f \] <expression>]

  CommandDescription [In formula mode, the formula as the canonical
                      formula is printed.  In verbose mode, the
                      explicit assignments satisfying the formula are
                      printed. Prints the number of satsfying
                      assignments for the given formula.<p>

  Command Options:
  <dl>
  <dt> <tt>-v</tt>
  <dd> Verbosely prints the list of assignments satisfying the formula.
  <dt> <tt>-f</tt>
  <dd> Prints a canonical representation of input.
  </dl>]
]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandDumpExpr(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps an expression in the specified output format.]

  CommandName        [dump_expr]

  CommandSynopsis [Dumps a given expression (which can be
  contextualized) in the specified format. Example of supported format
  is 'dot'. ]

  CommandArguments   [\[-h\] | -e <expression> -f <format> \[-o <fname>\]]

  CommandDescription [Dumps an expression in the specified output format.

  Command Options:
  <dl>
  <dt> <tt>-e expression</tt>
  <dd> The required expression to be dumped.
  <dt> <tt>-f format</tt>
  <dd> The format to be used when dumping. Examples are dot, davinci.
  <dt> <tt>-o filename</tt>
  <dd> The name of the output file (default: standard output)
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{operators.c}
		
	\texttt{node\_ptr node\_and(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ performs logical AND on two nodes.]

  Description        [ Nodes can be integers with values 0 and 1 (logical AND).
  All other combinations are illegal.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_or(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ performs logical OR on two nodes.]

  Description        [ Nodes can be integers with values 0 and 1 (logical OR).
  All other combinations are illegal.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_not(node\_ptr n, node\_ptr this\_node\_is\_not\_used)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ performs logical NOT on a node.]

  Description        [ Node can be an integer with values 0 or 1 (logical NOR).
  All other combinations are illegal.

  NOTE: At the momement, CUDD does not have unary 'apply', so
  you have to write a unary operator in the form of a binary one which
  actually applies to the first operand only]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_iff(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ performs logical IFF on two nodes.]

  Description        [ Nodes can be integers with values 0 and 1 (logical IFF).
  All other combinations are illegal.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_xor(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ performs logical XOR on two nodes.]

  Description        [ Nodes can be integers with values 0 and 1 (logical XOR).
  All other combinations are illegal.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_implies(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis        [ performs logical IMPLIES on two nodes.]

  Description     [Nodes can be integers with values 0 and 1 (logical IMPLIES).
  All other combinations are illegal.]

  SideEffects     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_equal(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns NUMBER with value 1 (symbol Expr_true()) if
  the nodes are the same, and value 0 (symbol Expr_false()) otherwise]

  Description        [
  In NuSMV an constant is equal to another constant then this
  constants are actually the same and representable by the same node.
  ]

  SideEffects        []

  SeeAlso            [node_setin]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_not\_equal(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns NUMBER with value 1 (symbol Expr_true()) if
  the nodes are of different values, and value 0 (symbol Expr_false()) otherwise]

  Description        [
  In NuSMV an constant is equal to another constant then this
  constants are actually the same and representable by the same node.
  ]

  SideEffects        []

  SeeAlso            [node_setin]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_lt(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns NUMBER with value 1 if
  the first node is less than the second one, and 0 - otherwise.]

  Description        [Nodes should be both NUMBER]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_gt(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns NUMBER with value 1 if
  the first node is greater than the second one, and 0 - otherwise.]

  Description        [Nodes should be both NUMBER]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_le(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns NUMBER with value 1 if
  the first node is less or equal than the second one, and 0 - otherwise.]

  Description        [Nodes should be both NUMBER]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_ge(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns NUMBER with value 1 if
  the first node is greater or equal than the second one, and 0 - otherwise.]

  Description        [Nodes should be both NUMBER]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_unary\_minus(node\_ptr n, node\_ptr this\_node\_is\_not\_used)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Negates the operand (unary minus)]

  Description        [Left node can be NUMBER, and the right one is Nil.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_plus(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds two nodes]

  Description        [Nodes can be both NUMBER.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_minus(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Subtract two nodes]

  Description        [Nodes can be both NUMBER.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_times(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Multiplies two nodes]

  Description        [Nodes can be both NUMBER.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_divide(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Divides two nodes]

  Description        [Nodes can be both NUMBER.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_mod(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the remainder of division of two nodes]

  Description        [Nodes can be both NUMBER.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_bit\_range(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [creates RANGE node from two NUMBER nodes.]

  Description        [this range is used in bit-selection only]

  SideEffects        [node_bit_selection]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_union(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the set union of two s_expr.]

  Description        [This function computes the sexp resulting from
  the union of s_expr "n1" and "n2".
  NB: if any of the operands is a FAILURE node, the FAILURE node is returned.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_setin(node\_ptr n1, node\_ptr n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set inclusion]

  Description        [Checks if s_expr "n1" is a subset of s_expr
  "n2", if it is the case them <code>Expr_true()</code> is returned,
  else <code>Expr_false()</code> is returned.

  If "n1" is a list of values then <code>Expr_true()</code> is returned only
  if all elements of "n1" is a subset of "n2".

  NB: if any of the operands is a FAILURE node, the FAILURE node is returned.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_create(node\_ptr bitval, size\_t w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a node_ptr that represents the encoding of a
  WORD.]

  Description        [bitval is the initial value of all bits. w it the
  word width]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_create\_from\_list(node\_ptr l, size\_t w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a node_ptr that represents the encoding of a
  WORD, taking the values of bits from the given list]

  Description        [The list (of CONS nodes) must have length equal to w]

  SideEffects        [node_word_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_create\_from\_wordnumber(WordNumber\_ptr wn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a node_ptr that represents the encoding of a
  WORD, taking the values of bits from the given WordNumber]

  Description        [Word width is taken from the given WordNumber]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_create\_from\_integer(unsigned long long value, size\_t width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a node_ptr that represents the encoding of a
  WORD, taking the values of bits from the given integer value]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_create\_from\_array(array\_t* arr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a node_ptr that represents the encoding of a
  WORD, taking the values of bits from the given array of nodes.]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{size\_t node\_word\_get\_width(node\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the width of the given word]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t* node\_word\_to\_array(node\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts the given word to a dynamic array.]

  Description        [The array must be freed by the caller.
  Note that the order is reversed,i.e. bits found earlier in the WORD expression
  are but closer to the end in the array (they should be higher bits).]


  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int \_apply\_op = 0; static node\_ptr \_node\_word\_apply\_unary\_aux(node\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private helpers for node_word_apply_unary]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int \_time\_op = 0; static node\_ptr \_node\_word\_apply\_attime\_aux(node\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private helper for node_word_apply_attime]

  Description        [Helper for node_word_apply_attime]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_apply\_unary(node\_ptr wenc, int op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Traverses the word bits, and foreach bit creates a node
  whose operator is given. The result is returned as a new word encoding]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_apply\_attime(node\_ptr wenc, int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Traverses the word bits, and foreach bit creates a node
  whose operator is given. The result is returned as a new word encoding]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_apply\_binary(node\_ptr wenc1, node\_ptr wenc2, int op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Traverses two given words, and creates a new word
  applying to each pair of bits the given operator]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_make\_conjuction(node\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an AND node that is the conjuction of all
  bits of the given word]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_make\_disjunction(node\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an OR node that is the disjuction of all
  bits of the given word]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_cast\_bool(node\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Casts the given word to boolean]

  Description        [The word must have width 1]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_not(node\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns a new word that is the negation of the given
  word]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_and(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new word that is the conjuction of the given
  words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_or(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new word that is the disjuction of the given
  words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_xor(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new word that is the xor of the given
  words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_xnor(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new word that is the xnor of the given
  words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_implies(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns a new word that is the logical implication of
  the given words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_iff(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new word that is the <-> of the given
  words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_equal(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_notequal(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new word that is the xor of the given
  words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_concat(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new word that is the concatenationof the given
  words]

  Description [The first given word is the most significant word
  of the result]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_selection(node\_ptr word, node\_ptr range)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Performs bit selections of the given word, that can be
  constant and non-constant]

  Description [ Range must be compatible with the given word
  width, and must be a node in the form of COLON(NUMBER, NUMBER)]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_extend(node\_ptr exp, node\_ptr times, boolean isSigned)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Concatenates bit 0 (if isSigned is false) or
  the highest bit of exp (if isSigned is true) 'times' number of times to exp]

  Description        [exp has to be a UNSIGNED_WORD and 'times' has to be
  a NUMBER]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_adder(node\_ptr a, node\_ptr b, node\_ptr carry\_in, node\_ptr* carry\_out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Bit-blasts the given words, creating a new word
  encoding that is an added circuit]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_plus(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new word encoding that is the circuit that
  adds given words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_minus(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new word encoding that is the circuit that
  subtracts given words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_uminus(node\_ptr a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new word encoding that is the circuit that
  performs unsigned subtraction of given words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_times(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new word encoding that is the circuit that
  performs multiplication of given words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_unsigned\_divide(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new word encoding that is the circuit that
  divides given unsigned words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_unsigned\_mod(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new word encoding that is the circuit that
  performs modulo of given unsigned words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_signed\_divide(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new word encoding that is the circuit that
  divides given signed words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_signed\_mod(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new word encoding that is the circuit that
  performs modulo of given signed words]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_unsigned\_less(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate for a < b]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_unsigned\_less\_equal(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate for a <= b]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_unsigned\_greater(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate for a > b]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_unsigned\_greater\_equal(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate for a >= b]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_signed\_less(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate for a <s b]

  Description        [Signed operation is performed]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_signed\_less\_equal(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate for a <=s b]

  Description        [Signed operation is performed]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_signed\_greater(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate for a >s b]

  Description        [Signed operation is performed]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_word\_signed\_greater\_equal(node\_ptr a, node\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate for a >=s b]

  Description        [Signed operation is performed]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr node\_word\_signed\_op(node\_ptr a, node\_ptr b, NPFNN op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [A private service for predicates]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr node\_word\_full\_adder(node\_ptr ai, node\_ptr bi, node\_ptr carry\_in, node\_ptr* carry\_out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements a full adder circuit]

  Description        [implements a full adder circuit]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr node\_word\_unsigned\_divide\_reminder(node\_ptr a, node\_ptr b, node\_ptr* reminder)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements a (unsigned) divide-with-reminder circuit]

  Description        [Quotient is directly returned and remainder is return
  in 'reminder']

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr node\_word\_signed\_divide\_reminder\_simple(node\_ptr a, node\_ptr b, node\_ptr* reminder)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements a (signed) divide-with-reminder circuit]

  Description        [Quotient is directly returned and remainder is return
  in 'reminder'.
  This is simple impelementation of signed division.
  See also node_word_signed_divide_reminder_hardware.]

  SideEffects        [node_word_signed_divide_reminder_hardware]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr node\_word\_signed\_divide\_reminder\_hardware(node\_ptr a, node\_ptr b, node\_ptr* reminder)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements a (signed) divide-with-reminder circuit]

  Description        [Quotient is directly returned and remainder is return
  in 'reminder'.
  This is alternative to node_word_signed_divide_reminder_simple.
  This function should be impelemented similar to
  add_array_signed_division_remainder_hardware.
  Then node_word_signed_divide_reminder_simple and
  node_word_signed_divide_reminder_hardware should be compared which
  generated exps are better. Then the worse function should be removed.]

  SideEffects        [node_word_signed_divide_reminder_hardware]

******************************************************************************/

	\end{verbatimtab}
	
	\section{fsm}
		
	\section{bdd}
		
	\subsection{BddFsm.c}
		
	\texttt{BddFsm\_ptr BddFsm\_create(BddEnc\_ptr encoding, BddStates init, BddInvarStates invar\_states, BddInvarInputs invar\_inputs, BddTrans\_ptr trans, JusticeList\_ptr justice, CompassionList\_ptr compassion)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Constructor for BddFsm]

   Description        [All given bdd are referenced.
   self becomes the owner of given trans, justice and compassion objects,
   whereas the encoding is owned by the caller]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_destroy(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Destructor of class BddFsm]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddFsm\_ptr BddFsm\_copy(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Copy constructor for BddFsm]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_copy\_cache(BddFsm\_ptr self, const BddFsm\_ptr other, boolean keep\_family)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Copies cached information of 'other' into self]

   Description [Copies cached information (reachable states, levels,
   fair states, etc.) possibly previoulsy calculated by 'other' into
   self.  Call this method when self is qualitatively identical to
   'other', but for some reason the trans is organized
   differently. Call to reuse still valid information calculated by
   'other' into self. If keep_family is true, the cache will be reused
   and not copied, meaning that self will belong to the same family as
   'other'. In this case a change in 'other' will have effects also on
   self (and viceversa). Notice that previoulsy calculated information
   into 'self' will be lost after the copy.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{JusticeList\_ptr BddFsm\_get\_justice(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Getter for justice list]

   Description        [self keeps the ownership of the returned object]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{CompassionList\_ptr BddFsm\_get\_compassion(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Getter for compassion list]

   Description        [self keeps the ownership of the returned object]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_init(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Getter for init]

   Description        [Returned bdd is referenced]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddInvarStates BddFsm\_get\_state\_constraints(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Getter for state constraints]

   Description        [Returned bdd is referenced]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddInvarInputs BddFsm\_get\_input\_constraints(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Getter for input constraints]

   Description        [Returned bdd is referenced]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddTrans\_ptr BddFsm\_get\_trans(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Getter for the trans]

   Description        [Returned Trans instance is not copied, do not destroy
   it, since self keeps the ownership.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddEnc\_ptr BddFsm\_get\_bdd\_encoding(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns the be encoding associated with the given fsm
   instance]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddFsm\_get\_cached\_reachable\_states(const BddFsm\_ptr self, BddStates** layers, int* size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns the cached reachable states]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_set\_reachable\_states(const BddFsm\_ptr self, BddStates reachable)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Sets the whole set of reachable states for this FSM, with
   no onion ring informations]

   Description [Sets the whole set of reachable states for this FSM, with
   no onion ring informations]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddFsm\_has\_cached\_reachable\_states(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks if the set of reachable states exists in the FSM]

   Description        [Checks if the set of reachable states exists in the FSM]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_update\_cached\_reachable\_states(const BddFsm\_ptr self, node\_ptr layers\_list, int size, boolean completed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Updates the cached reachable states]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddFsm\_reachable\_states\_computed(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns true if the set of reachable states has already been
   computed]

   Description  [
   Note: a state is represented by state and frozen variables.]
   computed]

   SideEffects  []

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_reachable\_states(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Gets the set of reachable states of this machine]

   Description  [Returned bdd is referenced.

   This method returns the set R of reachable states,
   i.e.  those states that can be actually reached
   starting from one of the initial state.

   R is the set of states such that "i TRC s" holds for
   some state i in the set of initial states, where TRC
   is the transitive closure of the conjunction of the
   transition relation of the machine with the set of
   invar states, the set of constraints on inputs and the
   set of state/input constraints.

   R is computed by this method in a forward manner by
   exploiting the "BddFsm_get_forward_image" method
   during a fixpoint calculation. In particular, R is
   computed by reaching the fixpoint on the functional
   that maps S onto the forward image
   BddFsm_get_forward_image(S) of S, where the
   computation is started from the set of initial states.
   Notice that the set of invar states, the set of
   constraints on inputs and the set of state/input
   constrains are implicitly taken into account by
   BddFsm_get_forward_image(S).

   Note: a state is represented by state and frozen variables.]

   SideEffects  [Internal cache could change]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_copy\_reachable\_states(BddFsm\_ptr self, BddFsm\_ptr other, boolean keep\_family, boolean force\_calculation)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Copies reachable states of 'other' into 'self']

   Description [This method can be called when reachable states among
   FSMs can be reused, for example when other's reachable states are an
   over-extimation of self's. Parameter force_calculation forces the
   calculation of the reachable states of 'other' if needed (i.e. not
   previoulsy calculated).

   The two FSMs are allowed to belong to the same family. If parameter
   keep_family is true, than the original FSM's family will not change,
   and all the family's members (all the FSMs that have a common
   relative) will have their reachable states changed
   accordingly. Otherwise, self will be detached by its own original
   family (originating a new one), and all relatives will be not
   changed.]

   SideEffects  [Internal cache could change of both self and other]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_reachable\_states\_at\_distance(BddFsm\_ptr self, int distance)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the set of reachable states at a given distance]

   Description  [Computes the set of reachable states if not previously,
   cached. Returned bdd is referenced.

   If distance is greater than the diameter, an assertion
   is fired.

   This method returns the set R of states of this
   machine which can be reached in exactly "distance"
   steps by applying the "BddFsm_get_forward_image"
   method ("distance" times) starting from one of
   the initial states (and cannot be reached with less
   than "distance" steps).

   In the case that the distance is less than 0, the
   empty-set is returned.

   These states are computed as intermediate steps of the
   fixpoint characterization given in the
   "BddFsm_get_reachable_states" method.

   Note: a state is represented by state and frozen variables.]

   SideEffects  [Internal cache could change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddFsm\_get\_monolithic\_trans\_bdd(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns a bdd that represents the monolithic
   transition relation]

   Description  [This method returns a monolithic representation of
   the transition relation, which is computed on the
   basis of the internal partitioned representation by
   composing all the element of the partition.

   Returned bdd is referenced.]

   SideEffects  [Internal cache could change]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddFsm\_get\_distance\_of\_states(BddFsm\_ptr self, BddStates states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the distance of a given set of states from initial
   states]

   Description  [Computes the set of reachable states if not previously cached.
   Returns -1 if given states set is not reachable.

   This method returns an integer which represents the
   distance of the farthest state in "states". The
   distance of one single state "s" is the number of
   applications of the "BddFsm_get_forward_image"
   method (starting from the initial set of states)
   which is necessary and sufficient to end up with a set
   of states containing "s". The distance of a *set* of
   states "set" is the maximal distance of states in
   "set", i.e. the number of applications of the
   "BddFsm_get_forward_image" method (starting from the
   initial set of states) which is necessary and
   sufficient to reach at least once (not necessarily
   during the last application, but somewhere along the
   way) each state in "set".

   So, the distance of a set of states is a max-min
   function.
   Could update the cache.]

   SideEffects  [Internal cache could change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddFsm\_get\_minimum\_distance\_of\_states(BddFsm\_ptr self, BddStates states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis          [Returns the minimum distance of a given set of states
   from initial states]

   Description  [Computes the set of reachable states if not previously cached.
   Returns -1 if given states set is not reachable.

   This method returns an integer which represents the
   distance of the nearest state in "states". The
   distance of one single state "s" is the number of
   applications of the "BddFsm_get_forward_image"
   method (starting from the initial set of states)
   which is necessary and sufficient to end up with a set
   of states containing "s".
   Could update the cache.]

   SideEffects  [Internal cache could change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int BddFsm\_get\_diameter(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the diameter of the machine from the inital state]

   Description  [This method returns an integer which represents the
   diameter of the machine with respect to the set of
   initial states, i.e.  the distance of the fatherst
   state in the machine (starting from the initial
   states), i.e. the maximal value among the lengths of
   shortest paths to each reachable state.  The initial
   diameter is computed as the number of iteration the
   fixpoint procedure described above (see
   "BddFsm_get_reachable_states") does before reaching
   the fixpoint.  It can also be seen as the maximal
   value the "BddFsm_get_distance_of_states" can return
   (which is returned when the argument "states" is set
   to "all the states").

   Could update the cache.]

   SideEffects  [Internal cache could change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_not\_successor\_states(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the set of states without subsequents]

   Description  [This method returns the set of states with no
   successor.  A state "ds" has no successor when all the
   following conditions hold:

   1) ds is a state satisfying stateConstr.
   2) no transition from ds exists which is consistent
   with input and state/input constraint and leads to
   a state satisfying stateConstr.

   Could update the cache.
   Note: a state is represented by state and frozen variables.]

   SideEffects  [Internal cache could change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_deadlock\_states(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the set of deadlock states]

   Description  [This method returns the set of deadlock states.  A
   state ds is said to be a deadlock state when all the
   following conditions hold:

   1) ds is a state satisfying stateConstr;
   2) no transition from ds exists which is consistent
   with input and state/input constraint and leads to
   a state satisfying stateConstr;
   3) s is rechable.

   Could update the cache. May trigger the computation of
   reachable states and states without successors.
   Returned bdd is referenced.

   Note: a state is represented by state and frozen variables.]

   SideEffects  [Cache can change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddFsm\_is\_total(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns true if this machine is total]

   Description  [This method checks wether this machine is total, in
   the sense that each INVAR state has at least one INVAR
   successor state given the constraints on the inputs
   and the state/input.

   This is done by checking that the BddFsm_ImageBwd
   image of the set of all the states is the set of all
   the INVAR states.  This way, the INVAR constraints
   together with the set of constraints on both input and
   state/input are implicitly taken into account by
   BddFsm_get_forward_image.

   The answer "false" is produced when states exist that
   admit no INVAR successor, given the sets of input and
   state/input constraints. However, all these "dead"
   states may be non-reachable, so the machine can still
   be "deadlock free".  See the "BddFsm_is_deadlock_free"
   method.

   Could update the cache. May trigger the computation of
   states without successors.]

   SideEffects  [Cache can change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddFsm\_is\_deadlock\_free(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns true if this machine is deadlock free]

   Description  [This method checks wether this machine is deadlock
   free, i.e.  wether it is impossible to reach an INVAR
   state with no admittable INVAR successor moving from
   the initial condition.

   This happens when the machine is total. If it is not,
   each INVAR state from which no transition to another
   INVAR state can be made according to the input and
   state/input constraints is non-reachable.

   This method checks deadlock freeness by checking
   that the intersection between the set of reachable
   states and the set of INVAR states with no admittable
   INVAR successor is empty.

   Could update the cache. May trigger the computation of
   deadlock states.]

   SideEffects  [Cache can change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_forward\_image(const BddFsm\_ptr self, BddStates states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the forward image of a set of states]

   Description  [This method computes the forward image of a set of
   states S, i.e. the set of INVAR states which are
   reachable from one of the INVAR states in S by means
   of one single machine transition among those
   consistent with both the input constraints and the
   state/input constraints.

   The forward image of S(X,F) is computed as follows.
   X - state variables, I - input variables, F - frozen variables.

   a. S1(X,F,I)   := S(X,F) and Invar(X,F) and InputConst(I)
   b. S2(X',F)    := { <x',f> | <x,f,i,x'> in Tr(X,F,I,X') for
   some <x,i> in S1(X,F,I) }
   c. S3(X,F)     := S2(X',F)[x/x']
   d. FwdImg(X,F) := S3(X,F) and Invar(X,F)

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced.]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_constrained\_forward\_image(const BddFsm\_ptr self, BddStates states, BddStatesInputsNexts constraints)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the constrained forward image of a set of states]

   Description  [This method computes the forward image of a set of
   states S, given a set C of contraints on STATE, FROZEN
   and INPUT vars which are meant to represent a
   restriction on allowed transitions and inputs.

   The constrained image is the set of INVAR states which
   are reachable from one of the INVAR states in S by
   means of one single machine transition among those
   consistent with both the constraints defined within
   the machine and the additional constraint C(X,F,I).

   The forward image of S(X,F) is computed as follows.
   X - state variables, I - input variables, F - frozen variables.

   a. S1(X,F,I) := S(X,F) and Invar(X,F) and InputConst(I) and C(X,F,I)
   b. S2(X',F)    := { <x',f> | <x,f,i,x'> in Tr(X,F,I,X') for
   some <x,f,i> in S1(X,F,I) }
   c. S3(X,F)     := S2(X',F)[x/x']
   d. FwdImg(X,F) := S3(X,F) and Invar(X,F)

   To apply no contraints, parameter constraints must be the
   true bdd.

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_sins\_constrained\_forward\_image(const BddFsm\_ptr self, BddStates states, BddStatesInputsNexts constraints)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the constrained forward image of a set of states]

   Description  [This method computes the forward image of a set of
   states S, given a set C of contraints on STATE, FROZEN
   and INPUT and NEXT vars which are meant to represent a
   restriction on allowed transitions and inputs.

   The constrained image is the set of INVAR states which
   are reachable from one of the INVAR states in S by
   means of one single machine transition among those
   consistent with both the constraints defined within
   the machine and the additional constraint C(X,F,I).

   The forward image of S(X,F) is computed as follows.
   X - state variables, I - input variables, F - frozen variables.

   a. S1(X,F,I) := S(X,F) and Invar(X,F) and InputConst(I) and C(X,F,I)
   b. S2(X',F)    := { <x',f> | <x,f,i,x'> in Tr(X,F,I,X') for
   some <x,f,i> in S1(X,F,I) }
   c. S3(X,F)     := S2(X',F)[x/x']
   d. FwdImg(X,F) := S3(X,F) and Invar(X,F)

   To apply no contraints, parameter constraints must be the
   true bdd.

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddFsm\_get\_forward\_image\_states\_inputs(const BddFsm\_ptr self, BddStatesInputs si)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the forward image of a set of state-input pairs]

   Description  [This method computes the forward image of a set of
   state-input pairs SI. This is the set of state-input
   pairs that fulfills INVAR and INPUT constraints and
   can be reached via a legal transition from at least
   one member of si that itself must fulfill INVAR and
   INPUT.

   The forward image of SI(X,F,I) is computed as follows.
   X - state variables, F - frozen variables, I - input
   variables.

   a. S1(X,F,I)     := SI(X,F,I) and Invar(X,F) and Input(I)
   b. S2(X',F)      := { <x',f> | <x,f,i,x'> in Tr(X,F,I,X')
   for some <x,i> in S1(X,F,I) }
   c. S3(X,F)       := S2(X',F)[x/x']
   d. FwdImg(X,F,I) := S3(X,F) and Invar(X,F) and Input(X,F,I)

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced.]

   SideEffects  []

   SeeAlso      [BddFsm_get_constrained_forward_image_states_inputs,
   BddFsm_get_forward_image]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddFsm\_get\_constrained\_forward\_image\_states\_inputs( const BddFsm\_ptr self, BddStatesInputs si, BddStatesInputsNexts constraints)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the constrained forward image of a set of
   state-input pairs]

   Description  [This method computes the forward image of a set of
   state-input pairs SI constrained by constraints (from
   now on C). This is the set of state-input pairs that
   fulfills INVAR and INPUT constraints and can be
   reached via a legal transition from at least one
   member of SI that itself must fulfill INVAR, INPUT,
   and C.

   The forward image of SI(X,F,I) is computed as follows.
   X - state variables, F - frozen variables, I - input
   variables.

   a. S1(X,F,I)     := SI(X,F,I) and Invar(X,F) and Input(I)
   and C(X,F,I)
   b. S2(X',F)      := { <x',f> | <x,f,i,x'> in Tr(X,F,I,X')
   for some <x,i> in S1(X,F,I) }
   c. S3(X,F)       := S2(X',F)[x/x']
   d. FwdImg(X,F,I) := S3(X,F) and Invar(X,F) and Input(I)

   To apply no contraints, parameter constraints must be
   the true bdd.

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced.]

   SideEffects  []

   SeeAlso      [BddFsm_get_forward_image_states_inputs,
   BddFsm_get_constrained_forward_image]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_backward\_image(const BddFsm\_ptr self, BddStates states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the backward image of a set of states]

   Description  [This method computes the backward image of a set S of
   states, i.e. the set of INVAR states from which some
   of the INVAR states in S is reachable by means of one
   single machine transition among those consistent with
   both the input constraints and the state/input
   constraints.

   The backward image of S(X,F) is computed as follows.
   X - state variables, I - input variables, F - frozen variables.

   a. S1(X,F)     := S(X,F) and Invar(X,F)
   b. S2(X',F)    := S1(X,F)[x'/x]
   c. S3(X,F,I)   := Invar(X,F) and InputConst(I)
   c. BwdImg(X,F) := { <x,f> | <x,f,i,x'> in Tr(X,F,I,X') for
   some <x,f,i> in S3(X,F,I) and some <x',f> in S2(X',F) }

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced.]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_constrained\_backward\_image(const BddFsm\_ptr self, BddStates states, BddStatesInputsNexts constraints)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the constrained backward image of a set of states]

   Description  [This method computes the backward image of a set of
   states S, given a set C(X,F,I) of contraints on STATE, FROZEN
   and INPUT vars which are meant to represent a
   restriction on allowed transitions and inputs.

   The constrained image is the set of INVAR states from
   which some of the INVAR states in S is reachable by
   means of one single machine transition among those
   consistent with both the machine constraints and the
   given additional constraint C(X,F,I).

   The backward image of S(X,F,I) is computed as follows.
   X - state variables, I - input variables, F - frozen variables.

   a. S1(X,F)     := S(X,F) and Invar(X,F)
   b. S2(X',F)    := S1(X,F)[x'/x]
   c. S3(X,F,I)   := Invar(X,F) and InputConst(I)
   and IC(I) and C(X,F,I)
   c. BwdImg(X,F) := { <x,f> | <x,f,i,x'> in Tr(X,F,I,X') for
   some <x,f,i> in S3(X,F,I) and some <x',f> in S2(X',F) }

   To apply no contraints, parameter constraints must be
   the true bdd.

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced.]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddFsm\_get\_k\_backward\_image(const BddFsm\_ptr self, BddStates states, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the k-backward image of a set of states]

   Description  [This method computes the set of <state,frozen,input> tuples
   that lead into at least k distinct states of the set
   of states given as input. The returned couples
   and the states in the set given in input are restricted

   The k-backward image of S(X,F) is computed as follows.
   X - state variables, I - input variables, F - frozen variables.

   a. S1(X,F)   := S(X,F) and Invar(X,F)
   b. S2(X',F)    := S1(X,F)[X'/X]
   c. S3(X,F,I,k) := {<x,f,i> | exists x'[1..k] : S2(x'[m],f) and
   x'[m] != x'[n] if m != n and
   <x,f,i,x'[m]> in Tr }
   d. KBwdImg(X,F,I,k) := S3(X,F,I,k) and Invar(X,F) and
   InputConst(I)

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   The returned bdd is referenced.]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddFsm\_get\_weak\_backward\_image(const BddFsm\_ptr self, BddStates states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the weak backward image of a set of states]

   Description  [This method computes the set of <state,frozen,input> tuples
   that leads into the set of states given as input.
   i.e. the set of <s,f,i> such that <s,f,i> is
   consistent with both the input constraints and the
   state/input constraints, s is INVAR, and a transition
   from s to s' labelled by i exists for some INVAR s' in
   S.

   The weak backward image of S(X,F) is computed as follows.
   X - state variables, I - input variables, F - frozen variables.

   a. S1(X,F)   := S(X,F) and Invar(X,F)
   b. S2(X',F   := S1(X,F)[x'/x]
   c. S3(X,F,I) := Invar(X,F) and InputConst(I)
   c. WeakBwdImg(X,F,I) := {<x,f,i> | <x,f,i,x'> in Tr(X,F,I,X')
   for some <x,f,i> in S3(X,I) and some <x,f>' in S2(X',F) }

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced.]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddFsm\_get\_strong\_backward\_image(const BddFsm\_ptr self, BddStates states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the strong backward image of a set of states]

   Description  [This method computes the set of <state,frozem,input>
   transitions that have at least one successor and are
   such that all the successors lay inside the INVAR
   subset of the set of states given as input.

   The strong backward image of S(X, F, I) is computed as
   follows.
   X - state variables, I - input variables, F - frozen variables.

   a. S1(X,F,I) := WeakBwdImg(not S(X,F))
   b. S2(X,F,I) := (not S1(X,F,I)) and StateConstr(X,F) and
   InputConst(I)
   c. Tr(X,F,I) := {<x,d,i> | <x,d,i,x'> in Tr(X,F,I,X') for some x'}
   d. StrongBwdImg(X,F,I) := S2(X,F,I) and Tr(X,F,I)

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced.]

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_print\_info(const BddFsm\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints some information about this BddFsm.]

   Description        [Prints some information about this BddFsm.]

   SideEffects        [None]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_print\_reachable\_states\_info(const BddFsm\_ptr self, const boolean print\_states, const boolean print\_defines, const boolean print\_formula, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints statistical information about reachable states.]

   Description        [Prints statistical information about reachable
   states, i.e. the real number of reachable states. It is computed
   taking care of the encoding and of the indifferent variables in the
   encoding.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddFsm\_get\_fair\_states\_inputs(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the set of fair state-input pairs of the machine.]

   Description  [A state-input pair is fair iff it can reach a cycle that
   visits all fairness constraints.

   Note: a state is represented by state and frozen variables.]

   SideEffects  [Internal cache could change]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddFsm\_get\_revfair\_states\_inputs(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the set of reverse fair state-input pairs of the
   machine.]

   Description  [A state-input pair is reverse fair iff it can be reached from
   a cycle that visits all fairness constraints.

   Note: a state is represented by state and frozen variables.]

   SideEffects  [Internal cache could change]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_fair\_states(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the set of fair states of a fsm.]

   Description  [A state is fair iff it can reach a cycle that visits all
   fairness constraints.

   Note: a state is represented by state and frozen variables.]

   SideEffects  [Internal cache could change]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_get\_revfair\_states(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the set of reverse fair states of a fsm.]

   Description  [A state is reverse fair iff it can be reached from a cycle
   that visits all fairness constraints.

   Note: a state is represented by state and frozen variables.]

   SideEffects  [Internal cache could change]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddInputs BddFsm\_states\_to\_states\_get\_inputs(const BddFsm\_ptr self, BddStates cur\_states, BddStates next\_states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Given two sets of states, returns the set of inputs
   labeling any transition from a state in the first set to a state in
   the second set.]

   Description        [Note: a state is represented by state and frozen variables.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddFsm\_is\_fair\_states(const BddFsm\_ptr self, BddStates states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks if a set of states is fair.]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs BddFsm\_get\_states\_inputs\_constraints(const BddFsm\_ptr self, BddFsm\_dir dir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns a state-input pair for which at least one
   legal successor (if dir  = BDD_FSM_DIR_BWD) or
   predecessor (otherwise) exists]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_states\_inputs\_to\_states(const BddFsm\_ptr self, BddStatesInputs si)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the states occurring in a set of states-inputs pairs.]

   Description  [Quantifies away the input variables.
   Note: a state is represented by state and frozen variables.]

   SeeAlso      []

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean BddFsm\_expand\_cached\_reachable\_states(BddFsm\_ptr self, int k, int max\_seconds)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Makes k steps of expansion of the set of reachable states
   of this machine but limit the computation to terminate in the
   number of seconds specified (even if this limit can be exceeded for
   the termination of the last cycle)]

   Description [ If k<0 the set is expanded until fixpoint, if max_seconds<0 no
   time limit is considered ]

   SideEffects  [Changes the internal cache]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates BddFsm\_states\_inputs\_to\_inputs(const BddFsm\_ptr self, BddStatesInputs si)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the inputs occurring in a set of states-inputs pairs.]

   Description  [Quantifies away the state variables (including frozen ones).
   A state is represented by state and frozen variables thus
   both state and frozen variables are abstracted away.]

   SeeAlso      []

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_print\_fair\_states\_info(const BddFsm\_ptr self, const boolean print\_states, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints statistical information about fair states.]

   Description [Prints the number of fair states, taking care of the
   encoding and of the indifferent variables in the
   encoding. In verbose mode also prints states.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_print\_fair\_transitions\_info(const BddFsm\_ptr self, const boolean print\_transitions, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints statistical information about fair states and
   transitions.]

   Description        [Prints the number of fair states, taking care of
   the encoding and of the indifferent variables in the encoding.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_check\_machine(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check that the transition relation is total]

   Description [Check that the transition relation is total. If not the
   case than a deadlock state is printed out. May trigger the
   computation of reachable states and states without successors.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_apply\_synchronous\_product\_custom\_varsets(BddFsm\_ptr self, const BddFsm\_ptr other, bdd\_ptr state\_vars\_cube, bdd\_ptr input\_vars\_cube, bdd\_ptr next\_vars\_cube)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Performs the synchronous product of two fsm]

   Description [Original description for BddFsm_apply_synchronous_product:

                The result goes into self, no changes on other.  Both
                the two FSMs must be based on the same dd manager.
                The cache will change, since a new separated family
                will be created for the internal cache, and it will
                not be shared anymore with previous family.  From the
                old cache will be reused as much as possible.

                Modified part:

                Takes cubes of state, input, and next state variables
                as arguments (rather than obtaining the cubes of all
                these variables from the bdd encoding). This is
                supposed to avoid problems when only subsets of
                variables need to be considered (as is the case for
                games).

                ]

   SideEffects [self will change]

   SeeAlso     [BddFsm_apply_synchronous_product,
                BddFsmCache_reset_not_reusable_fields_after_product]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsm\_apply\_synchronous\_product(BddFsm\_ptr self, const BddFsm\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Variant of
                BddFsm_apply_synchronous_product_custom_varsets that
                simply takes all variables in the encoding into
                account.]

   Description [The result goes into self, no changes on other. Both
                the two FSMs must be based on the same dd manager.
                The cache will change, since a new separated family
                will be created for the internal cache, and it will
                not be shared anymore with previous family.  From the
                old cache will be reused as much as possible]

   SideEffects [self will change]

   SeeAlso     [BddFsm_apply_synchronous_product_custom_varsets,
                BddFsmCache_reset_not_reusable_fields_after_product]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_init(BddFsm\_ptr self, BddEnc\_ptr encoding, BddStates init, BddInvarStates invar\_states, BddInvarInputs invar\_inputs, BddTrans\_ptr trans, JusticeList\_ptr justice, CompassionList\_ptr compassion)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Private initializer]

   Description []

   SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_copy(const BddFsm\_ptr self, BddFsm\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [private copy constructor]

   Description []

   SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_deinit(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [private member called by the destructor]

   Description []

   SideEffects []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_compute\_reachable\_states(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Computes the set of reachable states of this machine]

   Description  []

   SideEffects  [Changes the internal cache]

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddStatesInputs bdd\_fsm\_get\_legal\_state\_input(BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Returns the set of states and inputs,
   for which a legal transition can be made.]

   Description  [A legal transition is a transition which satisfy the
   transition relation, and the state, input and next-state satisfy the
   invariants.  So the image S(X, F, I) is computed as follows:
   S(X,F,I) = StateConstr(X,F) & InputConstr(i) & StateConstr(X',F) &
   Tr(X,F,I,X') for some X'
   X - state variables, I - input variables, F - frozen variables.

   Used for planning in strong backward image computation.
   Could update the cache.

   Note: a state is represented by state and frozen variables,
   but frozen variable are never abstracted away.

   Returned bdd is referenced.
   ]

   SideEffects  [Cache can change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddStatesInputs bdd\_fsm\_EXorEY\_SI(const BddFsm\_ptr self, BddStatesInputs si, BddFsm\_dir dir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Computes the preimage (if dir = BDD_FSM_DIR_BWD) or the
   postimage (otherwise) of a set of states-inputs pairs.]

   Description  [Preimage:

   Quantifies away the inputs, and computes the (states-inputs)
   preimage of the resulting set of states.

   Postimage:

   Computes the (states-inputs) postimage of si.
   ]

   SeeAlso      []

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddStatesInputs bdd\_fsm\_EUorES\_SI(const BddFsm\_ptr self, BddStatesInputs f, BddStatesInputs g, BddFsm\_dir dir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Computes the set of state-input pairs that satisfy E(f U g)
   (if dir = BDD_FSM_DIR_BWD) or E(f S g) (otherwise),
   with f and g sets of state-input pairs.]

   Description  []

   SeeAlso      []

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddStatesInputs bdd\_fsm\_compute\_EL\_SI\_subset(const BddFsm\_ptr self, BddStatesInputs subspace, BddFsm\_dir dir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Executes the Emerson-Lei algorithm]

   Description  [Executes the Emerson-Lei algorithm in the set of states
   given by subspace in the direction given by dir]

   SeeAlso      []

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddStatesInputs bdd\_fsm\_compute\_EL\_SI\_subset\_aux(const BddFsm\_ptr self, BddStatesInputs states, BddStatesInputs subspace, BddFsm\_dir dir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Executes the inner fixed point of the Emerson-Lei algorithm]

   Description  [Executes the inner fixed point of the Emerson-Lei
   algorithm. Direction is given by dir, fair states are restricted to
   states, backward/forward exploration (other than the last, "strict"
   image) is restricted to subspace.]

   SeeAlso      []

   SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddStatesInputs bdd\_fsm\_get\_fair\_or\_revfair\_states\_inputs\_in\_subspace(const BddFsm\_ptr self, BddStatesInputs subspace, BddFsm\_dir dir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Computes the set of (reverse) fair states in subspace]

   Description  [Computes the set of fair states (if dir =
   BDD_FSM_DIR_BWD) or reverse fair states (otherwise) by calling the
   Emerson-Lei algorithm.]

   SideEffects  []

   SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddStatesInputs bdd\_fsm\_get\_fair\_or\_revfair\_states\_inputs(BddFsm\_ptr self, BddFsm\_dir dir)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis     [Computes the set of (reverse) fair states]

   Description  [Computes the set of fair states (if dir =
   BDD_FSM_DIR_BWD) or reverse fair states (otherwise) by calling the
   Emerson-Lei algorithm.]

   SideEffects  [Cache might change]

   SeeAlso      [bdd_fsm_get_fair_or_revfair_states_inputs_in_subspace]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_check\_init\_state\_invar\_emptiness(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check inits for emptiness, and prints a warning if needed]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_check\_fairness\_emptiness(const BddFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Checks fair states for emptiness, as well as fot the
   intersaction of fair states and inits. Prints a warning if needed ]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{BddFsmCache.c}
		
	\texttt{BddFsmCache\_ptr BddFsmCache\_create(DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Class contructor]

  Description  []

  SideEffects  []

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsmCache\_destroy(BddFsmCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Class destructor]

  Description  []

  SideEffects  []

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddFsmCache\_ptr BddFsmCache\_hard\_copy(const BddFsmCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Class copy constructor]

  Description  [Hardly copy the instance, by creating a new, separate family]

  SideEffects  []

  SeeAlso      [BddFsmCache_soft_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsmCache\_reset\_not\_reusable\_fields\_after\_product(BddFsmCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Resets any field in the cache that must be recalculated]

  Description [This is called when syncronous product is carried out.
  In particular LTL BDD-based model checking, after having applied the
  product between the original fsm and the fsm coming from the tableau
  contruction, needs to disable the cache sharing and to recalculate
  fair states and other fields, since the fsm changed.
  All fsm's fields that need to be recalculated after the syncronous
  product must be reset by this method.]

  SideEffects  []

  SeeAlso      [BddFsm_apply_synchronous_product]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddFsmCache\_ptr BddFsmCache\_soft\_copy(const BddFsmCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Family soft copier]

  Description  [Returns the same instance, but the family counter is increased,
  in order to handle sharing of the instance. The destructor will actually
  destroy this instance only when the last family member will be destroyed]

  SideEffects  []

  SeeAlso      [BddFsmCache_hard_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsmCache\_copy\_reachables(BddFsmCache\_ptr self, const BddFsmCache\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Copies reachable states information within other into self]

  Description  [This method is used when copying reachable states
  information between to FSMs]

  SideEffects  []

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsmCache\_set\_reachable\_states(BddFsmCache\_ptr self, BddStates reachable)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Fills cache structure with reachable states information]

  Description  [Fills cache structure with reachable states
                information.  The given BDD is supposed to represent
                the whole set of reachable states of the Bdd FSM. It
                should NOT contain other informations (such as onion
                rings ecc)]

  SideEffects  []

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddFsmCache\_set\_reachables(BddFsmCache\_ptr self, node\_ptr layers\_list, const int diameter, boolean completed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Fills cache structure with reachable states information]

  Description [Given list layers_list must be reversed, from last
  layer to the layer corresponding to initial state.  Given list
  layers_list will be destroyed.]

  SideEffects [given list layers_list will be destroyed, cache
  changes]

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_cache\_init(BddFsmCache\_ptr self, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [private initializer]

  Description  [private initializer]

  SideEffects  []

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_cache\_deinit(BddFsmCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [private deinitializer]

  Description  [private deinitializer. Call only if family_counter is 0]

  SideEffects  []

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_fsm\_cache\_deinit\_reachables(BddFsmCache\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [private deinitializer for reachables states]

  Description  [Call only if family_counter is 0]

  SideEffects  []

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{FairnessList.c}
		
	\texttt{FairnessList\_ptr FairnessList\_create(DdManager* dd\_manager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Base class constructor]

  Description  []
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FairnessListIterator\_ptr FairnessList\_begin(const FairnessList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Use to start iteration]

  Description  []
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean FairnessListIterator\_is\_end(const FairnessListIterator\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Use to check end of iteration]

  Description  []
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FairnessListIterator\_ptr FairnessListIterator\_next(const FairnessListIterator\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [use to iterate on an list iterator]

  Description  []
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{JusticeList\_ptr JusticeList\_create(DdManager* dd\_manager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Constructor for justice fairness constraints list]

  Description  [Call FairnessList_destroy to destruct self]
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates JusticeList\_get\_p(const JusticeList\_ptr self, const FairnessListIterator\_ptr iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Getter for BddStates pointed by given iterator]

  Description  [Returned bdd is referenced]
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void JusticeList\_append\_p(JusticeList\_ptr self, BddStates p)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Appends the given bdd to the list]

  Description [Given bdd is referenced, so the caller should free it
  when it is no longer needed]
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void JusticeList\_apply\_synchronous\_product(JusticeList\_ptr self, const JusticeList\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Creates the union of the two given fairness lists. Result
  goes into self]

  Description  []
  
  SideEffects  [self changes]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{CompassionList\_ptr CompassionList\_create(DdManager* dd\_manager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Constructor for compassion fairness constraints list]

  Description  [Call FairnessList_destroy to destruct self]
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates CompassionList\_get\_p(const CompassionList\_ptr self, const FairnessListIterator\_ptr iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Getter of left-side bdd pointed by given iterator]

  Description  [Returned bdd is referenced]
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates CompassionList\_get\_q(const CompassionList\_ptr self, const FairnessListIterator\_ptr iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Getter of right-side bdd pointed by given iterator]

  Description  [Returned bdd is referenced]
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CompassionList\_append\_p\_q(CompassionList\_ptr self, BddStates p, BddStates q)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Appends the given BDDs to the list]

  Description [Given bdds are referenced, so the caller should free it
  when it is no longer needed]
  
  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CompassionList\_apply\_synchronous\_product(CompassionList\_ptr self, const CompassionList\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Creates the union of the two given fairness lists. Result
  goes into self]

  Description  []
  
  SideEffects  [self changes]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void fairness\_list\_init(FairnessList\_ptr self, DdManager* dd\_manager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bddCmd.c}
		
	\texttt{void Bdd\_Init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the BddFsm package.]

  Description        [Initializes the BddFsm package.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bdd\_End(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Quit the BddFsm package]

  Description        [Quit the BddFsm package]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCheckFsm(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks the fsm for totality and deadlock states.]

  CommandName        [check_fsm]

  CommandSynopsis    [Checks the transition relation for totality.]

  CommandArguments   [\[-h\] \[-m | -o output-file\]]

  CommandDescription [
  Checks if the transition relation is total. If the transition
  relation is not total then a potential deadlock state is shown out.
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-m</tt>
       <dd> Pipes the output generated by the command to the program
            specified by the <tt>PAGER</tt> shell variable if
            defined, else through the UNIX command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command to the file
       <tt>output-file</tt>.
  </dl>
  At the beginning reachable states are computed in order to guarantee
  that deadlock states are actually reachable.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandComputeReachable(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computates the set of reachable states]

  CommandName        [compute_reachable]

  CommandSynopsis    [Computes the set of reachable states]

  CommandArguments   [\[-h\] \[-k number\]]

  CommandDescription [The set of reachable states is used to simplify
  image and preimage computations. This can result in improved
  performances for models with sparse state spaces.
  <p>
  Command Options:<p>
  <dl>
    <dt> <tt>-k number</tt>
    <dd> Provides an explicit bound to perform at most "number"
    steps.
    <dt> <tt>-t number</tt> <dd> Provides a fail cut-off maximum
    CPU time to halt the computation. This option can be used to limit
    execution time.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandPrintReachableStates(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the reachable states.]

  CommandName        [print_reachable_states]

  CommandSynopsis    [Prints out information about reachable states]

  CommandArguments   [\[-h\] \[-v\] \[-f\] \[-d\] \[-o filename\] ]

  CommandDescription [Prints the number of reachable states of the
  given model. In verbose mode, prints also the list of all reachable
  states.  The reachable states are computed if needed.<p>

  Command Options:
  <dl>
  <dt> <tt>-v</tt>
  <dd> Verbosely prints the list of reachable states.
  <dt> <tt>-f</tt>
  <dd> Print the list of reachable states as a formula.
  <dt> <tt>-d</tt>
  <dd> Prints the list of reachable states with defines (Requires -v).
  <dt> <tt>-o filename </tt>
  <dd> Prints the result on the specified filename instead of on standard output
  </dl>
]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandPrintFairStates(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the fair states.]

  CommandName        [print_fair_states]

  CommandSynopsis    [Prints out information about fair states]

  CommandArguments   [\[-h\] \[-v\]]

  CommandDescription [This command provides information about the fair
  states of the current model.number of fair states. In verbose mode,
  prints also the list of fair states.<p>

  Command Options:
  <dl>
    <dt> <tt>-v</tt>
    <dd> Verbosely prints the list of fair states.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandPrintFairTransitions(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the fair transitions.]

  CommandName        [print_fair_transitions]

  CommandSynopsis    [Prints the number of fair transitions]

  CommandArguments   [\[-h\] \[-v\]]

  CommandDescription [Prints the number of fair transitions. In
  verbose mode, prints also the list of fair transitions.<p>

  Remark:
    Not really transitions, but rather state_input pairs.<p>

    Command Options:
    <dl>
    <dt> <tt>-v</tt>
    <dd> Verbosely prints the list of fair states.
  </dl>]
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandDumpFsm(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps selected parts of the bdd fsm, with optional 
  expression]

  CommandName        [dump_fsm]

  CommandSynopsis [Dumps (in DOT format) selected parts of the bdd
  fsm, with optional expression]

  CommandArguments   [\[-h\] -o filename \[-i\] \[-I\] \[-t\] \[-f\] \[-r\] \[-e expression\]]

  CommandDescription [Dumps selected parts of the bdd fsm, with
  optional expression, in DOT format. At least one among options
  \[iIte\] must be specified.

    Command Options:

    <dt> <tt>-o filename</tt>
    <dd> Dumps to the specified file name.

    <dt> <tt>-i</tt>
    <dd> Dumps the initial states of the FSM, among with other
    selected outputs.

    <dt> <tt>-I</tt>
    <dd> Dumps the invariant states of the FSM, among with other
    selected outputs.

    <dt> <tt>-t</tt>
    <dd> Dumps the (monolithic) transition relation of the FSM, among with other
    selected outputs.

    <dt> <tt>-F</tt>
    <dd> Dumps the (monolithic) fair states of the FSM, among with other
    selected outputs.

    <dt> <tt>-r</tt>
    <dd> Dumps the (monolithic) reachable states of the FSM, among with other
    selected outputs.

    <dt> <tt>-e</tt>
    <dd> Dumps the specified expression, among with other
    selected outputs (see also command dump_expr).
  </dl>]
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{bddMisc.c}
		
	\texttt{BddOregJusticeEmptinessBddAlgorithmType \ Bdd\_BddOregJusticeEmptinessBddAlgorithmType\_from\_string(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [const char* to BddOregJusticeEmptinessBddAlgorithmType]

  Description        [Converts the given type from string "name" to a
                      BddOregJusticeEmptinessBddAlgorithmType object.]

  SideEffects        [None.]

  SeeAlso            [BddOregJusticeEmptinessBddAlgorithmType_to_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Bdd\_BddOregJusticeEmptinessBddAlgorithmType\_to\_string (const BddOregJusticeEmptinessBddAlgorithmType self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [BddOregJusticeEmptinessBddAlgorithmType to const char*]

  Description        [It takes BddOregJusticeEmptinessBddAlgorithmType of
                      self and returns a string specifying the type of it.
                      Returned string is statically allocated and must not be
                      freed.]

  SideEffects        [None.]

  SeeAlso            [Bdd_BddOregJusticeEmptinessBddAlgorithmType_from_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bdd\_print\_available\_BddOregJusticeEmptinessBddAlgorithms(FILE *file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the BDD-based algorithms to check language
                      emptiness for omega-regular properties the system
                      currently supplies]

  Description        []

  SideEffects        [None.]

  SeeAlso            [BddOregJusticeEmptinessBddAlgorithmType,
                      Bdd_BddOregJusticeEmptinessBddAlgorithmType_to_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Bdd\_elfwd\_check\_options(unsigned int which\_options, boolean on\_fail\_print)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks options for forward Emerson-Lei algorithm]

  Description        [Depending on the value of which_options, it checks that
                      forward search, ltl_tableau_forward_search, and
                      use_reachable_states are enabled and counter_examples is
                      disabled. Returns true if the checks are successful,
                      false otherwise. If on_fail_print is true, it prints an
                      error message on failure.]

  SideEffects        [None.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddELFwdSavedOptions\_ptr Bdd\_elfwd\_check\_set\_and\_save\_options (unsigned int which\_options)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks, sets and saves previous values of options for
                      forward Emerson-Lei]

  Description        [Which values are actually checked, set, and saved is
                      determined by the value of which_options. If set
                      in which_options, forward search,
                      ltl_tableau_forward_search, and
                      use_reachable_states are enabled and
                      counter_examples is disabled. Previous values
                      are stored and returned.

                      Creates the returned
                      BddELFwdSavedOptions_ptr. It does *not* belong
                      to caller - it will be destroyed by the
                      corresponding call to
                      Bdd_elfwd_restore_options.]

  SideEffects        [Modifies options.]

  SeeAlso            [Bdd_elfwd_restore_options]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Bdd\_elfwd\_restore\_options(unsigned int which\_options, BddELFwdSavedOptions\_ptr saved\_options)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Restores previous values of options for forward
                      Emerson-Lei]

  Description        [Which values are actually restored from saved_options is
                      determined by the value of which_options.]

  SideEffects        [Modifies options.]

  SeeAlso            [Bdd_elfwd_check_set_and_save_options]

******************************************************************************/

	\end{verbatimtab}
	
	\section{be}
		
	\subsection{BeFsm.c}
		
	\texttt{BeFsm\_ptr BeFsm\_create\_from\_sexp\_fsm(BeEnc\_ptr be\_enc, const BoolSexpFsm\_ptr bfsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class BeFsm constructor]

  Description        [Creates a new instance of the BeFsm class, getting 
  information from an instance of a boolean Fsm_Sexp type.]

  SideEffects        []

  SeeAlso            [BeFsm_create, BeFsm_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BeFsm\_ptr BeFsm\_create(BeEnc\_ptr be\_enc, const be\_ptr init, const be\_ptr invar, const be\_ptr trans, const node\_ptr list\_of\_be\_fairness)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class BeFsm constructor]

  Description        [It gets init, invar, transition relation and the list
  of fairness in Boolean Expression format.]

  SideEffects        []

  SeeAlso            [BeFsm_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BeFsm\_destroy(BeFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class BeFsm destructor]

  Description        []

  SideEffects        [self will be invalidated]

  SeeAlso            [BeFsm_create, BeFsm_create_from_sexp_fsm]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BeFsm\_ptr BeFsm\_copy(BeFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy constructor for class BeFsm]

  Description        [Creates a new independent copy of the given fsm instance.
  You must destroy the returned class instance by invoking the class 
  destructor when you no longer need it.]

  SideEffects        []

  SeeAlso            [BeFsm_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BeEnc\_ptr BeFsm\_get\_be\_encoding(const BeFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the be encoding associated with the given fsm
  instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeFsm\_get\_init(const BeFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the initial states stored in BE format into the
  given fsm instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeFsm\_get\_invar(const BeFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the invariants stored in BE format into the
  given fsm instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr BeFsm\_get\_trans(const BeFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the transition relation stored in BE format 
  into the given fsm instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr BeFsm\_get\_fairness\_list(const BeFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of fairness stored in BE format 
  into the given fsm instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BeFsm\_apply\_synchronous\_product(BeFsm\_ptr self, const BeFsm\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Apply the synchronous product between self and other
                      modifying self]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_fsm\_init(BeFsm\_ptr self, BeEnc\_ptr be\_enc, const be\_ptr init, const be\_ptr invar, const be\_ptr trans, const node\_ptr list\_of\_be\_fairness)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service to initialize the internal members]

  Description        []

  SideEffects        [self will change internally]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void be\_fsm\_deinit(BeFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service to deinitialize the internal members]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{sexp}
		
	\subsection{BoolSexpFsm.c}
		
	\texttt{BoolSexpFsm\_ptr BoolSexpFsm\_create(const FlatHierarchy\_ptr hierarchy, const Set\_t vars\_set, BddEnc\_ptr benc, SymbLayer\_ptr det\_layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolSexpFsm class constructor]

  Description        [The BoolSexpFsm class constructor]

  SideEffects        []

  SeeAlso            [BoolSexpFsm_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BoolSexpFsm\_ptr BoolSexpFsm\_create\_from\_scalar\_fsm(const SexpFsm\_ptr scalar\_fsm, BddEnc\_ptr benc, SymbLayer\_ptr det\_layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolSexpFsm class constructor from existing sexp
  fsm which is typically a scalar FSM]

  Description        [The BoolSexpFsm class constructor from existing
  fsm. If the given fsm is already boolean, a copy is returned. If it is
  a scalar FSM, its boolean version is created and returned.]

  SideEffects        []

  SeeAlso            [BoolSexpFsm_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BoolSexpFsm\_ptr BoolSexpFsm\_copy(BoolSexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolSexpFsm copy constructor]

  Description        [The BoolSexpFsm copy constructor]

  SideEffects        []

  SeeAlso            [BoolSexpFsm_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void BoolSexpFsm\_destroy(BoolSexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolSexpFsm class destructor]

  Description        [The BoolSexpFsm class destructor]

  SideEffects        []

  SeeAlso            [BoolSexpFsm_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BoolEnc\_ptr BoolSexpFsm\_get\_bool\_enc(const BoolSexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the BoolEnc instance connected to self]

  Description [This method can be called only when a valid BddEnc was
  passed to the class constructor (not NULL). Returned instance do not
  belongs to the caller and must _not_ be destroyed]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_sexp\_fsm\_init(BoolSexpFsm\_ptr self, const FlatHierarchy\_ptr hierarchy, const Set\_t vars\_set, BddEnc\_ptr enc, SymbLayer\_ptr det\_layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolSexpFsm class private initializer]

  Description        [The BoolSexpFsm class private initializer]

  SideEffects        []

  SeeAlso            [BoolSexpFsm_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_sexp\_fsm\_deinit(BoolSexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolSexpFsm class private deinitializer]

  Description        [The BoolSexpFsm class private deinitializer]

  SideEffects        []

  SeeAlso            [BoolSexpFsm_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bool\_sexp\_fsm\_copy\_aux(const BoolSexpFsm\_ptr self, BoolSexpFsm\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BoolSexpFsm class private deinitializer]

  Description        [The BoolSexpFsm class private deinitializer]

  SideEffects        []

  SeeAlso            [BoolSexpFsm_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Object\_ptr bool\_sexp\_fsm\_copy(const Object\_ptr object)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [This is called by the virtual copy constructor]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bool\_sexp\_fsm\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The BoolSexpFsm class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr bool\_sexp\_fsm\_booleanize\_expr(BoolSexpFsm\_ptr self, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Booleanizes the given expression, keeping each top level
  part of a possible conjuction]

  Description [If the fsm is not boolean, the input expression is
  returned]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bool\_sexp\_fsm\_build\_input\_state\_mask(BoolSexpFsm\_ptr self, Expr\_ptr *input, Expr\_ptr *state)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Computes the mask for the variables of the FSM.]

  Description [For the variables in the vars_set of the FSM computes the
  mask and accumulate them into input or state depending on the kind
  of the variable being respectively input or state.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean bool\_sexp\_fsm\_set\_contains\_infinite\_variables(const SymbTable\_ptr st, const Set\_t vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks if the given set of variables contains at least
                       one infinite precision variable]

   Description        [Checks if the given set of variables contains at least
                       one infinite precision variable]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Expr.c}
		
	\texttt{Expr\_ptr Expr\_true()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the true expression value]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_false()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the false expression value]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Expr\_is\_true(const Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checkes whether given value is the true value]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Expr\_is\_false(const Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checkes whether given value is the false value]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_and(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise AND of given operators]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_and\_nil(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise AND of given operators,
  considering Nil as the true value]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_and\_from\_list(node\_ptr list, SymbTable\_ptr symb\_table) Expr\_ptr Expr\_and\_from\_list(node\_ptr list, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise AND of all elements in the
  list]

  Description        [Performs local syntactic simplification.
  Nil value is considered as true value]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_not(const Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise NOT of given operator]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_or(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise OR of given operators]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_xor(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise XOR of given operators]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_xnor(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise XNOR of given operators]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_iff(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise IFF of given operators]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_simplify\_iff(const SymbTable\_ptr st, const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise IFF of given operators]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_implies(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical/bitwise IMPLIES of given operators]

  Description        [Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_ite(const Expr\_ptr cond, const Expr\_ptr t, const Expr\_ptr e, SymbTable\_ptr symb\_table) Expr\_ptr Expr\_ite(const Expr\_ptr cond, const Expr\_ptr t, const Expr\_ptr e, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the If-Then-Else node with given operators]

  Description [Performs local syntactic simplification. 'cond' is the
  case/ite condition, 't' is the THEN expression, 'e' is the ELSE
  expression]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_next(const Expr\_ptr a, SymbTable\_ptr symb\_table) Expr\_ptr Expr\_next(const Expr\_ptr a, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Constructs a NEXT node of given expression]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_equal(const Expr\_ptr a, const Expr\_ptr b, SymbTable\_ptr st) Expr\_ptr Expr\_equal(const Expr\_ptr a, const Expr\_ptr b, const SymbTable\_ptr st)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical EQUAL of given operators]

  Description [Works with boolean, scalar and words. Performs local
  syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_notequal(const Expr\_ptr a, const Expr\_ptr b, SymbTable\_ptr st) Expr\_ptr Expr\_notequal(const Expr\_ptr a, const Expr\_ptr b, const SymbTable\_ptr st)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the logical NOTEQUAL of given operators]

  Description        [Works with boolean, scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_lt(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the predicate LT (less-then) of given operators]

  Description        [Works with scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_simplify\_lt(const SymbTable\_ptr st, const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the predicate LT (less-then) of given operators]

  Description        [Works with scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_le(const Expr\_ptr a, const Expr\_ptr b, SymbTable\_ptr symb\_table) Expr\_ptr Expr\_le(const Expr\_ptr a, const Expr\_ptr b, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the predicate LE (less-then-equal)
  of given operators]

  Description        [Works with scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_gt(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the predicate GT (greater-then)
  of given operators]

  Description        [Works with scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_simplify\_gt(const SymbTable\_ptr st, const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the predicate GT (greater-then)
  of given operators]

  Description        [Works with boolean, scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_ge(const Expr\_ptr a, const Expr\_ptr b, SymbTable\_ptr symb\_table) Expr\_ptr Expr\_ge(const Expr\_ptr a, const Expr\_ptr b, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the predicate GE (greater-then-equal)
  of given operators]

  Description        [Works with boolean, scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_plus(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the scalar node for PLUS of given operators]

  Description        [Works with boolean, scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_minus(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the scalar node for MINUS of given operators]

  Description        [Works with boolean, scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_times(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the scalar node for TIMES of given operators]

  Description        [Works with boolean, scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_divide(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the scalar node for DIVIDE of given operators]

  Description        [Works with boolean, scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_mod(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the scalar node for MODule of given operators]

  Description        [Works with boolean, scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_unary\_minus(const Expr\_ptr a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Builds the scalar node for UMINUS (unary minus) of given
  operators]

  Description        [Works with scalar and words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word\_left\_shift(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node left shifting of words.

  Description        [Works with words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word\_right\_shift(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node right shifting of words.

  Description        [Works with words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word\_left\_rotate(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node left rotation of words.

  Description        [Works with words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word\_right\_rotate(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node right rotation of words.

  Description        [Works with words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word\_bit\_select(const Expr\_ptr w, const Expr\_ptr r)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node for bit selection of words.

  Description        [Works with words. Performs local syntactic
                      simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_simplify\_word\_bit\_select(const SymbTable\_ptr st, const Expr\_ptr w, const Expr\_ptr r)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node for bit selection of words.

  Description        [Works with words. Performs local semantic and syntactic
                      simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word\_concatenate(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node for word concatenation.

  Description        [Works with words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word1\_to\_bool(Expr\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node for casting word1 to boolean.

  Description        [Works with words with width 1.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_bool\_to\_word1(Expr\_ptr a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node for casting boolean to word1.

  Description        [Works with booleans.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_signed\_word\_to\_unsigned(Expr\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Builds the node for casting signed words to unsigned
  words.

  Description        [Works with words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_unsigned\_word\_to\_signed(Expr\_ptr w)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Builds the node for casting unsigned words to signed words.

  Description        [Works with words.
  Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_simplify\_word\_resize(const SymbTable\_ptr st, Expr\_ptr w, Expr\_ptr i)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Builds the node for resizing a word.]

  Description [Works with words. Performs local syntactic simplification]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word\_extend(Expr\_ptr w, Expr\_ptr i, SymbTable\_ptr symb\_table) Expr\_ptr Expr\_word\_extend(Expr\_ptr w, Expr\_ptr i, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the node for extending a word.]

  Description        [Works with words.
                      Performs local syntactic simplification]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_simplify\_word\_extend(const SymbTable\_ptr st, Expr\_ptr w, Expr\_ptr i)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Builds the node for extending a word.]

  Description [Works with words. Performs local syntactic
               simplification]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_attime(Expr\_ptr e, int time, SymbTable\_ptr symb\_table) Expr\_ptr Expr\_attime(Expr\_ptr e, int time, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a ATTIME node]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Expr\_attime\_get\_time(Expr\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the time out of an ATTIME node]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_attime\_get\_untimed(Expr\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the untimed node out of an ATTIME node]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_union(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a union node]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_range(const Expr\_ptr a, const Expr\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a TWODOTS node, representing an integer range]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_setin(const Expr\_ptr a, const Expr\_ptr b, SymbTable\_ptr symb\_table) Expr\_ptr Expr\_setin(const Expr\_ptr a, const Expr\_ptr b, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a setin node, with possible syntactic
                      simplification.]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_function(const Expr\_ptr name, const Expr\_ptr params)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds an Uninterpreted function]

  Description        [Builds an uninterpreted function named "name" with
                      "params" as parameters. "params" must be a cons
                      list of expressions (Created with find_node)]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_resolve(SymbTable\_ptr st, int type, Expr\_ptr left, Expr\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [This is the top-level function that simplifiers can use to
  simplify expressions. This evaluates constant values in operands
  left and right with respect to the operation required with parameter type.]

  Description [Given an expression node E (handled at
  simplifier-level) the simplifier call this function in post order
  after having simplified car(E) and cdr(E). It calls it by passing
  node_get_type(E) as type, and simplified sub expressions for left and right.
  The function Expr_resolve does not traverses further the structures, it simply
  combine given operation encoded in type with given already simplified
  operands left and right.

  For example, suppose E is AND(exp1, exp2). The simplifier:

  1. Simplifies recursively exp1 to exp1' and exp2 to exp2' (lazyness
  might be taken into account if exp1 is found to be a false
  constant).

  2. Calls in postorder Expr_resolve(AND, exp1', exp2')

  Expr_resolve will simplify sintactically the conjunction of (exp1', exp2')]

  SideEffects        [None]

  SeeAlso            [Expr_simplify]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_simplify(SymbTable\_ptr st, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis   [Top-level simplifier that evaluates constants and
  simplifies syntactically the given expression]

  Description [Top-level simplifier that evaluates constants and
  simplifies syntactically the given expression. Simplification is trivial,
  no lemma learning nor sintactic implication is carried out at the moment.

  WARNING:
  the results of simplifications are memoized in a hash stored
  in the symbol table provided. Be very careful not to free/modify the input
  expression or make sure that the input expressions are find_node-ed.
  Otherwise, it is very easy to introduce a bug which will be
  difficult to catch.
  The hash in the symbol table is reset when any layer is removed.

  NOTE FOR DEVELOPERS: if you think that memoization the simplification
  results may cause some bugs you always can try without global
  memoization. See the function body below for info.

  ]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Expr\_is\_timed(Expr\_ptr expr, hash\_ptr cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Determines whether a formula has ATTIME nodes in it]

   Description        [Determines whether a formula has ATTIME nodes in it
                       If cache is not null whenever we encounter a formula in
                       the cache we simply return the previously computed value,
                       otherwise an internal and temporary map is used.

                       NOTE: the internal representation of cache is private so
                             the user should provide only caches generated by
                             this function!]

   SideEffects        [cache can be updated]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Expr\_get\_time(SymbTable\_ptr st, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Obtain the base time of an expression]

   Description        [Current time is recursively calculated as follows:

                       1. UNTIMED_CURRENT for Nil and leaves;
                       2. UNTIMED_FROZEN if all vars are frozen;
                       3. Time specified for an ATTIME node, assuming
                       that the inner expression is untimed.

                       Nesting of ATTIME nodes is _not_ allowed;
                       4. Minimum time for left and right children
                       assuming

                       UNTIMED_CURRENT <
                       UNTIMED_NEXT <
                       t, for any t >= 0.]

   SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Expr\_time\_is\_dont\_care(int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true if the time (obtained by Expr_get_time) is
                       dont't care]

   Description        []

   SideEffects        [Expr_get_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Expr\_time\_is\_current(int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true if the time (obtained by Expr_get_time) is
                       current]

   Description        []

   SideEffects        [Expr_get_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Expr\_time\_is\_next(int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns true if the time (obtained by Expr_get_time) is
                       next]

   Description        []

   SideEffects        [Expr_get_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_untimed(SymbTable\_ptr st, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the untimed version of an expression]

   Description        []

   SideEffects        [Expr_get_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_untimed\_explicit\_time(SymbTable\_ptr st, Expr\_ptr expr, int curr\_time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the untimed version of an expression without
                       searching for the current time]

   Description        [Returns the untimed version of an expression using the
                       current time provided as an argument.]

   SideEffects        [Expr_get_time]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_word\_constant(SymbTable\_ptr symb\_table, int type, Expr\_ptr l, Expr\_ptr r) Expr\_ptr Expr\_word\_constant(const SymbTable\_ptr symb\_table, int type, Expr\_ptr l, Expr\_ptr r)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Builds the node for UWCONST or SWCONST]

  Description [Works with words and scalars. Performs local syntactic
               simplification.]

  SideEffects [None]

  SeeAlso     [Expr_resolve]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_wsizeof(Expr\_ptr l, Expr\_ptr r)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Builds the node for WSIZEOF]

  Description [Works with words. Performs local syntactic simplification.]

  SideEffects [None]

  SeeAlso     [Expr_resolve]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Expr\_cast\_toint(Expr\_ptr l, Expr\_ptr r)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Builds the node for CAST_TOINT]

  Description [Works with scalars. Performs local syntactic simplification.]

  SideEffects []

  SeeAlso     [Expr_resolve]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr expr\_timed\_to\_untimed(SymbTable\_ptr st, Expr\_ptr expr, int curr\_time, boolean in\_next, hash\_ptr cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Converts a timed node into an untimed node]

   Description        [Converts a timed node into an untimed node]

   SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int expr\_get\_curr\_time(SymbTable\_ptr st, node\_ptr expr, hash\_ptr cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Calculates current time for an expression]

   Description        [Private service of Expr_get_time]

   SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr expr\_simplify\_aux(SymbTable\_ptr st, Expr\_ptr expr, hash\_ptr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Recursive auxiliary function for Expr_simplify]

   Description        [Recursive auxiliary function for Expr_simplify]

   SideEffects        []

   SeeAlso            [Expr_simplify]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr expr\_bool\_to\_word1(const Expr\_ptr a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [casts boolean constants to WORD[1]]

   Description        []

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean expr\_is\_timed\_aux(Expr\_ptr expr, hash\_ptr cache)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [true if expression is timed]

   Description        [Private service of Expr_is_timed.
                       To represent 'true' in cache we use the constant 2 for
                       'false' we use 1 to avoid representation problems wrt Nil]

   SideEffects        [cache can be updated]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean expr\_is\_bool(const Expr\_ptr a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check for an expr being boolean]

   Description        [Check for an expr being boolean]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SexpFsm.c}
		
	\texttt{SexpFsm\_ptr SexpFsm\_create(const FlatHierarchy\_ptr hierarchy, const Set\_t vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Costructor for a scalar sexp fsm]

  Description [Given hierarchy will be copied, so the caller is
  responsible for its destruction. Vars set is also copied, so the
  caller is responsible for its destruction (best if frozen)]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL SexpFsm\_ptr SexpFsm\_copy(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy costructor]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SexpFsm\_ptr SexpFsm\_create\_predicate\_normalised\_copy(const SexpFsm\_ptr self, PredicateNormaliser\_ptr normaliser)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy the Sexp FSM and perform predicate-normalisation
  on all the expressions.]

  Description        [Predicate-normalisations means that an expression is
  modified in such a way that at the end the subexpressions of a
  not-boolean expression can be only not-boolean. This is performed by
  changing boolean expression "exp" (which is a subexpression of a
  not-boolean expression) to "ITE(exp, 1, 0)", and then pushing all
  ITE up to the root of not-boolean expressions.

  Constrain: the given Sexp FSM has to be NOT boolean. Otherwise,
  it is meaningless to apply normalisation functions, since all the exporessions
  are already boolean.
  ]

  SideEffects        [SexpFsm_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void SexpFsm\_destroy(SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destructor]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SexpFsm\_is\_boolean(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Use to check if this FSM is a scalar or boolean fsm]

  Description        [Since a BoolSexpFsm derives from SexpFsm, a SexpFsm
                      is not necessarily a scalar fsm. Use this
                      method to distinguish scalar from boolean fsm
                      when dealing with generic SexpFsm pointers. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr SexpFsm\_get\_symb\_table(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the symbol table that is connected to the
  BoolEnc instance connected to self]

  Description [This method can be called only when a valid BddEnc was
  passed to the class constructor (not NULL). Returned instance do not
  belongs to the caller and must _not_ be destroyed]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FlatHierarchy\_ptr SexpFsm\_get\_hierarchy(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the internal complete hierarchy]

  Description [Returned hierarchy belongs to self and cannot be
  freely changed without indirectly modifying self as well. Copy
  the returned hierarchy before modifying it if you do not want to
  change self.  Also, notice that the SexpFsm constructor copies
  the passed hierarchy.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpFsm\_get\_init(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an Expr that collects init states for all
  variables handled by self]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpFsm\_get\_invar(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an Expr that collects invar states for all
  variables handled by self]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpFsm\_get\_trans(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an Expr that collects all next states for all
  variables handled by self]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpFsm\_get\_input(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an Expr that collects all input states for all
  variables handled by self]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpFsm\_get\_var\_init(const SexpFsm\_ptr self, node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [ Gets the sexp expression defining the initial state for
                  the variable "v". ]

  Description   [ Gets the sexp expression defining the initial state for
                  the variable "v". ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpFsm\_get\_var\_invar(const SexpFsm\_ptr self, node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [ Gets the sexp expression defining the state constraints
                  for the variable "v". ]

  Description   [ Gets the sexp expression defining the state constraints
                  for the variable "v". ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpFsm\_get\_var\_trans(const SexpFsm\_ptr self, node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [ Gets the sexp expression defining the transition relation
                  for the variable "v". ]

  Description   [ Gets the sexp expression defining the transition relation
                  for the variable "v". ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpFsm\_get\_var\_input(const SexpFsm\_ptr self, node\_ptr var\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [ Gets the sexp expression defining the input relation
                  for the variable "v". ]

  Description   []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SexpFsm\_get\_justice(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [ Gets the list of sexp expressions defining the set of justice
                  constraints for this machine. ]

  Description   [ Gets the list of sexp expressions defining the set of justice
                  constraints for this machine. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr SexpFsm\_get\_compassion(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [ Gets the list of sexp expressions defining the set of
                  compassion constraints for this machine. ]

  Description   [ Gets the list of sexp expressions defining the set of
                  compassion constraints for this machine. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SexpFsm\_get\_vars\_list(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the set of variables in the FSM]

  Description   [Returned instance belongs to self. Do not change not free it.]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr SexpFsm\_get\_symbols\_list(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the set of symbols in the FSM]

  Description   [Returned instance belongs to self. Do not change not free it.]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t SexpFsm\_get\_vars(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the set of variables in the FSM]

  Description   [Returned instance belongs to self. Do not change not free it.]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SexpFsm\_apply\_synchronous\_product(SexpFsm\_ptr self, SexpFsm\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Performs the synchronous product of two FSMs]

  Description   [The result goes into self, no changes to other.]

  SideEffects   [self will change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SexpFsm\_is\_syntactically\_universal(SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks if the SexpFsm is syntactically universal]

   Description        [Checks if the SexpFsm is syntactically universal:
                       Checks INIT, INVAR, TRANS, INPUT, JUSTICE,
                       COMPASSION to be empty (ie: True Expr). In this
                       case returns true, false otherwise]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SexpFsm\_self\_check(const SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Self-check for the instance]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sexp\_fsm\_init(SexpFsm\_ptr self, const FlatHierarchy\_ptr hierarchy, const Set\_t vars\_set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Initializes the sexp fsm]

  Description [hierarchy is copied into an independent FlatHierarchy
  instance. If the new sexp must be based only on a set of variables, the
  hierarchy must be empty]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sexp\_fsm\_deinit(SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Initializes the vars fsm hash]

  Description   []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sexp\_fsm\_copy\_aux(const SexpFsm\_ptr self, SexpFsm\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [private service for copying self to other]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Object\_ptr sexp\_fsm\_copy(const Object\_ptr object)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [This is called by the virtual copy constructor]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_fsm\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The SexpFsm class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_fsm\_const\_var\_fsm\_init(SexpFsm\_ptr self, hash\_ptr simp\_hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Initializes the const_var_fsm field]

  Description   [Formulae are simplified through
                 sexp_fsm_simplify_expr. For this reason a
                 simplification hash is required as input]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_fsm\_hash\_var\_fsm\_init(SexpFsm\_ptr self, hash\_ptr simp\_hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Initializes the vars fsm hash]

  Description   [Formulae are simplified through
                 sexp_fsm_simplify_expr. For this reason a
                 simplification hash is required as input]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr sexp\_fsm\_simplify\_expr(SexpFsm\_ptr self, hash\_ptr hash, Expr\_ptr expr, const int group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [removes duplicates from expression containing AND nodes]

  Description        [group identifies INVAR, TRANS or INIT group.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static hash\_ptr simplifier\_hash\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This is used when creating cluster list from vars list]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void simplifier\_hash\_destroy(hash\_ptr hash)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call after sexp_fsm_cluster_hash_create]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void simplifier\_hash\_add\_expr(hash\_ptr hash, Expr\_ptr expr, const int group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [To insert a new node in the hash]

  Description        [group is INIT, INVAR or TRANS]

  SideEffects        [The hash can change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean simplifier\_hash\_query\_expr(hash\_ptr hash, Expr\_ptr expr, const int group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Queries for an element in the hash, returns True if
  found]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_fsm\_hash\_var\_fsm\_destroy(SexpFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Call to destroy the var fsm hash]

  Description        [Private method, used internally]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval sexp\_fsm\_callback\_var\_fsm\_free(char *key, char *data, char * arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Private callback that destroys a single variable fsm
  contained into the var fsm hash]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static VarFsm\_ptr sexp\_fsm\_hash\_var\_fsm\_lookup\_var(SexpFsm\_ptr self, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given a variable name, returns the corresponding variable
  fsm, or NULL if not found]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_fsm\_hash\_var\_fsm\_insert\_var(SexpFsm\_ptr self, node\_ptr var, VarFsm\_ptr varfsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a var fsm to the internal hash. Private.]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static VarFsm\_ptr var\_fsm\_create(Expr\_ptr init, Expr\_ptr invar, Expr\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a var fsm]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void var\_fsm\_destroy(VarFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [It does not destroy the init, trans and invar nodes.
  It destroys only the support nodes]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr var\_fsm\_get\_init(VarFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr var\_fsm\_get\_invar(VarFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr var\_fsm\_get\_next(VarFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr var\_fsm\_get\_input(VarFsm\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static VarFsm\_ptr var\_fsm\_synchronous\_product(VarFsm\_ptr fsm1, VarFsm\_ptr fsm2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns new var fsm that is synchronous product of var
  fsms.]

  Description        [Any argument can be Nil. When both are Nil the product
  has all arguments true.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{FsmBuilder.c}
		
	\texttt{FsmBuilder\_ptr FsmBuilder\_create(DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The constructor creates a BddEnc and self handles it]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void FsmBuilder\_destroy(FsmBuilder\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class FsmBuilder destructor]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SexpFsm\_ptr FsmBuilder\_create\_scalar\_sexp\_fsm(const FsmBuilder\_ptr self, FlatHierarchy\_ptr flat\_hierarchy, const Set\_t vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new scalar sexp fsm]

  Description        [The caller becomes the owner of the returned object]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BoolSexpFsm\_ptr FsmBuilder\_create\_boolean\_sexp\_fsm(const FsmBuilder\_ptr self, FlatHierarchy\_ptr flat\_hierarchy, const Set\_t vars, BddEnc\_ptr bdd\_enc, /* cannot be NULL */ SymbLayer\_ptr det\_layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new boolean sexp fsm, taking into account of
                      the current variables ordering, or the trans
                      ordering file when specified by the
                      user. When used, the latter overrides the
                      former.]

  Description        [The caller becomes the owner of the returned object.
                      An exception may occur if the trans cluster
                      ordering is specified and an error occurs
                      while parsing it.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddFsm\_ptr FsmBuilder\_create\_bdd\_fsm(const FsmBuilder\_ptr self, BddEnc\_ptr enc, const SexpFsm\_ptr sexp\_fsm, const TransType trans\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a BddFsm instance from a given SexpFsm]

  Description        [
  Note: all variables from provided encoding will go to the BDD FSM.
  Use FsmBuilder_create_bdd_fsm_of_vars if only SOME variables should be taken
  into account.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddFsm\_ptr FsmBuilder\_create\_bdd\_fsm\_of\_vars(const FsmBuilder\_ptr self, const SexpFsm\_ptr sexp\_fsm, const TransType trans\_type, BddEnc\_ptr enc, BddVarSet\_ptr state\_vars\_cube, BddVarSet\_ptr input\_vars\_cube, BddVarSet\_ptr next\_state\_vars\_cube)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a BddFsm instance from a given SexpFsm]

  Description        [It is the same as FsmBuilder_create_bdd_fsm except that
  the cubes of state, input and next-state variables are given explicitly.

  Note: The functions will take a copy of provided cubes.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ClusterList\_ptr FsmBuilder\_clusterize\_expr(FsmBuilder\_ptr self, BddEnc\_ptr enc, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given an expression, returns a bdd ClusterList with
  each conjuction occurring into expr contained in each cluster of
  the list. ]

  Description [Each cluster into the list represents a piece of
  transition relation. If the given expression contains
  duplicates, they will not occur into the returned cluster
  list. Returned list should be destroyed by the caller.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void fsm\_builder\_init(FsmBuilder\_ptr self, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void fsm\_builder\_deinit(FsmBuilder\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ClusterList\_ptr fsm\_builder\_clusterize\_expr(FsmBuilder\_ptr self, BddEnc\_ptr enc, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts an expression into a list of clusters.
  This list can be used to create a BddFsm]

  Description        [Each cluster into the list represents a piece of
  transition relation. One important requirement is that the given expr should
  not contain duplicates. See for example SexpFsm_get_{init, invar, trans} on
  how to obtain a well formed expression]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{EXTERN AddArray\_ptr BddEnc\_expr\_to\_addarray(BddEnc\_ptr self, const Expr\_ptr expr, const node\_ptr context); EXTERN bdd\_ptr bdd\_iff(DdManager * dd, bdd\_ptr a, bdd\_ptr b); static void fsm\_builder\_clusterize\_expr\_aux(const FsmBuilder\_ptr self, BddEnc\_ptr enc, ClusterList\_ptr clusters, Expr\_ptr expr\_trans, boolean is\_inside\_and, hash\_ptr h)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Auxiliary function to recursively traverse the
  given expression, clusterizing each node as bdd. If called from outside,
  parameter is_inside_and is false.]

  Description        []

  SideEffects        [given cluster list will change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static JusticeList\_ptr fsm\_builder\_justice\_sexp\_to\_bdd(FsmBuilder\_ptr self, BddEnc\_ptr enc, node\_ptr justice\_sexp\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts a list of expressions into a list of
  bdds, wrapped inside a justice list object]

  Description        [The caller becomes the wner of the returned object.
  Internally used by the bdd fsm building code]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static CompassionList\_ptr fsm\_builder\_compassion\_sexp\_to\_bdd(FsmBuilder\_ptr self, BddEnc\_ptr enc, node\_ptr compassion\_sexp\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Converts a list of couple of expressions into a list of couple of
  bdds, wrapped inside a compassion list object]

  Description        [The caller becomes the wner of the returned object.
  Internally used by the bdd fsm building code]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t fsm\_builder\_order\_vars\_list(const FsmBuilder\_ptr self, const BddEnc\_ptr enc, const NodeList\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service used by SexpFsm builders]

  Description        [This method orders the given vars list wrt to the
                      trans ordering file as a first attempt, then
                      wrt the current bdd variables
                      ordering. Caller has to free the returned
                      set.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr fsm\_builder\_remove\_dupl(FsmBuilder\_ptr self, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes duplicates from expression containing AND nodes]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval hash\_bdd\_key\_free(char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Private service]

   Description        [Used when destroying hash containing bdd_ptr as key]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SexpFsm\_ptr fsm\_builder\_lookup\_sexp\_fsm(const FsmBuilder\_ptr self, const FlatHierarchy\_ptr fh, const Set\_t vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Sexp Fsm cache lookup routine]

   Description        [If any, returns a cached copy of a Sexp Fsm which has
                       been built using the given hierarchy and the given set
                       of variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void fsm\_builder\_insert\_sexp\_fsm(const FsmBuilder\_ptr self, const FlatHierarchy\_ptr fh, const Set\_t vars, const SexpFsm\_ptr sexp\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds to the sexp fsm cache the given scalar fsm]

   Description        [Adds to the sexp fsm cache the given scalar fsm,
                       which has been built using the given flat hierarchy
                       and the given set of variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BoolSexpFsm\_ptr fsm\_builder\_lookup\_bool\_sexp\_fsm(const FsmBuilder\_ptr self, const FlatHierarchy\_ptr fh, const Set\_t vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Bool Sexp Fsm cache lookup routine]

   Description        [If any, returns a cached copy of a Boolean Fsm which has
                       been built using the given hierarchy and the given set
                       of variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void fsm\_builder\_insert\_bool\_sexp\_fsm(const FsmBuilder\_ptr self, const FlatHierarchy\_ptr fh, const Set\_t vars, const BoolSexpFsm\_ptr sexp\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds to the sexp fsm cache the given scalar fsm]

   Description        [Adds to the sexp fsm cache the given scalar fsm,
                       which has been built using the given flat hierarchy
                       and the given set of variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddFsm\_ptr fsm\_builder\_lookup\_bdd\_fsm(const FsmBuilder\_ptr self, const SexpFsm\_ptr sexp\_fsm, const Set\_t vars, TransType trans\_type, BddVarSet\_ptr state\_vars\_cube, BddVarSet\_ptr input\_vars\_cube, BddVarSet\_ptr next\_state\_vars\_cube)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Bdd Fsm cache lookup routine]

   Description        [If any, returns a cached copy of a Bdd Fsm which has
                       been built using the given Sexp Fsm and the given set
                       of variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void fsm\_builder\_insert\_bdd\_fsm(const FsmBuilder\_ptr self, const SexpFsm\_ptr sexp\_fsm, const Set\_t vars, TransType trans\_type, BddVarSet\_ptr state\_cube, BddVarSet\_ptr input\_cube, BddVarSet\_ptr next\_cube, const BddFsm\_ptr bdd\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Adds to the bdd fsm cache the given bdd fsm]

   Description        [Adds to the bdd fsm cache the given bdd fsm,
                       which has been built using the given scalar fsm
                       and the given set of variables]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr fsm\_builder\_compute\_hierarchy\_id(const FlatHierarchy\_ptr fh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Computes the id for the given Flat Hierarchy]

   Description        [Computes the id for the given Flat Hierarchy.
                       The ID is the normalized result of the union of
                       all FSM expressions]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr fsm\_builder\_compute\_scalar\_fsm\_id(const SexpFsm\_ptr sexp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Computes the id for the given Sexp Fsm]

   Description        [Computes the id for the given Sexp Fsm.
                       The ID is the normalized result of the union of
                       all FSM expressions]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean fsm\_builder\_set\_contains\_infinite\_variables(const SymbTable\_ptr st, const Set\_t vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks if the given set of variables contains at least
                       one infinite precision variable]

   Description        [Checks if the given set of variables contains at least
                       one infinite precision variable]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{fsm.c}
		
	\texttt{void Fsm\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Package initialization]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Fsm\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Package deinitialization]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\section{hrc}
		
	\section{dumpers}
		
	\subsection{HrcDumper.c}
		
	\texttt{HrcDumper\_ptr HrcDumper\_create(FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumper class constructor]

  Description [The HrcDumper class constructor. Parameter fout
  belongs to self.]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcDumper\_destroy(HrcDumper\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumper class destructor]

  Description [The HrcDumper class destructor. This can be used
  also by all derivated classes.]

  SideEffects        []

  SeeAlso            [HrcDumper_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void HrcDumper\_dump\_snippet(HrcDumper\_ptr self, HrcDumperSnippet snippet, const HrcDumperInfo* info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes the dumper dump the given snippet]

  Description        [This is a virtual method]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcDumper\_enable\_indentation(HrcDumper\_ptr self, boolean flag)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Enables/disables the indentation]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcDumper\_inc\_indent(HrcDumper\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Increments the indent level]

  Description        [Increments the indent level]

  SideEffects        []

  SeeAlso            [HrcDumper_dec_indent]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcDumper\_dec\_indent(HrcDumper\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Decrements the indent level]

  Description [Decrements the indent level. Each call must
  correspond to a call to inc_indent. An assertion fails if called
  when the indent level is zero.]

  SideEffects        []

  SeeAlso            [HrcDumper_inc_indent]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcDumper\_enable\_mod\_suffix(HrcDumper\_ptr self, boolean flag)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Controls if module names must be dumped with a
  (default) suffix or not.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_init(HrcDumper\_ptr self, FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumper class private initializer]

  Description        [The HrcDumper class private initializer]

  SideEffects        []

  SeeAlso            [HrcDumper_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_deinit(HrcDumper\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumper class private deinitializer]

  Description        [The HrcDumper class private deinitializer]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_dump\_snippet(HrcDumper\_ptr self, HrcDumperSnippet snippet, const HrcDumperInfo* info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_dump\_comment(HrcDumper\_ptr self, const char* msg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps a comment]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_dump\_header(HrcDumper\_ptr self, const char* msg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_dump\_indent(HrcDumper\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_nl(HrcDumper\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Implements indentation of a newline]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_dump\_var\_type(HrcDumper\_ptr self, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the type of a variable.]

  Description        [Prints the type of a variable. The printers used
  in compileWrite.c in compile package cannot be used in hrc, unless
  symbol table is used.

  The printer manages the following types: BOOLEAN, INTEGER, REAL,
  UNSIGNED_WORD, SIGNED_WORD, SCALAR, WORD_ARRAY and  ARRAY_TYPE.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_dumper\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The HrcDumper class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_dumper\_dump\_scalar\_type(HrcDumper\_ptr self, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the scalar type of a variable.]

  Description        [Dumps the scalar type of a variable. The
  printer takes care of reversing the CONS list that contains the
  enumeration to preserve the order of the literals in the source
  model.]

  SideEffects        []

  SeeAlso            [hrc_dumper_dump_var_type]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{HrcDumperDebug.c}
		
	\texttt{HrcDumperDebug\_ptr HrcDumperDebug\_create(FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperDebug class constructor]

  Description        [The HrcDumperDebug class constructor]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_debug\_init(HrcDumperDebug\_ptr self, FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperDebug class private initializer]

  Description        [The HrcDumperDebug class private initializer]

  SideEffects        []

  SeeAlso            [HrcDumperDebug_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_debug\_deinit(HrcDumperDebug\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperDebug class private deinitializer]

  Description        [The HrcDumperDebug class private deinitializer]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_debug\_dump\_snippet(HrcDumper\_ptr self, HrcDumperSnippet snippet, const HrcDumperInfo* info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_dumper\_debug\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The HrcDumperDebug class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{HrcDumperSmv.c}
		
	\texttt{HrcDumperSmv\_ptr HrcDumperSmv\_create(FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperSmv class constructor]

  Description        [The HrcDumperSmv class constructor]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_smv\_init(HrcDumperSmv\_ptr self, FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperSmv class private initializer]

  Description        [The HrcDumperSmv class private initializer]

  SideEffects        []

  SeeAlso            [HrcDumperSmv_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_smv\_deinit(HrcDumperSmv\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperSmv class private deinitializer]

  Description        [The HrcDumperSmv class private deinitializer]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_smv\_dump\_snippet(HrcDumper\_ptr self, HrcDumperSnippet snippet, const HrcDumperInfo* info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_smv\_dump\_comment(HrcDumper\_ptr self, const char* msg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps a comment]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_smv\_dump\_header(HrcDumper\_ptr self, const char* msg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_dumper\_smv\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The HrcDumperSmv class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{HrcDumperXml.c}
		
	\texttt{HrcDumperXml\_ptr HrcDumperXml\_create(FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperXml class constructor]

  Description        [The HrcDumperXml class constructor]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_xml\_init(HrcDumperXml\_ptr self, FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperXml class private initializer]

  Description        [The HrcDumperXml class private initializer]

  SideEffects        []

  SeeAlso            [HrcDumperXml_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_xml\_deinit(HrcDumperXml\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcDumperXml class private deinitializer]

  Description        [The HrcDumperXml class private deinitializer]

  SideEffects        []

  SeeAlso            [HrcDumper_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_xml\_dump\_snippet(HrcDumper\_ptr self, HrcDumperSnippet snippet, const HrcDumperInfo* info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void hrc\_dumper\_xml\_dump\_comment(HrcDumper\_ptr self, const char* msg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps a comment]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_dumper\_xml\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The HrcDumperXml class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_dumper\_xml\_dump\_escaped\_node(HrcDumperXml\_ptr self, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dumps escaped node]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{HrcFlattener.c}
		
	\texttt{FlatHierarchy\_ptr HrcToFlatHierarchy(HrcNode\_ptr node, SymbTable\_ptr symb\_table, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [HrcFlattener main routine]

  Description        [HrcFlattener top-level function. Given an Hrc hierarchy
                      and a symbol table (and eventually a symbol
                      layer), creates and returns a flat
                      hierarchy. Parameter layer can be NULL. Is so, a
                      new layer belonging to the given symbol table is
                      created. If not NULL, the layer must belong to
                      the given symbol table]

  SideEffects        []

  SeeAlso            [HrcFlattener_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SexpFsm\_ptr HrcToSexpFsm(HrcNode\_ptr node, SymbTable\_ptr symb\_table, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [HrcFlattener main routine]

  Description        [HrcFlattener top-level function. Given an Hrc hierarchy
                      and a symbol table (and eventually a symbol
                      layer), creates and returns a sexpfsm. Parameter
                      layer can be NULL. Is so, a new layer belonging
                      to the given symbol table is created. If not
                      NULL, the layer must belong to the given symbol
                      table]

  SideEffects        [Adds new symbols to the given symbol table]

  SeeAlso            [HrcFlattener_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{HrcFlattener\_ptr HrcFlattener\_create(HrcNode\_ptr node, SymbTable\_ptr symb\_table, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcFlattener class constructor]

  Description        [The HrcFlattener class constructor. Parameter
                      layer can be NULL. Is so, a new layer belonging
                      to the given symbol table is created. If not
                      NULL, the layer must belong to the given symbol
                      table. The given hrc node must be the top-level
                      node.  Hrc Localize methods should be used first
                      if trying to flatten an instance which is not
                      the main one]

  SideEffects        []

  SeeAlso            [HrcFlattener_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FlatHierarchy\_ptr HrcFlattener\_get\_flat\_hierarchy(HrcFlattener\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the built flat hierarchy]

  Description        [Get the internally built flat hierarchy. The hierarchy
                      is populated only if
                      HrcFlattener_flatten_hierarchy was previously
                      called]

  SideEffects        []

  SeeAlso            [HrcFlattener_flatten_hierarchy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr HrcFlattener\_get\_symbol\_table(HrcFlattener\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the symbol table]

  Description        [Gets the internally populated symbol table. The
                      st is populated only if
                      HrcFlattener_flatten_hierarchy was previously
                      called]

  SideEffects        []

  SeeAlso            [HrcFlattener_flatten_hierarchy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbLayer\_ptr HrcFlattener\_get\_symbol\_layer(HrcFlattener\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the symbol layer]

  Description        [Gets the internally populated symbol layer. The
                      layer is populated only if
                      HrcFlattener_flatten_hierarchy was previously
                      called]

  SideEffects        []

  SeeAlso            [HrcFlattener_flatten_hierarchy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcFlattener\_flatten\_hierarchy(HrcFlattener\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Does the actual flattening.]

  Description        [This method does the actual flattening
                      job. Takes the input hrc node and processes it
                      in 2 steps: in the first step a first version of
                      the hierarchy is build, where expressions are
                      just contextualized but not flattened. After
                      this Compile_ProcessHierarchy is called and the
                      actual flat hierachy is built. The symbol table
                      is also filled]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcFlattener\_populate\_symbol\_table(HrcFlattener\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Fills the symbol table without building
                      any flat hierarchy]

  Description        [Fills the symbol table without building
                      any flat hierarchy]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcFlattener\_write\_flatten\_model(HrcFlattener\_ptr self, FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the flatten model on file "out"]

  Description        [Dumps the flatten model on file "out"]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcFlattener\_destroy(HrcFlattener\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcFlattener class destructor]

  Description        [The HrcFlattener class destructor]

  SideEffects        []

  SeeAlso            [HrcFlattener_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_flattener\_populate\_symb\_table(HrcFlattener\_ptr self, HrcNode\_ptr node, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Populates the symbol table for the given node in
                      the given context]

  Description        [All symbols of the HRC node are flattened and
                      declared into the symbol layer]

  SideEffects        []

  SeeAlso            [hrc_flattener_flatten_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_flattener\_populate\_model(HrcFlattener\_ptr self, HrcNode\_ptr node, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds to the hierarchy model informations of the
                      given hrc node into the given context]

  Description        [Does the actual flattening and contextualization
                      of expressions and properties.]

  SideEffects        []

  SeeAlso            [hrc_flattener_flatten_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_flattener\_flatten\_recur(HrcFlattener\_ptr self, HrcNode\_ptr node, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Does the actual flattening, recursively]

  Description        [Does the actual flattening and contextualization
                      of expressions and properties. Recursively
                      descends on module instances. All symbols are
                      flattened and declared into the symbol layer]

  SideEffects        []

  SeeAlso            [HrcFlattener_flatten_hierarchy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr hrc\_flattener\_build\_properties(HrcFlattener\_ptr self, node\_ptr prop\_list, node\_ptr ctx, short int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a list of flathierarchy-structure
                      compliant properties]

  Description        [Returns a list of properties decorated with
                      CONTEXT and property-type top-level node
                      (LTLSPEC, SPEC, COMPUTE, INVARSPEC, PSLSPEC)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr hrc\_flattener\_expression\_and(node\_ptr expr\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a big-and of the given expression list]

  Description        [Returns a big-and of the given expression list]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr hrc\_flattener\_contextualize\_expr(node\_ptr expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a contextualized version of the expression]

  Description        [Returns a contextualized version of the expression]

  SideEffects        []

  SeeAlso            [hrc_flattener_concat_context]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_flattener\_declare\_variables(HrcFlattener\_ptr self, node\_ptr variables, node\_ptr context, Instantiation\_Variables\_Mode\_Type mode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declares each variable of the given array within
                      the symbol table]

  Description        [Declares each variable of the given array within
                      the symbol table.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr hrc\_flattener\_concat\_context(node\_ptr ctx1, node\_ptr ctx2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Contatenates 2 contexts]

  Description        [Contatenates 2 contexts]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_flattener\_instantiate\_array\_define(SymbTable\_ptr st, SymbLayer\_ptr layer, node\_ptr name, node\_ptr mod\_name, node\_ptr definition)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Instantiates the elements of a array define]

   Description [For every cell and every dimension create a correct
   binding in the symbol layer]


   SideEffects        [Elements are added to the layer an the symbol table]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_flattener\_init(HrcFlattener\_ptr self, HrcNode\_ptr node, SymbTable\_ptr symb\_table, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcFlattener class private initializer]

  Description        [The HrcFlattener class private initializer]

  SideEffects        []

  SeeAlso            [HrcFlattener_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_flattener\_deinit(HrcFlattener\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcFlattener class private deinitializer]

  Description        [The HrcFlattener class private deinitializer]

  SideEffects        []

  SeeAlso            [HrcFlattener_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{HrcNode.c}
		
	\texttt{HrcNode\_ptr HrcNode\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcNode class constructor]

  Description        [The HrcNode class constructor]

  SideEffects        []

  SeeAlso            [HrcNode_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_destroy(HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcNode class destructor]

  Description        [The HrcNode class destructor]

  SideEffects        [The node is freed]

  SeeAlso            [HrcNode_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_destroy\_recur(HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcNode class destructor. It recurses on the childs.]

  Description        [The HrcNode class destructor. It recurses on the childs.]

  SideEffects        [The whole hierarchy tree is freed]

  SeeAlso            [HrcNode_create, HrcNode_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_cleanup(HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Resets all fields of the given node]

  Description        [Resets all fields of the given node.
                      This is needed for safely recycle a node instance.
                      For example, if a parsing error occurs.
                      Children are destroyed.
                      ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_symbol\_table(HrcNode\_ptr self, SymbTable\_ptr st)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the symbol table inside the node.]

  Description        [Sets the symbol table inside the node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr HrcNode\_get\_symbol\_table(HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the symbol table.]

  Description        [Gets the symbol table.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_lineno(HrcNode\_ptr self, int lineno)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the MOD_TYPE lineno of the node.]

  Description        [Sets the MOD_TYPE lineno of the node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int HrcNode\_get\_lineno(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the MOD_TYPE lineno of the node.]

  Description        [Gets the MOD_TYPE lineno of the node.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_name(HrcNode\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the MOD_TYPE name of the node.]

  Description        [Sets the MOD_TYPE name of the node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_name(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the MOD_TYPE name of the node.]

  Description        [Gets the MOD_TYPE name of the node. WARNING: the returned 
  name is 'normalized' and can be used as hash value.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_crude\_name(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the MOD_TYPE name of the node.]

  Description [Gets the MOD_TYPE name of the node. WARNING: the
  returned name is the name passed to SetName, and it is not
  'normalized' like in GetName. This can be used to obtain the node
  as produced by the parser.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_instance\_name(HrcNode\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the instance name of the node.]

  Description        [Sets the instance name of the node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_instance\_name(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the instance name of the node.]

  Description        [Gets the instance name of the node.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_flattened\_instance\_name(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the flattened instance name of the node.]

  Description        [Gets the flattened instance name of the node.

  The hierarchy is visited upward from self until main node is
  found. The flattened and normalized instance node is built and
  returned.

  The flattened instance name is the name obtained considering all the
  anchestors instance of the current node.

  The result of this operation could also be memoized to improve
  performances (this would avoid to recompute the same path twice).]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_parent(HrcNode\_ptr self, const HrcNode\_ptr father)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the parent node of the node.]

  Description        [Sets the parent node of the node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{HrcNode\_ptr HrcNode\_get\_parent(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the parent node of the node.]

  Description        [Get the parent node of the node. HRC_NODE(NULL)
  is returned if no father available.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_formal\_parameters(HrcNode\_ptr self, node\_ptr par)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the formal parameters of the current node.]

  Description        [Sets the formal parameters of the current
  node. They are list of pairs (name . type), where type specifies the
  type of the parameter if know, otherwise it is Nil.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_formal\_parameters(HrcNode\_ptr self, node\_ptr par)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the formal parameters of the current node.]

  Description        [Relaces the formal parameters of the current node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_formal\_parameters(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the formal parameters of the current node.]

  Description        [Gets the formal parameters of the current
  node. They result os a list of pairs (name . type), where type
  specifies the type of the parameter if know, otherwise it is Nil.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_formal\_parameter(HrcNode\_ptr self, node\_ptr par)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a formal parameter to the the current node.]

  Description        [Adds a formal parameter to the current node. It
  should be a pair (name . type), where type specifies the type of the
  parameter if known, otherwise it is Nil.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_actual\_parameters(HrcNode\_ptr self, node\_ptr par)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the actual parameters of the current node.]

  Description        [Sets the actual parameters of the current
  node. They are list of pairs (name . expr), where expr specifies the
  expression the current current formal parameter node has been
  instatiated to.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_actual\_parameters(HrcNode\_ptr self, node\_ptr par)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the actual parameters of the current node.]

  Description        [Replaces the actual parameters of the current node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_actual\_parameters(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the actual parameters of the current node.]

  Description        [Gets the actual parameters of the current
  node. The result is a list of pairs (name . expr), where expr specifies the
  expression the current current formal parameter node has been
  instatiated to.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_actual\_parameter(HrcNode\_ptr self, node\_ptr par)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an actual parameter to the current node.]

  Description        [Adds an actual parameter to the current node. It
  should be a pair (name . expr), where expr specifies the expression the
  parameter has been instantiated to.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_state\_variables(HrcNode\_ptr self, node\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the local state variables of the current node.]

  Description        [Sets the local state variables of the current
  node. It is a list of pairs (name . type) where type is the type of
  the corresponding variable.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_state\_variables(HrcNode\_ptr self, node\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the local state variables of the current node.]

  Description        [Replaces the local state variables of the current node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_state\_variables(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the local state variables of the current node.]

  Description        [Gets the local state variables of the current
  node. The result is a list of pairs (name . type) where type is the
  type of the corresponding variable.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_state\_variable(HrcNode\_ptr self, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a state variable to the current node.]

  Description        [Adds a state variable to the current node. The
  var should be a pairs (name . type) where type is the type of the
  corresponding variable.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_input\_variables(HrcNode\_ptr self, node\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the local input variables of the current node.]

  Description        [Sets the local input variables of the current
  node. It is a list of pairs (name . type) where type is the type of
  the corresponding variable.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_input\_variables(HrcNode\_ptr self, node\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replacess the local input variables of the current node.]

  Description        [Replaces the local input variables of the current  node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_input\_variables(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the local input variables of the current node.]

  Description        [Gets the local input variables of the current
  node. The result is a list of pairs (name . type) where type is the
  type of the corresponding variable.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_input\_variable(HrcNode\_ptr self, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a input variable to the current node.]

  Description        [Adds a input variable to the current node. The
  var should be a pairs (name . type) where type is the type of the
  corresponding variable.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_frozen\_variables(HrcNode\_ptr self, node\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the local frozen variables of the current node.]

  Description        [Sets the local frozen variables of the current
  node. It is a list of pairs (name . type) where type is the type of
  the corresponding variable.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_frozen\_variables(HrcNode\_ptr self, node\_ptr vars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the local frozen variables of the
  current node.]

  Description        [Replaces the local frozen variables of the
  current node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_frozen\_variables(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the local frozen variables of the current node.]

  Description        [Gets the local frozen variables of the current
  node. The result is a list of pairs (name . type) where type is the
  type of the corresponding variable.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_frozen\_variable(HrcNode\_ptr self, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a frozen variable to the current node.]

  Description        [Adds a frozen variable to the current node. The
  var should be a pairs (name . type) where type is the type of the
  corresponding variable.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_defines(HrcNode\_ptr self, node\_ptr defs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the local DEFINES of the current node.]

  Description        [Sets the local DEFINES for the current node. It
  is a list of pairs (name . expr) where expr is the body of the
  DEFINEd symbol.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_defines(HrcNode\_ptr self, node\_ptr defs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the local DEFINES of the current node.]

  Description        [Replaces the local DEFINES for the current node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_defines(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the local DEFINES of the current node.]

  Description        [Gets the local DEFINES of the current node. The
  result is a list of pairs (name . expr) where expr is the body of
  the DEFINEd symbol.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_define(HrcNode\_ptr self, node\_ptr def)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a DEFINE to the current node.]

  Description        [Adds a define declaration to the current node. The
  define should be a pairs (name . expr) where expr is the body of the
  current DEFINE symbol.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_array\_defines(HrcNode\_ptr self, node\_ptr mdefs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the local  ARRAY DEFINES of the current node.]

  Description        [Sets the local ARRAY DEFINES for the current node. It
  is a list of pairs (name . expr) where expr is the body of the
  ARRAY DEFINEd symbol.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_array\_defines(HrcNode\_ptr self, node\_ptr mdefs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the local ARRAY DEFINES of the current
  node.]

  Description        [Replaces the local ARRAY DEFINES for the current
  node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_array\_defines(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the local ARRAY DEFINES of the current node.]

  Description        [Gets the local ARRAY DEFINES of the current node. The
  result is a list of pairs (name . expr) where expr is the body of
  the ARRAY DEFINEd symbol.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_array\_define(HrcNode\_ptr self, node\_ptr mdef)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an ARRAY DEFINE to the current node.]

  Description        [Adds a ARRAY DEFINE declaration to the current
  node. The array define should be a pairs (name . expr) where expr is the
  body of the  current DEFINE symbol.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_init\_exprs(HrcNode\_ptr self, node\_ptr exprs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the INIT expressions for the current node.]

  Description        [Sets the INIT expressions for the current
  node. It is a list of implicitly conjoined expressions.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_init\_exprs(HrcNode\_ptr self, node\_ptr exprs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the INIT expressions for the current
  node.]

  Description        [Replaces the INIT expressions for the current
  node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_init\_exprs(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the INIT expressions for the current node.]

  Description        [Sets the INIT expressions for the current
  node. It is a possibly empty list of implicitly conjoined expressions.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_init\_expr(HrcNode\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an INIT expression to the current node.]

  Description        [Adds an INIT expression to the current node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_init\_assign\_exprs(HrcNode\_ptr self, node\_ptr assigns)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the init(*) := expressions for the current node.]

  Description        [Sets the init(*) := expressions for the current
  node. It is a list of implicitly conjoined assignements.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_init\_assign\_exprs(HrcNode\_ptr self, node\_ptr assigns)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the init(*) := expressions for the
  current node.]

  Description        [Replaces the init(*) := expressions for the
  current node. ]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_init\_assign\_exprs(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the init(*) := expressions for the current node.]

  Description        [Gets the init(*) := expressions for the current
  node. It is a list of implicitly conjoined assignments.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_init\_assign\_expr(HrcNode\_ptr self, node\_ptr assign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an init(*) := assignment to the current node.]

  Description        [Adds an init(*) := assignment to the current
  node. An assignment is an ASSIGN node that has as left child init(*)
  and as right child the assignment.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_invar\_exprs(HrcNode\_ptr self, node\_ptr exprs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the INVAR expressions for the current node.]

  Description        [Sets the INVAR expressions for the current
  node. It is a list of implicitly conjoined expressions.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_invar\_exprs(HrcNode\_ptr self, node\_ptr exprs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the INVAR expressions for the current
  node.]

  Description        [Replaces the INVAR expressions for the current
  node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_invar\_exprs(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the INVAR expressions for the current node.]

  Description        [Sets the INVAR expressions for the current
  node. It is a possibly empty list of implicitly conjoined expressions.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_invar\_expr(HrcNode\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an INVAR expression to the current node.]

  Description        [Adds an INVAR expression to the current node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_invar\_assign\_exprs(HrcNode\_ptr self, node\_ptr assigns)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the (*) := expressions for the current node.]

  Description        [Sets the (*) := expressions for the current
  node. It is a list of implicitly conjoined assignments.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_invar\_assign\_exprs(HrcNode\_ptr self, node\_ptr assigns)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the (*) := expressions for the current node.]

  Description        [Replaces the (*) := expressions for the current
  node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_invar\_assign\_exprs(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the (*) := expressions for the current node.]

  Description        [Gets the (*) := expressions for the current
  node. It is a list of implicitly conjoined assignments.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_invar\_assign\_expr(HrcNode\_ptr self, node\_ptr assign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an (*) := assignment to the current node.]

  Description        [Adds an (*) := assignment to the current
  node. An assignment is an ASSIGN node that has as left child (*)
  and as right child the assignment.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean HrcNode\_can\_declare\_assign(HrcNode\_ptr self, node\_ptr symbol, int assign\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis          [Checks if an assignment can be declared within the node]

  Description        [Checks if an assignment can be declared within the node.
                      If an INIT/NEXT assign is already declared for a symbol,
                      then only a NEXT/INIT assign can be declared. If an INVAR
                      assignment is already declared, then no other assignments
                      can be declared]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_trans\_exprs(HrcNode\_ptr self, node\_ptr exprs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the TRANS expressions for the current node.]

  Description        [Sets the TRANS expressions for the current
  node. It is a list of implicitly conjoined expressions.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_trans\_exprs(HrcNode\_ptr self, node\_ptr exprs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the TRANS expressions for the current node.]

  Description        [Replaces the TRANS expressions for the current
  node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_trans\_exprs(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the TRANS expressions for the current node.]

  Description        [Gets the TRANS expressions for the current
  node. It is a possibly empty list of implicitly conjoined expressions.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_trans\_expr(HrcNode\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an TRANS expression to the current node.]

  Description        [Adds an TRANS expression to the current node.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_next\_assign\_exprs(HrcNode\_ptr self, node\_ptr assigns)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the next(*) := expressions for the current node.]

  Description        [Sets the next(*) := expressions for the current
  node. It is a list of implicitly conjoined assignments.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_next\_assign\_exprs(HrcNode\_ptr self, node\_ptr assigns)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the next(*) := expressions for the current node.]

  Description        [Replaces the next(*) := expressions for the current
  node. It is a list of implicitly conjoined assignments.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_next\_assign\_exprs(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the next(*) := expressions for the current node.]

  Description        [Gets the next(*) := expressions for the current
  node. It is a list of implicitly conjoined assignments.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_next\_assign\_expr(HrcNode\_ptr self, node\_ptr assign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an next(*) := assignment to the current node.]

  Description        [Adds an next(*) := assignment to the current
  node. An assignment is an ASSIGN node that has as left child next(*)
  and as right child the assignment.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_justice\_exprs(HrcNode\_ptr self, node\_ptr justices)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of JUSTICE constraints.]

  Description        [Sets the list of JUSTICE constraints.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_justice\_exprs(HrcNode\_ptr self, node\_ptr justices)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the list of JUSTICE constraints.]

  Description        [Replaces the list of JUSTICE constraints.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_justice\_exprs(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of JUSTICE constraints.]

  Description        [Gets the list of JUSTICE constraints.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_justice\_expr(HrcNode\_ptr self, node\_ptr justice)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a JUSTICE constraint.]

  Description        [Adds a JUSTICE constraint.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_compassion\_exprs(HrcNode\_ptr self, node\_ptr compassions)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of COMPASSION constraints.]

  Description        [Sets the list of COMPASSION constraints.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_compassion\_exprs(HrcNode\_ptr self, node\_ptr compassions)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the list of COMPASSION constraints.]

  Description        [Replaces the list of COMPASSION constraints.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_compassion\_exprs(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of COMPASSION constraints.]

  Description        [Gets the list of COMPASSION constraints.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_compassion\_expr(HrcNode\_ptr self, node\_ptr compassion)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a COMPASSION constraint.]

  Description        [Adds a COMPASSION constraint.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_constants(HrcNode\_ptr self, node\_ptr constants)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of CONSTANTS declarations.]

  Description        [Sets the list of CONSTANTS declarations.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_constants(HrcNode\_ptr self, node\_ptr constants)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the list of CONSTANTS declarations.]

  Description        [Replaces the list of CONSTANTS declarations.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_constants(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of CONSTANTS declarations.]

  Description        [Gets the list of CONSTANTS declarations.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_constants(HrcNode\_ptr self, node\_ptr constant)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a CONSTANTS declaration to the list of
  constants.]

  Description        [Adds a CONSTANTS declaration to the list of
  constants. All constants are kept in a unique list.

  constant is a list of constants.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_ctl\_properties(HrcNode\_ptr self, node\_ptr ctls)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of CTL properties.]

  Description        [Sets the list of CTL properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_ctl\_properties(HrcNode\_ptr self, node\_ptr ctls)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the list of CTL properties.]

  Description        [Replaces the list of CTL properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_ctl\_properties(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of CTL properties.]

  Description        [Gets the list of CTL properties.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_ctl\_property\_expr(HrcNode\_ptr self, node\_ptr ctl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a CTL property.]

  Description        [Adds a CTL property.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_ltl\_properties(HrcNode\_ptr self, node\_ptr ltls)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of LTL properties.]

  Description        [Sets the list of LTL properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_ltl\_properties(HrcNode\_ptr self, node\_ptr ltls)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the list of LTL properties.]

  Description        [Replaces the list of LTL properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_ltl\_properties(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of LTL properties.]

  Description        [Gets the list of LTL properties.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_ltl\_property\_expr(HrcNode\_ptr self, node\_ptr ltl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an LTL property.]

  Description        [Adds an LTL property.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_psl\_properties(HrcNode\_ptr self, node\_ptr psls)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of PSL properties.]

  Description        [Sets the list of PSL properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_psl\_properties(HrcNode\_ptr self, node\_ptr psls)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the list of PSL properties.]

  Description        [Replaces the list of PSL properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_psl\_properties(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of PSL properties.]

  Description        [Gets the list of PSL properties.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_psl\_property\_expr(HrcNode\_ptr self, node\_ptr psl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an PSL property.]

  Description        [Adds an PSL property.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_invar\_properties(HrcNode\_ptr self, node\_ptr invars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of INVARIANT properties.]

  Description        [Sets the list of INVARIANT properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_invar\_properties(HrcNode\_ptr self, node\_ptr invars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the list of INVARIANT properties.]

  Description        [Replaces the list of INVARIANT properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_invar\_properties(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of INVARIANT properties.]

  Description        [Gets the list of INVARIANT properties.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_invar\_property\_expr(HrcNode\_ptr self, node\_ptr invar)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds an INVARIANT property.]

  Description        [Adds an INVARIANT property.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_compute\_properties(HrcNode\_ptr self, node\_ptr computes)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of COMPUTE properties.]

  Description        [Sets the list of COMPUTE properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_replace\_compute\_properties(HrcNode\_ptr self, node\_ptr computes)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the list of COMPUTE properties.]

  Description        [Replaces the list of COMPUTE properties.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_get\_compute\_properties(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of COMPUTE properties.]

  Description        [Gets the list of COMPUTE properties.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_compute\_property\_expr(HrcNode\_ptr self, node\_ptr compute)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a COMPUTE property.]

  Description        [Adds a COMPUTE property.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_child\_hrc\_nodes(HrcNode\_ptr self, Slist\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of local childs for the current node.]

  Description        [Sets the list of local childs for the current
  node. Assumption is that the child nodes have the current node as parent.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{/* Get the local list of child nodes for current node */ Slist\_ptr HrcNode\_get\_child\_hrc\_nodes(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the list of child nodes.]

  Description        [Gets the list of child nodes.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_add\_child\_hrc\_node(HrcNode\_ptr self, HrcNode\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a child node to the current node.]

  Description        [Add a child node to the current node. The parent
  of the child should have been set by someone else and it is expected
  to be the current one.]

  SideEffects        [Structure is updated]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{HrcNode\_ptr HrcNode\_find\_hrc\_node\_by\_mod\_type(const HrcNode\_ptr self, const node\_ptr mod\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the pointer to a node instance of mod_type.]

  Description        [Returns the pointer to the first instance of a
  module of type mod_type encountered in a depth first traversal of
  the hierarchy tree. Returns HRC_NODE(NULL) if no instance exists.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{HrcNode\_ptr HrcNode\_find\_hrc\_node\_by\_instance\_name(const HrcNode\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the pointer to the a module instance of a
  of given name.]

  Description        [Returns the pointer to the a module instance of a
  of given name. Returns HRC_NODE(NULL) if no instance exists.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean HrcNode\_is\_root(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks wether current node is the root of the hierarchy.]

  Description        [Checks wether current node is the root of the
  hierarchy. Returns true if it is the root, false otherwise.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean HrcNode\_is\_leaf(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks wether current node is a leaf node in the hierarchy.]

  Description        [Checks wether current node is a leaf node in the
  hierarchy. Returns true if it is a leaf node, false otherwise.]

  SideEffects        [None]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{HrcNode\_ptr HrcNode\_copy(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new node that is a copy of self without
  considering children.]

  Description        [Creates a new node that is a copy of self without
  considering children.

  The copy does not even link a node with its parent.]

  SideEffects        []

  SeeAlso            [HrcNode_copyRename]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{HrcNode\_ptr HrcNode\_copy\_rename(const HrcNode\_ptr self, node\_ptr new\_module\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new node that is a copy of self without
  considering children. The name of the module of the new node is
  set as new_module_name.]

  Description        [Creates a new node that is a copy of self without
  considering childre. The name of the module of the new node is
  set as new_module_name.

  The copy does not even link a node with its parent.]

  SideEffects        []

  SeeAlso            [HrcNode_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* HrcNode\_get\_undef(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Getter for the undef field]

  Description        [Getter for the undef field]

  SideEffects        []

  SeeAlso            [HrcNode_set_undef]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcNode\_set\_undef(const HrcNode\_ptr self, void* undef)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Getter for the undef field]

  Description        [Getter for the undef field]

  SideEffects        []

  SeeAlso            [HrcNode_set_undef]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{HrcNode\_ptr HrcNode\_recursive\_copy(const HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of self and recursively of all
  its children.]

  Description        [Creates a copy of self and recursively of all
  its children.

  This function is currently NOT IMPLEMENTED.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr HrcNode\_find\_var(HrcNode\_ptr self, node\_ptr var\_name, int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the variable var_name of type var_type.]

  Description        [Returns the variable var_name of type
  var_type. The search is performed only inside self node, thus the
  function does not recur over hierarchy.
  Nil is returned if variable is not found.

  var_name is the name of the variable while type is the type of
  variable to search (VAR, FROZENVAR, INVAR).]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_node\_init(HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcNode class private initializer]

  Description        [The HrcNode class private initializer]

  SideEffects        []

  SeeAlso            [HrcNode_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_node\_deinit(HrcNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcNode class private deinitializer]

  Description        [The HrcNode class private deinitializer]

  SideEffects        []

  SeeAlso            [HrcNode_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr hrc\_node\_copy\_cons\_list(node\_ptr cons\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy a list made of CONS elements.]

  Description        [Copy a list made of CONS elements.

  Also CONS elements are copied when copying the list. In this way the returned
  list can be used in a copy of the current node.

  New node are used to create cons elements. The copy preserves order of
  elements.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_node\_free\_cons\_elements\_in\_list\_and\_list(node\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees all the elements contained in a CONS list.]

  Description        [Frees all the elements contained in a CONS list.]

  SideEffects        [Elements contained in list are freed.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_node\_free\_list\_and\_clear\_assign\_map(HrcNode\_ptr self, int assign\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees all the elements contained in a ASSIGN list. and
                      removes entries from the assign map]

  Description        [Frees all the elements contained in a ASSIGN list. and
                      removes entries from the assign map]

  SideEffects        [Elements contained in list are freed, the list is
                      freed and set to Nil into the HrcNode]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval hrc\_node\_free\_cons\_map\_fun(char *key, char *data, char *arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Function for freeing cons nodes into a map]

  Description        [Function for freeing cons nodes into a map]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{HrcVarDependencies.c}
		
	\texttt{HrcVarDependencies\_ptr HrcVarDependencies\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcVarDependencies class constructor]

  Description        [The HrcVarDependencies class constructor]

  SideEffects        []

  SeeAlso            [HrcVarDependencies_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcVarDependencies\_destroy(HrcVarDependencies\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcVarDependencies class destructor]

  Description        [The HrcVarDependencies class destructor]

  SideEffects        []

  SeeAlso            [HrcVarDependencies_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcVarDependencies\_add\_variable(HrcVarDependencies\_ptr self, node\_ptr variable)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Add a variable to the variable set.]

  Description        [Add a variable to the variable set.
  No checks are performed to ensure that variable is really a variable.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcVarDependencies\_add\_define(HrcVarDependencies\_ptr self, node\_ptr define)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Add a define to the define set.]

  Description        [Add a define to the define set.
  No checks are performed to ensure that define is really a define.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void HrcVarDependencies\_add\_parameter(HrcVarDependencies\_ptr self, node\_ptr formal\_name, node\_ptr actual)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a formal and an actual parameter.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t HrcVarDependencies\_get\_variables\_set(HrcVarDependencies\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the set that contains all the variables.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t HrcVarDependencies\_get\_defines\_set(HrcVarDependencies\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the set that contains all the defines.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t HrcVarDependencies\_get\_formal\_par\_set(HrcVarDependencies\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the set that contains all the formal
  parameters.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t HrcVarDependencies\_get\_actual\_par\_set(HrcVarDependencies\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the set that contains all the actual
  parameters.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean HrcVarDependencies\_has\_formal\_parameter(HrcVarDependencies\_ptr self, node\_ptr formal)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if formal parameter is contained in the
  formal_par_set.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_var\_dependencies\_init(HrcVarDependencies\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcVarDependencies class private initializer]

  Description        [The HrcVarDependencies class private initializer]

  SideEffects        []

  SeeAlso            [HrcVarDependencies_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_var\_dependencies\_deinit(HrcVarDependencies\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The HrcVarDependencies class private deinitializer]

  Description        [The HrcVarDependencies class private deinitializer]

  SideEffects        []

  SeeAlso            [HrcVarDependencies_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{hrc.c}
		
	\texttt{void Hrc\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes the hrc package.]

  Description [Initializes the hrc package. The initialization
  consists of the allocation of the mainHrcNode global variable and
  the initialization of the hrc package commands.]

  SideEffects []

  SeeAlso     [TracePkg_quit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Hrc\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Quits the hrc package.]

  Description [Quits the hrc package, freeing the global variable
  mainHrcNode and removing the hrc commands.]

  SideEffects []

  SeeAlso     [TracePkg_init]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{hrcCmd.c}
		
	\texttt{void Hrc\_init\_cmd()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the commands of the hrc package.]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Hrc\_quit\_cmd()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the commands provided by the hrc package.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandHrcWriteModel(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes the SMV model contained in the root node
  of the hrc structure.]

  CommandName        [hrc_write_model]

  CommandSynopsis    [Writes the hrc structure from root node to a
  given SMV file]

  CommandArguments   [\[-h\] | \[-o "filename"\] \[-d\]]

  CommandDescription [Writes the currently loaded SMV model stored in
  hrc structure in the specified file. If no file is specified the

  standard output is used. <p>

  Command Options:
  <dl>
    <dt> <tt>-o "filename"</tt>
    <dd> Attempts to write the SMV model in "filename".

    <dt> <tt>-d</tt>
    <dd> Renames modules appending "_hrc" the the original module name.
  </dl>
 ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandHrcDumpModel(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes the SMV model contained in the root node
  of the hrc structure.]

  CommandName        [hrc_dump_model]

  CommandSynopsis    [Writes the hrc structure from root node to a
  given SMV file]

  CommandArguments   [\[-h\] | \[-o "filename"\] \[-d\]]

  CommandDescription [Writes the currently loaded SMV model stored in
  hrc structure in the specified file. If no file is specified the

  standard output is used. <p>

  Command Options:
  <dl>
    <dt> <tt>-o "filename"</tt>
    <dd> Attempts to write the SMV model in "filename".

    <dt> <tt>-d</tt>
    <dd> Renames modules appending "_hrc" the the original module name.
  </dl>
 ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageHrcWriteModel(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the usage of the command UsageHrcWriteModel]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageHrcDumpModel(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the usage of the command UsageHrcDumpModel]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{hrcDump.c}
		
	\texttt{void Hrc\_DumpModel(HrcNode\_ptr hrcNode, HrcDumper\_ptr dumper)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the SMV module for the hrcNode.]

  Description        [Prints the SMV module for the hrcNode. If the
  flag append_suffix is true then the suffix HRC_WRITE_MODULE_SUFFIX
  is appended when a module type is printed. So
  HRC_WRITE_MODULE_SUFFIX is appended to the module name in module
  declarations and to the module name in a module instantiation. The
  feature is needed for testing to avoid name clash among modules
  names when the original model and the model generated from hrc are
  merged.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_dump\_module\_instance(HrcNode\_ptr hrcNode, HrcDumper\_ptr dumper, HrcDumperInfo* info, hash\_ptr printed\_module\_map)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes the SMV translation of the instance
  module contained in hrcNode on file.]

  Description        [Writes the SMV translation of the instance
  module contained in hrcNode on file.]

  SideEffects        [printed_module_map is changed to keep track of
  printed modules.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_dump\_compile\_info(HrcNode\_ptr hrcNode, HrcDumper\_ptr dumper, HrcDumperInfo* info)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dumps the compiler information]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{hrcPrefixUtils.c}
		
	\texttt{Set\_t hrc\_prefix\_utils\_get\_prefix\_symbols(Set\_t symbol\_set, node\_ptr prefix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a set of symbol returns a new set that
  contains only symbols that have a given prefix.]

  Description        [Given a set of symbol returns a new set that
  contains only symbols that have a given prefix.

  The returned set must be destroyed by the caller.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean hrc\_prefix\_utils\_is\_subprefix(node\_ptr subprefix, node\_ptr prefix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if subprefix is contained in prefix.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr hrc\_prefix\_utils\_add\_context(node\_ptr context, node\_ptr expression)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Build the expression prefixed by context.]

  Description        [Build the expression prefixed by context.

  If expression is of DOT or CONTEXT type we cannot build the tree
  DOT(context, expression). We need to recursively visit expression
  to build a correct DOT tree.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr hrc\_prefix\_utils\_get\_first\_subcontext(node\_ptr symbol)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the first subcontext of the given symbol.]

  Description        [Get the first subcontext of the given symbol.

  Search the second CONTEXT or DOT node in symbol and returns it. If it
  is not found then Nil is returned.

  DOT and CONTEXT nodes are always searched in the car node.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr hrc\_prefix\_utils\_remove\_context(node\_ptr identifier, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes context from identifier.]

  Description        [Removes context from identifier.
  If context is not ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr hrc\_prefix\_utils\_assign\_module\_name(HrcNode\_ptr instance, node\_ptr instance\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new name for the module instance.]

  Description        [Creates a new name for the module instance.

  The generated module name is <module_name>_<module_instance_flattened_name>]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr hrc\_prefix\_utils\_flatten\_instance\_name(HrcNode\_ptr instance)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given an instance returns its flattened name.]

  Description        [Given an instance returns its flattened name.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{hrcWrite.c}
		
	\texttt{void Hrc\_WriteModel(HrcNode\_ptr hrcNode, FILE * ofile, boolean append\_suffix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the SMV module for the hrcNode.]

  Description        [Prints the SMV module for the hrcNode. If the
  flag append_suffix is true then the suffix HRC_WRITE_MODULE_SUFFIX
  is appended when a module type is printed. So
  HRC_WRITE_MODULE_SUFFIX is appended to the module name in module
  declarations and to the module name in a module instantiation. The
  feature is needed for testing to avoid name clash among modules
  names when the original model and the model generated from hrc are
  merged.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_module\_instance(FILE * ofile, HrcNode\_ptr hrcNode, st\_table* printed\_module\_map, boolean append\_suffix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes the SMV translation of the instance
  module contained in hrcNode on file.]

  Description        [Writes the SMV translation of the instance
  module contained in hrcNode on file.]

  SideEffects        [printed_module_map is changed to keep track of
  printed modules.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_declare\_module\_variables(FILE * ofile, HrcNode\_ptr child, st\_table* printed\_module\_map, boolean append\_suffix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Declare a module variables, setting the module
  to use and the actual parameters.]

  Description        [Declare a module variables, setting the module
  to use and the actual parameters.]

  SideEffects        [printed_module_map is changed in the recursive
  calls of the the function.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_parameters(FILE* ofile, node\_ptr parameters\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a list of parameters for module
  declaration or instantiation.]

  Description        [Prints a list of parameters for module
  declaration or instantiation.

  The parameter list is printed enclosed by brackets, every parameter
  is separated by colon.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_print\_vars(FILE* out, HrcNode\_ptr hrcNode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the variable of the module contained in hrcNode.]

  Description        [Prints the variable of the module contained in
  hrcNode.
  The sections printed are VAR, IVAR and FROZENVAR.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_print\_var\_list(FILE* out, node\_ptr var\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a list of variables.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_print\_defines(FILE* out, HrcNode\_ptr hrcNode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes DEFINE declarations in SMV format on a
  file.]

  Description        [Writes DEFINE declarations in SMV format on a
  file.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_print\_array\_defines(FILE* out, HrcNode\_ptr hrcNode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes the ARRAY DEFINE declarations contained in hrcNode.]

  Description        [Writes the ARRAY DEFINE declarations contained in hrcNode.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean hrc\_write\_expr\_split(FILE* out, node\_ptr n, const char* s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes an expression in SMV format on a file.]

  Description        [Writes a generic expression prefixed by a given
  string in SMV format on a file.

  Returns true if at least one expression was printed.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean hrc\_write\_spec\_split(FILE* out, node\_ptr n, const char* s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes a specification list in SMV format on a file.]

  Description        [Writes a specification list prefixed by a given
  string in SMV format on a file.

  Returns true if at least one specification was printed.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_expr(FILE* out, node\_ptr n, const char* s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes expression in SMV format on a file.]

  Description        [Writes a generic expression prefixed by a given
  string in SMV format on a file.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_spec(FILE* out, node\_ptr spec, const char* msg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the given specification.]

  Description        [Prints in out file the specification.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_specifications(FILE* out, HrcNode\_ptr hrcNode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes all the specifications of a module instance.]

  Description        [Writes all the specifications of a module instance.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean hrc\_write\_assign\_list(FILE* out, int assign\_node\_type, node\_ptr assign\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes ASSIGN declarations in SMV format on a file.]

  Description        [Writes ASSIGN declarations in SMV format on a
  file.

  Function returns true if at least an assign was written]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_print\_assign(FILE * out, node\_ptr lhs, node\_ptr rhs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints an assignement statement]

  Description        [Prints an assignement statement]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hrc\_write\_spec\_pair\_list(FILE* out, node\_ptr pair\_list, char* section\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Writes a list of specification that contains
  pairs in SMV format.]

  Description        [Writes a list of specification that contains
  pairs in SMV format.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean hrc\_write\_constants(FILE *out, node\_ptr constants\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints in the output file the SMV
  representations of constants list.]

  Description        [Prints in the output file the SMV
  representations of constants list.

  Function returns true if at least a constant was printed.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void print\_variable\_type(FILE* out, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the type of a variable.]

  Description        [Prints the type of a variable. The printers used
  in compileWrite.c in compile package cannot be used in hrc, unless
  symbol table is used.

  The printer manages the following types: BOOLEAN, INTEGER, REAL,
  UNSIGNED_WORD, SIGNED_WORD, SCALAR, WORD_ARRAY and  ARRAY_TYPE.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void print\_scalar\_type(FILE* out, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the scalar type of a variable.]

  Description        [Prints the scalar type of a variable. The
  printer takes care of reversing the CONS list that contains the
  enumeration to preserve the order of the literals in the source
  model.]

  SideEffects        []

  SeeAlso            [print_variable_type]

******************************************************************************/

	\end{verbatimtab}
	
	\section{ltl}
		
	\section{ltl2smv}
		
	\subsection{ltl2smv.c}
		
	\texttt{node\_ptr ltl2smv(unsigned int uniqueId, node\_ptr in\_ltl\_expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The main routine converting an LTL formula to am SMV Module.]

  Description [The parameters are:
  uniqueId - is a positive integer number, which is converted to string
            representation and then used as a part of the generated
            SMV models name.  (_LTL_uniqueId_SPECF_N_)
  in_ltl_expr - the input LTL Formula in the form of node_ptr. The
            expression should be flattened, rewritten wrt input
            variables, negated, i.e. be ready for conversion without
            any additional transformations.


  The function also performs memory-sharing on the input expression,
  since the returned module may be smaller if the memory of
  expression is shared. So DO NOT modify the output expressions.

  But the invoker can modify the declarations and module itself (but
  not their expressions). See generate_smv_module for more info.

  The return value is the created SMV module in the form of node_ptr.
  ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void initialise\_transformation(unsigned int specificationNumber\_)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initialises the conversion performed by this package]

  Description [The specificationNumber is the same operand provided to ltl2smv]

  SideEffects [initialises all the data structures required for conversion]

  SeeAlso     [ltl2smv]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void deinitialise\_transformation()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [deinitialises the package]

  Description [The only required thing is to free the hash table: exp -> name]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr normalise\_formula(node\_ptr t)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Normalises the formula]

  Description        [Normalisations will create a new formula with
  the following transformations:
   "a & b"   => "!(!a & !b)"
   "a -> b"  => "!a | b"
   "a <-> b"  => "!(!a | !b) | !(a | b)"
   "a xnor b" => "!(!a | !b) | !(a | b)"
   "a xor b"  => "!(!a | b) | !(!a | b)"
   "Z a" => "! Y !a"
   "F a" => "1 U a"
   "G a" => "!(1 U !a)"
   "a V b" => "!(!a U !b)"
   "O a" => "1 S a"
   "H a" => "!(1 S !a)"
   "a T b" => "!(!a S !b)"

   If two consecutive NOT are met => both removed.

   The expression is also memory-shared, i.e. find_atom
   of find_node is invoked on every(!) expressions, including
   on the leaf-nodes (i.e. nodes not participating in the conversion directly).
   ]

  SideEffects []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr perform\_memory\_sharing(node\_ptr t)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Make all sub-expressions of the expression
  to share as much memory as possible, i.e. the same sub-expressions
  will have the same pointer.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr transform\_ltl\_expression(node\_ptr t, boolean polarity)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The main conversion function.]

  Description [It fills in the lists : var_declarations,
  define_declarations, trans_declarations, init_declarations,
  justice_declarations. These lists are list of nodes.
  var_declarations: a list of ATOM (future VAR declarations)
  define_declarations: a list of DEFINES body, i.e. EQDEF (see syntax
  of DEFINE) trans_declarations: a list of TRANS expressions (but not
  TRANS itself) init_declarations: a list of INIT expressions (but not
  INIT itself) justice_declarations: a list of JUSTICE expressions(but
  not JUSTICE itself)

  NB: The elements of the lists use memory-sharing so
  pointers can be compare to check their uniqueness.
  (But the lists themselves do not use memory-sharing)

  Returns the name of the input expression (see expr_to_name
  for more details).

  NB: The memory of expression is expected to be shared. Then the
  same name will be used for the same sub-expression.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr\_to\_name(node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a name of the expression or
  the expression itself]

  Description        [If the expression is an LTL leaf node (i.e. not
  a node participating in the transformation) then the node itself is
  returned.
  If the node is a node participating in the transformation then
  the ATOM node with a unique name is returned.

  NB: The memory sharing for expression will make the whole algorithm
  more efficient because the same name will be returned
  for the same subexpression]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr add\_to\_list(node\_ptr node, node\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Add a node to a list. If the node is already in the list,
  nothing happens]

  Description        [Returns a new list (probably with the given node.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char* generate\_string(const char* format, ...)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Behaves similar to standard sprintf, but will allocates
  the required memory by itself]

  Description        [Warning:
  1. memory belongs to the function. Do not modify the returned
     string. Consecutive invocations damage the previously returned
     strings.

  2. The limit of generated strings is set to 100 bytes. Do not try
  to generate a bigger string]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr generate\_smv\_module(node\_ptr whole\_expression\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [After invocation of transform_ltl_expression, this
  function generates SMV modules from the obtained lists
  of DEFINEs, INITs, etc.]

  Description        [The parameter whole_expression_name
  is the name (see expr_to_name) of the whole LTL expression.

  All expressions in the module are memory-shared, but
  the module itself is not. The invoker may modify or delete
  all the declarations (and lists insided VAR and DEFINE), but
  should not modify the expressions (including EQDEF in DEFINEs).]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr expand\_case\_body(node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Expands the body of a case]

  Description        [Given a case expression, of the form
  <textarea>
  case
     c1 : e1;
     c2 : e2;
     ...
  esac;
  </textarea>
  it returns <tt> (c1 and e1) or (!c1 and ((c2 and e2) or (!c2 and (....)))) </tt>
]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ltl2smv\_print\_module(FILE* ostream, node\_ptr module)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the tableau in SMV format]

  Description        [Prints the tableau in SMV format]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ltl2smvMain.c}
		
	\subsection{ltl.c}
		
	\texttt{void Ltl\_CheckLtlSpec(Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The main routine to perform LTL model checking.]

  Description [The main routine to perform LTL model checking. It
  first takes the LTL formula, prints it in a file. It calls the LTL2SMV
  translator on it an reads in the generated tableau. The tableau is
  instantiated, compiled and then conjoined with the original model
  (both the set of fairness conditions and the transition relation are
  affected by this operation, for this reason we save the current
  model, and after the verification of the property we restore the
  original one).

  If already set (The Scalar and the Bdd ones, the FSMs used for
  verification are taken from within the property. Otherwise, global
  FSMs are set within the property and then used for verification.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void print\_ltlspec(FILE* file, Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Print the LTL specification.]

  Description        [Print the LTL specification.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ltl\_StructCheckLtlSpec\_ptr Ltl\_StructCheckLtlSpec\_create(Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create an empty Ltl_StructCheckLtlSpec structure.]

  Description        [Create an empty Ltl_StructCheckLtlSpec structure.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_destroy(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Desrtroy an Ltl_StructCheckLtlSpec structure.]

  Description        [Desrtroy an Ltl_StructCheckLtlSpec structure.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_set\_oreg2smv(Ltl\_StructCheckLtlSpec\_ptr self, Ltl\_StructCheckLtlSpec\_oreg2smv oreg2smv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the oreg2smv field of an Ltl_StructCheckLtlSpec structure]

  Description        [Set the oreg2smv field of an Ltl_StructCheckLtlSpec structure]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_set\_ltl2smv(Ltl\_StructCheckLtlSpec\_ptr self, Ltl\_StructCheckLtlSpec\_ltl2smv ltl2smv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the ltl2smv field of an Ltl_StructCheckLtlSpec structure]

  Description        [Set the ltl2smv field of an Ltl_StructCheckLtlSpec structure]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_set\_negate\_formula(Ltl\_StructCheckLtlSpec\_ptr self, boolean negate\_formula)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the negate_formula field of an Ltl_StructCheckLtlSpec structure]

  Description        [Set the negate_formula field of an Ltl_StructCheckLtlSpec structure]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_set\_do\_rewriting(Ltl\_StructCheckLtlSpec\_ptr self, boolean do\_rewriting)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the do_rewriting field of an Ltl_StructCheckLtlSpec
  structure]

  Description        [Set the do_rewriting field of an Ltl_StructCheckLtlSpec
  structure]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr Ltl\_StructCheckLtlSpec\_get\_s0(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the s0 field of an Ltl_StructCheckLtlSpec structure]

  Description        [Get the s0 field of an Ltl_StructCheckLtlSpec structure
  Returned bdd is NOT referenced.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr Ltl\_StructCheckLtlSpec\_get\_clean\_s0(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the s0 field purified by tableu variables]

  Description        [Get the s0 field  of an Ltl_StructCheckLtlSpec structure
  purified by tableu variables]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_build(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initialize the structure by computing the tableau for
  the LTL property]

  Description        [Initialize the structure by computing the tableau for
  the LTL property and computing the cross-product with the FSM of the model.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_check(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the check to see wether the property holds or not]

  Description        [Perform the check to see wether the property holds or not.
  Assumes the Ltl_StructcCheckLtlSpec structure being initialized before with
  Ltl_StructCheckLtlSpec_build.

  If compassion is present it calls the check method for compassion,
  otherwise the check method dedicated to the algorithm given by the
  value of the oreg_justice_emptiness_bdd_algorithm option. ]

  SideEffects        []

  SeeAlso            [ltl_stuctcheckltlspec_check_compassion,
  ltl_structcheckltlspec_check_el_bwd, ltl_structcheckltlspec_check_el_fwd]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_print\_result(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the result of the Ltl_StructCheckLtlSpec_check fun]

  Description        [Prints the result of the Ltl_StructCheckLtlSpec_check fun]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Ltl\_StructCheckLtlSpec\_build\_counter\_example(Ltl\_StructCheckLtlSpec\_ptr self, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the computation of a witness for a property]

  Description        [Perform the computation of a witness for a property.
  Assumes the Ltl_StructcCheckLtlSpec structure being initialized before with
  Ltl_StructCheckLtlSpec_build, and that Ltl_StructCheckLtlSpec_build has been
  invoked.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_StructCheckLtlSpec\_explain(Ltl\_StructCheckLtlSpec\_ptr self, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the computation of a witness for a property]

  Description        [Perform the computation of a witness for a property.
  Assumes the Ltl_StructcCheckLtlSpec structure being initialized before with
  Ltl_StructCheckLtlSpec_build, and that Ltl_StructCheckLtlSpec_build has been
  invoked.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddFsm\_ptr ltlPropAddTableau(Ltl\_StructCheckLtlSpec\_ptr self, FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Main routine to add the tableau to the FSM]

  Description        [The bdd fsm into the property will change]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Ltl\_apply\_input\_vars\_rewriting(Expr\_ptr spec, SymbTable\_ptr st, SymbLayer\_ptr layer, FlatHierarchy\_ptr outfh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis   [Takes a LTL formula and applies rewriting to get rid of
  input variables from the formula]

  Description [Rewriting makes side-effect on given hierarchy, and
  can declare new variables inside given layer.
  The resulting expression is flattened and define expanded.
  Invoker has to free returned expression exactly as if it was created by
  Compile_FlattenSexpExpandDefine.]

  SideEffects [layer and outfh are expected to get changed]

  SeeAlso     [Compile_FlattenSexpExpandDefine]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ltl\_spec\_to\_hierarchy(Expr\_ptr spec, node\_ptr context, SymbTable\_ptr st, node\_ptr (*what2smv)(unsigned int id, node\_ptr expr), SymbLayer\_ptr layer, FlatHierarchy\_ptr outfh)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Takes a formula (with context) and constructs the flat
  hierarchy from it.

  Description        []

  SideEffects        [layer and outfh are expected to get changed]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int ltl\_structcheckltlspec\_build\_tableau\_and\_prop\_fsm(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates the tableau]

  Description [Creates the tableau for a LTL property.  The FSM of the
  property contains the tableau. Returns 1 if an error is encountered
  during the tableau generation, 0 otherwise]

  SideEffects        [The bdd fsm into the prop will change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ltl\_structcheckltlspec\_check\_compassion(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the check to see wether the property holds or
  not using an algorithm for strong fairness]

  Description        [Assumes the Ltl_StructcCheckLtlSpec structure being
  initialized before with Ltl_StructCheckLtlSpec_build. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ltl\_structcheckltlspec\_check\_el\_bwd(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the check to see wether the property holds or
  not using the backward Emerson-Lei algorithm]

  Description        [Assumes the Ltl_StructcCheckLtlSpec structure being
  initialized before with Ltl_StructCheckLtlSpec_build. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ltl\_structcheckltlspec\_check\_el\_fwd(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Perform the check to see wether the property holds or
  not using the forward Emerson-Lei algorithm]

  Description        [Assumes the Ltl_StructcCheckLtlSpec structure being
  initialized before with Ltl_StructCheckLtlSpec_build. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ltl\_structcheckltlspec\_remove\_layer(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service that removes the given layer from
  the symbol table, and from both the boolean and bdd encodings.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr ltl\_clean\_bdd(Ltl\_StructCheckLtlSpec\_ptr self, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Quantify out tableau variables]

  Description        [Quantify out tableau variables]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ltl\_structcheckltlspec\_init(Ltl\_StructCheckLtlSpec\_ptr self, Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ltl\_structcheckltlspec\_deinit(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ltl\_structcheckltlspec\_prepare(Ltl\_StructCheckLtlSpec\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Support function for the init function]

  Description        [Support function for the init function]

  SideEffects        []

  SeeAlso            [ltl_structcheckltlspec_init]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ltlCmd.c}
		
	\texttt{void Ltl\_Init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the ltl package.]

  Description        [Initializes the ltl package.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCheckLtlSpec(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs LTL model checking]

  CommandName        [check_ltlspec]

  CommandSynopsis    [Performs LTL model checking]

  CommandArguments   [\[-h\] \[-m | -o output-file\] \[-n number | -p "ltl-expr \[IN context\]" | -P \"name\"\] ]

  CommandDescription [ Performs model checking of LTL formulas. LTL
  model checking is reduced to CTL model checking as described in the
  paper by \[CGH97\].<p>

  A <tt>ltl-expr</tt> to be checked can be specified at command line
  using option <tt>-p</tt>. Alternatively, option <tt>-n</tt> can be used
  for checking a particular formula in the property database. If
  neither <tt>-n</tt> nor <tt>-p</tt> are used, all the LTLSPEC formulas in
  the database are checked.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-m</tt>
       <dd> Pipes the output generated by the command in processing
           <tt>LTLSPEC</tt>s to the program specified by the
           <tt>PAGER</tt> shell variable if defined, else
           through the Unix command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command in processing
           <tt>LTLSPEC</tt>s to the file <tt>output-file</tt>.
    <dt> <tt>-p "ltl-expr \[IN context\]"</tt>
       <dd> An LTL formula to be checked. <tt>context</tt> is the module
       instance name which the variables in <tt>ltl_expr</tt> must be
       evaluated in.
    <dt> <tt>-n number</tt>
       <dd> Checks the LTL property with index <tt>number</tt> in the property
            database.
    <dt> <tt>-P name</tt>
       <dd> Checks the LTL property named <tt>name</tt> in the property
            database.
  </dl>]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ltlCompassion.c}
		
	\texttt{bdd\_ptr feasible(BddFsm\_ptr fsm, BddEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check for feasability]

  Description        [Checks whether the model has a fair path and returns
  the initial state of the path.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr witness(BddFsm\_ptr fsm, BddEnc\_ptr enc, bdd\_ptr feasib)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compute a withness of feasability]

  Description        [Computes fair path from one of the states 
  passed as parameter.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr successor(BddEnc\_ptr enc, bdd\_ptr from, bdd\_ptr relation)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

  Synopsis     [Compute the direct successor of a state]

  Description [Given a state from and transition relation, compute the
  direct successor state.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr successors(BddEnc\_ptr enc, bdd\_ptr from, bdd\_ptr relation)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

  Synopsis     [Compute the direct and indirect successors of a state]

  Description [Given a state from and transition relation, compute the
  direct and indirect successor states (transitive closure of
  successor).]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr predecessor(BddEnc\_ptr enc, bdd\_ptr relation, bdd\_ptr to)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

  Synopsis     [Compute the direct predecessor of a state]

  Description [Given a state to and a transition relation, compute the
  direct predecessor state.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr predecessors(BddEnc\_ptr enc, bdd\_ptr relation, bdd\_ptr to)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

  Synopsis     [Compute the direct and indirect predecessors of a state]

  Description [Given a state to and a transition relation, compute the
  direct and indirect predecessor states (transitive closure of
  predecessor).]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr path(BddEnc\_ptr enc, bdd\_ptr source, bdd\_ptr dest, bdd\_ptr R)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compute a path from source to destination]

  Description        [Computes a path given the bdds representind the source
  states, the target states, and the transition relation.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr fill\_path\_with\_inputs(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Fill a path with inputs.]

  Description        [Fills a path with inputs.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ltlRewrite.c}
		
	\texttt{node\_ptr Ltl\_RewriteInput(SymbTable\_ptr symb\_table, node\_ptr expr, SymbLayer\_ptr layer, node\_ptr* init, node\_ptr* invar, node\_ptr* trans, const LtlRewriteType rewrite\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Rewrites an LTL formula to get rid of input variables
  in it present]

  Description [The function takes an LTL formula and rewrite it such a
  way that it will not contain input variables any more. See the
  description of this file for more details.

  "layer" is the later where new state variables are defined (if it is
  required).

  "init", "invar", "trans" point to expressions corresponding to
  initial condition, invariant and transition relations of the
  hierarchy, respect. This expressions are added new expression if required.

  The returned expressions (the LTL formula and parts of hierarchy)
  are newly created node_ptr constructs and have to be freed by the
  invoker.
  NOTE ABOUT MEMORY: New expressions are created exactly the same way
  as it is done by Compile_FlattenSexpExpandDefine.

  Precondition: input expression has to be already flattened.

  rewrite_type determines the type of rewriting to be perfomed. For
  further details, please see the description of this file.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static LtlInputKind ltl\_rewrite\_input(SymbTable\_ptr symb\_table, node\_ptr* expr, NodeList\_ptr new\_var\_exprs, const LtlRewriteType rw\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Recursively walk over the expressions and returns
  the kind of the expression, i.e. if it is temporal or with input vars.]

  Description [A copy of the provided expression is created and
  returned in the same pointer "expr". The copy may be exact or
  already rewritten (to remove inputs in temporal expressions).

  "new_var_exprs" is a list of pairs (CONS) of a new state var
  introduced during rewriting and an expression associated with that
  state variable.

  Precondition: the expression have to be correctly typed.

  NOTE FOR DEVELOPERS: This function creates new expression using the
  same approach as compileFlattenSexpRecur, i.e. consts and ids are
  find_atom-ed and operations are new_node-ed. Both functions should be
  changed synchronously.]

  SideEffects []

  SeeAlso     [LtlInputKind]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr ltl\_create\_substitution(SymbTable\_ptr symb\_table, node\_ptr expr, NodeList\_ptr new\_var\_exprs, const LtlRewriteType rewrite\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a new state variable and add a pair <var id, expr>
  to the list "new_var_exprs"]

  Description [The purpose of the function is to create a substitution
  for the given expression in an LTL formula.

  The function returns:
     if rewrite_type is
      LTL_REWRITE_STANDARD : new identifiers.
      LTL_REWRITE_DEADLOCK_FREE: "X new_identifier"
      ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{mc}
		
	\subsection{mcAGonly.c}
		
	\texttt{void Mc\_CheckAGOnlySpec(Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This function checks for SPEC of the form AG
  alpha in "context".]

  Description [The implicit assumption is that "spec" must be an AG
  formula (i.e. it must contain only conjunctions and AG's).  No attempt
  is done to normalize the formula (e.g. push negations). The AG mode
  relies on the previous computation and storage of the reachable
  state space (<tt>reachable_states_layers</tt>), they are used in
  counterexample computation.]

  SideEffects        []

  SeeAlso            [check_spec]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean check\_AG\_only(BddFsm\_ptr fsm, BddEnc\_ptr enc, Prop\_ptr prop, Expr\_ptr spec, node\_ptr context, NodeList\_ptr symbols, Trace\_ptr* out\_trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function checks for SPEC of the form AG alpha in
               "context".]

  Description [The implicit assumption is that "spec" must be an AG
               formula (i.e. it must contain only conjunctions and
               AG's).  No attempt is done to normalize the formula
               (e.g. push negations). The AG mode relies on the
               previous computation and storage of the reachable state
               space (<tt>reachable_states_layers</tt>), they are used
               in counterexample computation.

               Returns true iff the property is true.]

  SideEffects [*out_trace contains the counterexample trace (where
               applicable)]

  SeeAlso     [check_spec]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr make\_AG\_counterexample(BddFsm\_ptr fsm, BddStates target\_states)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This function constructs a counterexample
  starting from state target_state]

  Description        [Compute a counterexample starting from a given state.
  Returned counterexample is a sequence of "state (input, state)*"]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean is\_AG\_only\_formula(node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the formulas is of type AGOnly.]

  Description        [returns true , if the formula is AGOnly formula.]

  SideEffects        []

  SeeAlso            [is_AG_only_formula_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean is\_AG\_only\_formula\_recur(node\_ptr n, int* ag\_count)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Recursive function that helps is_AG_only_formula.]

  Description        []

  SideEffects        []

  SeeAlso            [is_AG_only_formula]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{mcCmd.c}
		
	\texttt{void Mc\_Init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the mc package.]

  Description        [Initializes the mc package.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Mc\_End(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Quit the mc package]

  Description        [Quit the mc package]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Mc\_check\_psl\_property(Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Top-level function for mc of PSL properties]

  Description        [The parameters are:
  - prop is the PSL property to be checked
  ]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCheckCtlSpec(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs fair CTL model checking.]

  CommandName        [check_ctlspec]

  CommandSynopsis    [Performs fair CTL model checking.]

  CommandArguments   [\[-h\] \[-m | -o output-file\] \[-n number | -p "ctl-expr \[IN context\]" | -P "name"\]]

  CommandDescription [Performs fair CTL model checking.<p>

  A <tt>ctl-expr</tt> to be checked can be specified at command line
  using option <tt>-p</tt>. Alternatively, option <tt>-n</tt> or
  <tt>-P</tt> can be used for checking a particular formula in the
  property database. If neither <tt>-n</tt> nor <tt>-p</tt> are used,
  all the SPEC formulas in the database are checked.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-m</tt>
       <dd> Pipes the output generated by the command in processing
           <tt>SPEC</tt>s to the program specified by the
           <tt>PAGER</tt> shell variable if defined, else
           through the <tt>UNIX</tt> command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command in processing
           <tt>SPEC</tt>s to the file <tt>output-file</tt>.
    <dt> <tt>-p "ctl-expr \[IN context\]"</tt>
       <dd> A CTL formula to be checked. <tt>context</tt> is the module
       instance name which the variables in <tt>ctl-expr</tt> must
       be evaluated in.
    <dt> <tt>-n number</tt>
       <dd> Checks the CTL property with index <tt>number</tt> in the property
            database.
    <dt> <tt>-P name</tt>
       <dd> Checks the CTL property with name <tt>name</tt> in the property
            database.
  </dl><p>

  If the <tt>ag_only_search</tt> environment variable has been set, and
  the set of reachable states has already been computed, then a
  specialized algorithm to check AG formulas is used instead of the
  standard model checking algorithms.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCheckInvar(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs model checking of invariants]

  CommandName        [check_invar]

  CommandSynopsis    [Performs model checking of invariants]

  CommandArguments [\[-h\] \[-m | -o output-file\] \[-s "strategy"\]
  \[-e "heuristic"\] \[-t number\] \[-k number\] \[-j "heuristic"\]
  \[-n number | -p "invar-expr \[IN context\]" | -P "name"\]]

  CommandDescription [Performs invariant checking on the given
  model. An invariant is a set of states. Checking the invariant is
  the process of determining that all states reachable from the
  initial states lie in the invariant.

  Invariants to be verified can be provided as simple formulas
  (without any temporal operators) in the input file via the
  <tt>INVARSPEC</tt> keyword or directly at command line, using the option
  <tt>-p</tt>.<p>

  Option <tt>-n</tt> can be used for checking a particular invariant
  of the model. If neither <tt>-n</tt> nor <tt>-p</tt> are
  used, all the invariants are checked.<p>

  During checking of invariant all the fairness conditions associated
  with the model are ignored.<p>

  If an invariant does not hold, a proof of failure is demonstrated.
  This consists of a path starting from an initial state to a state
  lying outside the invariant. This path has the property that it is the
  shortest path leading to a state outside the invariant.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-m</tt>
       <dd> Pipes the output generated by the program in processing
           <tt>INVARSPEC</tt>s to the program specified by the
           <tt>PAGER</tt> shell variable if defined, else
           through the UNIX command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command in processing
           <tt>INVARSPEC</tt>s to the file <tt>output-file</tt>.
    <dt> <tt>-s <i>strategy</i></tt>
    <dd> Force the analysis strategy.
    <dt> <tt>-e <i>heuristic</i></tt>
    <dd> Force the search heuristic for the forward-backward strategy.
    <dt> <tt>-t <i>number</i></tt>
    <dd> When using the mixed BDD and BMC approach specify the heuristic threshold.
    <dt> <tt>-k <i>number</i></tt>
    <dd> When using the mixed BDD and BMC approach specify the BMC max k.
    <dt> <tt>-j <i>heuristic</i></tt>
    <dd> Force the switch heuristic for the BDD-BMC strategy.
    <dt> <tt>-p "invar-expr \[IN context\]"</tt>
       <dd> The command line specified invariant formula to be verified.
       <tt>context</tt> is the module instance name which the variables
       in <tt>invar-expr</tt> must be evaluated in.
    <dt> <tt>-P name</tt>
       <dd> Checks the INVARSPEC with name <tt>name</tt> in the property
            database.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCheckCompute(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs computation of quantitative characteristics]

  CommandName        [check_compute]

  CommandSynopsis    [Performs computation of quantitative characteristics]

  CommandArguments   [\[-h\] \[-m | -o output-file\] \[-n number |
  -p "compute-expr \[IN context\]" | -P "name"\]]

  CommandDescription [This command deals with the computation of
  quantitative characteristics of real time systems. It is able to
  compute the length of the shortest (longest) path from two given set
  of states.<p>

  <center><code>MAX \[ alpha , beta \]</code></center><br>
  <center><code>MIN \[ alpha , beta \]</code></center><p>

  Properties of the above form can be specified in the input file via
  the keyword <code>COMPUTE</code> or directly at command line,
  using option <tt>-p</tt>.<p>

  Option <tt>-n</tt> can be used for computing a particular expression
  in the model. If neither <tt>-n</tt> nor <tt>-p</tt> nor <tt>-P</tt>
  are used, all the COMPUTE specifications are computed.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-m</tt>
       <dd> Pipes the output generated by the command in processing
           <tt>COMPUTE</tt>s to the program specified by the
           <tt>PAGER</tt> shell variable if defined, else
           through the UNIX command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command in processing
           <tt>COMPUTE</tt>s to the file <tt>output-file</tt>.
    <dt> <tt>-p "compute-expr \[IN context\]"</tt>
       <dd> A COMPUTE formula to be checked. <tt>context</tt> is the module
       instance name which the variables in <tt>compute-expr</tt> must
       be evaluated in.
    <dt> <tt>-n number</tt>
       <dd> Computes only the property with index <tt>number</tt>
    <dt> <tt>-P name</tt>
       <dd> Computes only the property named <tt>name</tt>
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCheckPslSpec(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs fair PSL model checking.]

  CommandName        [check_pslspec]

  CommandSynopsis    [Performs fair PSL model checking.]

  CommandArguments   [\[-h\] \[-m | -o output-file\] \[-n number | -p "psl-expr \[IN context\]" | -P "name"\]
  \[-b|-s \[-i\] \[-c\] \[-N\] \[-g\] \[-1\] \[-k bmc_length\] \[-l loopback\]\]]

]

  CommandDescription [Performs fair PSL model checking.<p>

  A <tt>psl-expr</tt> to be checked can be specified at command line
  using option <tt>-p</tt>. Alternatively, option <tt>-n</tt> can be used
  for checking a particular formula in the property database. If
  neither <tt>-n</tt> nor <tt>-p</tt> are used, all the PSLSPEC formulas in
  the database are checked.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-m</tt>
       <dd> Pipes the output generated by the command in processing
           <tt>SPEC</tt>s to the program specified by the
           <tt>PAGER</tt> shell variable if defined, else
           through the <tt>UNIX</tt> command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command in processing
           <tt>PSLSPEC</tt>s to the file <tt>output-file</tt>.
    <dt> <tt>-p "psl-expr \[IN context\]"</tt>
       <dd> A PSL formula to be checked. <tt>context</tt> is the module
       instance name which the variables in <tt>ctl-expr</tt> must
       be evaluated in.
    <dt> <tt>-n number</tt>
       <dd> Checks the PSL property with index <tt>number</tt> in the property
            database.
    <dt> <tt>-P name</tt>
       <dd> Checks the PSL property named <tt>name</tt> in the property
            database.

    <dt> <tt>-b</tt> When specified, the BMC engine will be used for
    checking those PSL properties that can be converted to LTL
    specifications. The SAT solver to be used will be chosen according
    to the current value of the system variable sat_solver. Non-LTL
    properties will be ignored.

    <dt> <tt>-s</tt> When specified, the SBMC engine will be used for
    checking those PSL properties that can be converted to LTL
    specifications. The SAT solver to be used will be chosen according
    to the current value of the system variable sat_solver. Non-LTL
    properties will be ignored.

    <dt> <tt>-i</tt> Uses incremental SAT solving when this feature is
    available. This option must be mandatorily used in combination
    with the option -b.

    <dt> <tt>-c</tt> Performs completeness check. This option can be
    used only in combination with -s. This options implies also -i

    <dt> <tt>-N</tt> Does not perform virtual unrolling. This option can be
    used only in combination with -s. This options implies also -i


    <dt> <tt>-g</tt> While solving a problem, dumps it as a DIMACS
    file whose name depends on the content of the system variable
    "bmc_dimacs_filename". This feature is not allowed when the option
    -i is used as well.

    <dt> <tt>-1</tt> Generates and solves a single problem instead of
    iterating through 0 and bmc_length.

    <dt> <tt>-k <i>bmc_length</i></tt>
       <dd> <i>bmc_length</i> is the maximum problem bound must be reached if
       the option -1 is not specified. If -1 is specified, <i>bmc_length</i> is
       the exact length of the problem to be generated.
       Only natural number are valid values for this option. If no value
       is given the environment variable <i>bmc_length</i> is considered
       instead.
    <dt> <tt>-l <i>loopback</i></tt>
       <dd> <i>loopback</i> value may be: <BR>
       - a natural number in (0, <i>bmc_length-1</i>). Positive sign ('+') can
       be also used as prefix of the number. Any invalid combination of length
       and loopback will be skipped during the generation/solving process.<BR>
       - a negative number in (-1, -<i>bmc_length</i>). In this case
       <i>loopback</i> is considered a value relative to <i>bmc_length</i>.
       Any invalid combination of length and loopback will be skipped
       during the generation/solving process.<BR>
       - the symbol 'X', which means "no loopback" <BR>
       - the symbol '*', which means "all possible loopback from zero to
       <i>bmc_length-1</i>"

  </dl><p>

  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandLanguageEmptiness(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks for language emptiness.]

  CommandName        [language_emptiness]

  CommandSynopsis    [Checks for language emptiness.]

  CommandArguments   [\[-h\] \[-v\] \[-a\]]

  CommandDescription [Checks for the language emptiness. <br>

  If <tt>-a</tt> is given the check is performed by verifying whether
  all initial states are included in the set of fair states. If it is
  the case from all initial states there exists a fair path and thus
  the language is not empty. On the other hand, if no <tt>-a</tt> is
  specified, the check is performed by verifying whether there exists
  at least one inital state that is also a fair state. In this case
  there is an initial state from which it starts a fair path and thus
  the lnaguage is not empty.

  if <tt>-v</tt> is specified, then some information on the set of
  initial states is printed out too.  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CommandCheckSpec(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deprecated version of CommandCheckCtlSpec]

  Description        [Provided for backward compatibility]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int mc\_cmd\_check\_compute(int argc, char **argv, int (*usage\_fun)(void))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [helper function of commands check_compute and compute]

  Description        [helper function of commands check_compute and compute]

  SideEffects        []

  SeeAlso            [CommandCheckCompute CommandCompute]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{mcEval.c}
		
	\texttt{bdd\_ptr eval\_ctl\_spec(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compile a CTL formula into BDD and performs
  Model Checking.]

  Description        [Compile a CTL formula into BDD and performs
  Model Checking.]

  SideEffects        []

  SeeAlso            [eval_compute]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr eval\_formula\_list(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr nodes, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This function takes a list of formulas, and
  returns the list of their BDDs.]

  Description        [This function takes as input a list of formulae,
  and return as output the list of the corresponding BDDs, obtained by
  evaluating each formula in the given context.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int eval\_compute(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes shortest and longest length of the path
  between two set of states.]

  Description        [This function performs the invocation of the
  routines to compute the length of the shortest and longest execution
  path between two set of states s_1 and s_2.]

  SideEffects        []

  SeeAlso            [eval_ctl_spec]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void free\_formula\_list(DdManager* dd, node\_ptr formula\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees a list of BDD as generated by eval_formula_list]

  Description        [Frees a list of BDD as generated by eval_formula_list]

  SideEffects        []

  SeeAlso            [eval_formula_list]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr eval\_ctl\_spec\_recur(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Recursive step of <code>eval_ctl_spec</code>.]

  Description [Performs the recursive step of
  <code>eval_ctl_spec</code>.]

  SideEffects        []

  SeeAlso            [eval_ctl_spec]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int eval\_compute\_recur(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr n, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Recursive step of <code>eval_compute</code>.]

  Description        [Performs the recursive step of <code>eval_compute</code>.]

  SideEffects        []

  SeeAlso            [eval_compute]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr unary\_bdd\_op(BddFsm\_ptr fsm, BddEnc\_ptr enc, BDDPFDB op, node\_ptr n, int resflag, int argflag, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies unary operation.]

  Description        [Takes in input the expression <code>n</code> and a
  unary operation <code>op</code>. Evaluates <code>n</n> and applies to this
  partial result the unary operator <code>op</code>. The sign of the
  partial result and of the result depends respectively from the flag
  <code>argflag</code> and <code>resflag</code>.] 

  SideEffects        []

  SeeAlso            [binary_bdd_op, ternary_bdd_op, quaternary_bdd_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr binary\_bdd\_op(BddFsm\_ptr fsm, BddEnc\_ptr enc, BDDPFDBB op, node\_ptr n, int resflag, int argflag1, int argflag2, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies binary operation.]

  Description        [Takes in input the expression <code>n</code> and a
  binary operation <code>op</code>. Extracts from <code>n</n> the operands
  and evaluates them. The binary operator <code>op</code> is then applied
  to these partial results. The sign of the partial results and of the
  result depends respectively from the flags <code>argflag1</code>,
  <code>argflag2</code> and <code>resflag</code>.]

  SideEffects        []

  SeeAlso            [unary_bdd_op, ternary_bdd_op, quaternary_bdd_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr unary\_mod\_bdd\_op(BddFsm\_ptr fsm, BddEnc\_ptr enc, BDDPFFB op, node\_ptr n, int resflag, int argflag, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies unary operation.]

  Description        [Takes in input the expression <code>n</code> and a
  unary operation <code>op</code>. Evaluates <code>n</n> and applies to this
  partial result the unary operator <code>op</code>. The sign of the
  partial result and of the result depends respectively from the flag
  <code>argflag</code> and <code>resflag</code>.] 

  SideEffects        []

  SeeAlso            [binary_bdd_op, ternary_bdd_op, quaternary_bdd_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr binary\_mod\_bdd\_op(BddFsm\_ptr fsm, BddEnc\_ptr enc, BDDPFFBB op, node\_ptr n, int resflag, int argflag1, int argflag2, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies binary operation.]

  Description        [Takes in input the expression <code>n</code> and a
  binary operation <code>op</code>. Extracts from <code>n</n> the operands
  and evaluates them. The binary operator <code>op</code> is then applied
  to these partial results. The sign of the partial results and of the
  result depends respectively from the flags <code>argflag1</code>,
  <code>argflag2</code> and <code>resflag</code>.]

  SideEffects        []

  SeeAlso            [unary_bdd_op, ternary_bdd_op, quaternary_bdd_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr binary\_mod\_bdd\_op\_ns(BddFsm\_ptr fsm, BddEnc\_ptr enc, BDDPFFBB op, node\_ptr n, int resflag, int argflag1, int argflag2, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies binary operation.]

  Description        [Takes in input the expression <code>n</code> and a
  binary operation <code>op</code>. Extracts from <code>n</n> the operands
  and evaluates them. The binary operator <code>op</code> is then applied
  to these partial results. The sign of the partial results and of the
  result depends respectively from the flags <code>argflag1</code>,
  <code>argflag2</code> and <code>resflag</code>.<br>
  The only difference between this and "binary_mod_bdd_op" is that the
  result of the application of the operation passed as argument is not
  referenced. This is used for example in the "minu" and "maxu" operations.]

  SideEffects        []

  SeeAlso            [unary_bdd_op, ternary_bdd_op, quaternary_bdd_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr ternary\_mod\_bdd\_op(BddFsm\_ptr fsm, BddEnc\_ptr enc, BDDPFFBII op, node\_ptr n, int resflag, int argflag, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies ternary operation.]

  Description        [Takes in input the expression <code>n</code> and a
  ternary operation <code>op</code>. Extracts from <code>n</n> the operands
  and evaluates them.<br>
  The second and third arguments have to evaluate to numbers. And
  <code>op</code> is a function that takes as input an BDD an two integers.
  The ternary operator <code>op</code> is then applied to these partial
  results. The sign of the partial result and of the result depends
  respectively from the flags <code>argflag</code> and <code>resflag</code>.]

  SideEffects        []

  SeeAlso            [unary_bdd_op, binary_bdd_op, quaternary_bdd_op]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr quad\_mod\_bdd\_op(BddFsm\_ptr fsm, BddEnc\_ptr enc, BDDPFFBBII op, node\_ptr n, int resflag, int argflag1, int argflag2, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies quaternary operation.]

  Description        [Takes in input the expression <code>n</code> and a
  quaternary operation <code>op</code>. Extracts from <code>n</n> the operands
  and evaluates them.<br>
  The third and fourth arguments have to evaluate to numbers. And
  <code>op</code> is a function that takes as input two BDD and two integers.
  The quaternary operator <code>op</code> is then applied to these partial
  results. The sign of the partial result and of the result depends
  respectively from the flags <code>argflag1</code>, <code>argflag2</code> and
  <code>resflag</code>.]

  SideEffects        []

  SeeAlso            [unary_bdd_op, binary_bdd_op, ternary_bdd_op]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{mcExplain.c}
		
	\texttt{node\_ptr explain(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, node\_ptr spec\_formula, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [Counterexamples and witnesses generator.]

   Description        [This function takes as input a CTL formula and
   returns a witness showing how the given formula does not hold. The
   result consists of a list of states (i.e. an execution trace) that
   leads to a state in which the given formula does not hold.]

   SideEffects        []

   SeeAlso            [explain_recur ex_explain eu_explain eg_explain
   ebg_explain ebu_explain]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr ex\_explain(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, bdd\_ptr f)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [This function computes a path that is a witness
   for <i>EX(f)</i>.]

   Description        [This function finds a path that is a witness for
   <i>EX(f)</i>. <code>path<code> is a BDD which represents the first
   state of the path. It essentially is an initial state from which the
   example can be found.  The formula <i>EX(f)</i> holds under
   fairness constraints in a state <i>s_i</i> iff there is a
   successor state <i>s_{i+1}</i> such that <i>s_{i+1}</i>
   satisfies <i>f</i> and </i>s_{i+1}</i> is the beginning of some
   fair computation path. We look for states that can be reached from
   the state stored as first element in <code>path</code>, which are fair and
   in which <i>f</i> is satisfied. The algorithm computes more than
   one state, in order to have only one state we apply
   <code>bdd_pick_one_state</code>. The result of this application is
   then put in AND with <code>path</code> to form the witness.]

   SideEffects        []

   SeeAlso            [explain]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr eu\_si\_explain(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, bdd\_ptr f, bdd\_ptr g\_si, bdd\_ptr hulk)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [This function finds a path that is a witness
   for <i>E\[f U g\]</i> when g is a set of  state-inputs ]

   Description []

   SideEffects        []

   SeeAlso            [explain]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr eu\_explain(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, bdd\_ptr f, bdd\_ptr g)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [This function finds a path that is a witness
   for <i>E\[f U g\]</i>]

   Description [This function finds a path of single states that is a
   witness for <i>E\[f U g\]</i>. The first element of
   <code>path</code> is a BDD <code>p</code> representing a set of
   states from which the first state of the witness path is taken.

   The procedure is to try to execute <code>eu(f,g)</code> again,
   looking for a path from <code>p</code> along states satisfying
   <code>f</code> to a state where <i>g</i> is valid.  The found path
   is then stored in <code>path</code> in reverse order.  Note that in
   the found path every state is a minterm, i.e. a single state, not a
   set. Also the original first element of <code>path</code> is reset
   to minterm.

   If a witness is not found then Nil is return and nothing is modified.
   ]

   SideEffects        []

   SeeAlso            [explain]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr eg\_explain(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr witness\_path, bdd\_ptr arg\_g)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [This function finds a path that is an example
   for <i>EG(g)</i>.]

   Description [This function finds a path that is an example for
   <i>EG(g)</i>. The first element <code>p</code> is the BDD that
   represents the first state of the path. It is an initial state from
   which the example can be found.<br>

   The procedure is based on the greatest fixed point characterization
   for the CTL operator <b>EG</b>. The CTL formula <i>EG(g)</i> under
   fairness constraints means that there exists a path beginning with
   current state on which <i>g</i> holds globally (invariantly) and
   each formula in the set of fairness constraints holds infinitely
   often on the path.  If we denote with <i>EG(g)</i> the set of states
   that satisfy <i>EG(g)</i> under fairness constraints, we can
   construct the witness path incrementally by giving a sequence of
   prefixes of the path of increasing length until a cycle is found. At
   each step in the construction we must ensure that the current prefix
   can be extended to a fair path along which each state satisfies
   <i>EG(g)</i>.]

   SideEffects        []

   SeeAlso            [explain]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr ebu\_explain(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, bdd\_ptr f, bdd\_ptr g, int inf, int sup)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [This function finds a path that is a witness
   for <i>E\[f U g\]^{sup}_{inf}</i>.]

   Description        [This function finds a path that is a witness
   for <i>E\[f U g\]^{sup}_{inf}</i>. The first element of
   <code>path</code> is a BDD that represents the first state of the
   path. It is an initial state from which the example can be found.
   The procedure is to try to execute <code>ebu(f, g, inf,
   sup)</code>, looking for a path, with length <code>(sup -
   inf)<code>, from <code>p</code> to a state where <i>g</i> is valid
   using only transitions from states satisfying <i>f</i>.]

   SideEffects        []

   SeeAlso            [explain]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr ebg\_explain(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, bdd\_ptr g, int inf, int sup)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [This function finds a path of length
   <tt>(sup-inf)</tt> that is an example for
   <i>EG(g)^{sup}_{inf}</i>.]

   Description        [This function finds a path of length
   <tt>(sup-inf)</tt> that is an example for <i>EG(g)^{sup}_{inf}</i>.
   The first element of <code>p</code> is the BDD that represents the
   first state of the path. It is an initial state from which the
   example has to be found.]

   SideEffects        []

   SeeAlso            [explain]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr explain\_recur(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, node\_ptr formula\_expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [Recursively traverse the formula CTL and rewrite
   it in order to use the base witnesses generator functions.]

   Description        [Recursively traverse the formula CTL and rewrite
   it in order to use the base witnesses generator functions.<br>
   The rewritings performed use the equivalence between CTL formulas,
   i.e. <i>A\[f U g\]</i> is equivalent to
   <i>!(E\[!g U (!g & !f)\] | EG !g)</i>.]

   SideEffects        []

   SeeAlso            [explain]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr fairness\_explain(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr witness\_path, bdd\_ptr hulk\_si, JusticeList\_ptr fairness\_constrainst\_list)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [Auxiliary function to the computation of a
   witness of the formula <i>EG f</i>.]

   Description        [In the computation of the witness for the
   formula <i>EG f</i>, at each step we must ensure that the current
   prefix can be extended to a fair path along which each state
   satisfies <i>f</i>. This function performs the inner fixpoint
   computation for each fairness constraints in the fix point
   computation of the formula <i>EG(f)<i>. For every constraints
   <i>h</i>, we obtain an increasing sequence of approximations Q_0^h,
   Q_1^h, ..., where each Q_i^h is the set of states from which a state
   in the accumulated set can be reached in <i>i</i> or fewer steps,
   while satisfying <i>f</i>.]

   SideEffects        []

   SeeAlso            [explain, eg_explain, fair_iter, eg]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr explain\_and(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, node\_ptr formula\_expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

  Synopsis      [Generates a witness path for car(formula) AND cdr(formula)]

  Description   [Generates a witness path for car(formula) AND cdr(formula)]

  SideEffects   [None]

  SeeAlso       [explain_recur]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr explain\_eval(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, node\_ptr formula\_expr, node\_ptr context)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

  Synopsis           [required]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr Extend\_trace\_with\_state\_input\_pair(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, bdd\_ptr starting\_state, bdd\_ptr next\_states, const char * comment)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

  Synopsis            []

   Description        []

   SideEffects        []

   SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr Extend\_trace\_with\_states\_inputs\_pair(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, bdd\_ptr starting\_states, bdd\_ptr next\_states, const char * comment)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void Check\_TraceList\_Sanity(BddEnc\_ptr enc, node\_ptr path, const char * varname)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void mc\_eu\_explain\_restrict\_state\_input\_to\_minterms(BddFsm\_ptr fsm, BddEnc\_ptr enc, node\_ptr path, node\_ptr initial\_node)}
	\begin{verbatimtab}
		
/**Function*******************************************************************

   Synopsis           [Given a path the function restrict its states
   and inputs to minterms]

   Description        ['path' is a list of ((state, input)+, state).
   States and inputs are BDDs.
   The list has to be reversed i.e. state car(path) can be reached
   from state car(cdr(cdr(path))) through input car(cdr(path)).

   The first element of the path, i.e. car(path) has to be already
   minterm.

   The function restricts every state and input to single state/input,
   resp, i.e. to minterm.

   initial_node is the last state node of path to be restricted.]

   SideEffects        []

   SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\subsection{mcInvar.c}
		
	\texttt{void Mc\_CheckInvar(Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Verifies that M,s0 |= AG alpha]

   Description [Verifies that M,s0 |= AG alpha, with alpha propositional.
   Uses strategy read from the option variable. ]

   SideEffects []

   SeeAlso     [check_spec check_ltlspec Mc_CheckInvar_With_Strategy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Mc\_CheckInvarSilently(Prop\_ptr prop, Trace\_ptr* trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Verifies that M,s0 |= AG alpha WITHOUT print results or
                counterexamples ]

   Description [Verifies that M,s0 |= AG alpha, with alpha propositional.
   Uses strategy read from the option variable.

   If opt_counter_examples is setted and trace is not null, then a
   trace is stored (and must be released by caller) in trace
   parameter location.

   The result of model checking is stored in the given property. ]

   SideEffects []

   SeeAlso     [check_spec check_ltlspec Mc_CheckInvar_With_Strategy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Mc\_CheckInvar\_With\_Strategy(Prop\_ptr prop, Check\_Strategy strategy, Trace\_ptr* output\_trace, boolean silent)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Verifies that M,s0 |= AG alpha with the specified strategy]

   Description [Verifies that M,s0 |= AG alpha, with alpha propositional.
   Uses strategy given in input

   If opt_counter_examples is setted and trace is not null, then a
   trace is stored (and must be released by caller) in trace
   parameter location.

   The result of model checking is stored in the given property.
   ]

   SideEffects []

   SeeAlso     [check_spec check_ltlspec Mc_CheckInvar]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Mc\_CheckInvar\_With\_Strategy\_And\_Symbols(Prop\_ptr prop, Check\_Strategy strategy, Trace\_ptr* output\_trace, boolean silent, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Verifies that M,s0 |= AG alpha with the specified strategy]

   Description [Verifies that M,s0 |= AG alpha, with alpha propositional.
   Uses strategy given in input.

   If opt_counter_examples is setted and trace is not null, then a
   trace is stored (and must be released by caller) in trace
   parameter location. A trace is created for variables and defines in 'symbols'.
   If trace is not required 'symbols' can be NULL.

   The result of model checking is stored in the given property.
   ]

   SideEffects []

   SeeAlso     [check_spec check_ltlspec Mc_CheckInvar]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SexpFsm\_ptr Mc\_rewrite\_invar\_get\_sexp\_fsm(const Prop\_ptr prop, SymbLayer\_ptr layer, node\_ptr* created\_var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [ Prepares the rewriting generating a new sexp fsm
   containing the needed observer variable and its
   transition relation as well as its initial state.]

   Description        [ Returns the scalar fsm and the third argument will
   be filled with the name of the monitor variable ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr compute\_path\_fb (BddFsm\_ptr fsm, bdd\_ptr target\_states, node\_ptr f\_list, node\_ptr b\_list, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Generates a counterexample from a path forward and a
   path backward]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr compute\_and\_complete\_path (BddFsm\_ptr fsm, bdd\_ptr start\_fw\_state, bdd\_ptr start\_bw\_state, node\_ptr f\_list, node\_ptr b\_list, NodeList\_ptr symbols, Trace\_ptr* middle\_trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Generates a counterexample from a path forward and a
   path backward completing the two parts with the specified middle trace if
   needed]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int check\_invariant\_forward\_backward\_with\_break(BddFsm\_ptr fsm, Prop\_ptr inv\_prop, heuristic\_type heuristic, stopping\_heuristic\_type stopping\_h, NodeList\_ptr symbols, Trace\_ptr* output\_trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Performs on the fly verification of the
   invariant during reachability analysis.]

   Description        [During the computation of reachable states it
   checks invariants. If the invariant is not satisfied, then an
   execution trace leading to a state not satisfing the invariant is
   printed out. This function differs from check_invariant_forward
   since it performs backward and forward search.

   NOTE: returns 0 if the property is false, 1 if it is true, 2 if BMC
   was not able to solve the problem

   If opt_counter_examples is setted and trace is not null, then a
   trace is stored (and must be released by caller) in trace
   parameter location.

   The result of model checking is stored in the given property.
   ]

   SideEffects        []

   SeeAlso            [check_invariant_forward]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void print\_invar(FILE *file, Prop\_ptr p)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Print an invariant specification]

   Description        [Print an invariant specification]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void print\_result(Prop\_ptr p)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis          [Prints the result of the check if the check was performed,
   does nothing otherwise]

   Description        [Print an invariant specification check result]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Prop\_ptr mc\_rewrite\_invar(const Prop\_ptr prop, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [ Rewrites an invariant specification containing input
   variables or next with an observer state variable ]

   Description        [ Returns a rewrited property ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void mc\_rewrite\_cleanup(Prop\_ptr rewritten\_prop, SymbLayer\_ptr layer)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [ Crean up the memory after the rewritten property check ]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int check\_invariant(BddFsm\_ptr fsm, Prop\_ptr inv\_prop, Check\_Strategy strategy, NodeList\_ptr symbols, Trace\_ptr* trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Check the given invariant with the specified technology]

   Description [If opt_counter_examples is setted and trace is not
   null, then a trace is stored (and must be released by caller) in
   trace parameter location.

   The result of model checking is stored in the given property.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Step\_Direction forward\_heuristic (DdManager* dd, bdd\_ptr reachable\_frontier, bdd\_ptr bad\_frontier, bdd\_ptr reachable\_states, bdd\_ptr bad\_states, int turn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Constant function to perform forward analysis]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Step\_Direction backward\_heuristic (DdManager* dd, bdd\_ptr reachable\_frontier, bdd\_ptr bad\_frontier, bdd\_ptr reachable\_states, bdd\_ptr bad\_states, int turn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Constant function to perform backward analysis]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean never\_stopping\_heuristic (DdManager* dd, bdd\_ptr reachable\_frontier, bdd\_ptr bad\_frontier, bdd\_ptr reachable\_states, bdd\_ptr bad\_states, int turn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Constant function to perform backward, forward and
   FB analysis]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Step\_Direction forward\_backward\_heuristic (DdManager* dd, bdd\_ptr reachable\_frontier, bdd\_ptr bad\_frontier, bdd\_ptr reachable\_states, bdd\_ptr bad\_states, int turn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Heuristic function used to decide the sept to perform
   in forward-backward analysis]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean stopping\_heuristic(DdManager* dd, bdd\_ptr reachable\_frontier, bdd\_ptr bad\_frontier, bdd\_ptr reachable\_states, bdd\_ptr bad\_states, int turn)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Heuristic function used to decide whether to stop BDD
   analysis to pass to BMC.]

   Description        [True means continue with BDD false means swap to BMC]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr complete\_bmc\_trace\_with\_bdd(Trace\_ptr* trace, NodeList\_ptr symbols, BddEnc\_ptr bdd\_enc, BddFsm\_ptr bdd\_fsm, node\_ptr f\_list, node\_ptr b\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Completes a partial BMC tace in BDD-BMC analysis]

   Description        [The free of the returned trace is demanded to the caller]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{mcLE.c}
		
	\texttt{void Mc\_CheckLanguageEmptiness(const BddFsm\_ptr fsm, boolean allinit, boolean verbose)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks whether the language is empty]

  Description        [Checks whether the language is empty. Basically just a
  wrapper function that calls the language emptiness algorithm given
  by the value of the oreg_justice_emptiness_bdd_algorithm option.

  If <tt>allinit</tt> is <tt>true</tt> the check is performed by
  verifying whether all initial states are included in the set of fair
  states. If it is the case from all initial states there exists a
  fair path and thus the language is not empty. On the other hand, if
  <tt>allinit</tt> is false, the check is performed by verifying
  whether there exists at least one initial state that is also a fair
  state. In this case there is an initial state from which it starts a
  fair path and thus the lnaguage is not empty. <tt>allinit</tt> is
  not supported for forward Emerson-Lei.

  Depending on the global option use_reachable_states the set of fair
  states computed can be restricted to reachable states only. In this
  latter case the check can be further simplified. Forward Emerson-Lei
  requires forward_search and use_reachable_states to be enabled.
  
  If <tt>verbose</tt> is true, then some information on the set of
  initial states is printed out too. <tt> verbose</tt> is ignored for
  forward Emerson-Lei.  ]

  SideEffects        [None]

  SeeAlso            [mc_check_language_emptiness_el_bwd,
  mc_check_language_emptiness_el_fwd]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void mc\_check\_language\_emptiness\_el\_bwd(const BddFsm\_ptr fsm, boolean allinit, boolean verbose)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks whether the language is empty using the backward
  Emerson-Lei algorithm]

  Description        [See Mc_CheckLanguageEmptiness.]

  SideEffects        []

  SeeAlso            [BddFsm_get_fair_states]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void mc\_check\_language\_emptiness\_el\_fwd(const BddFsm\_ptr fsm, boolean allinit, boolean verbose)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks whether the language is empty using the forward
  Emerson-Lei algorithm]

  Description        [See Mc_CheckLanguageEmptiness.]

  SideEffects        []

  SeeAlso            [BddFsm_get_revfair_states]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{mcMc.c}
		
	\texttt{void Mc\_CheckCTLSpec(Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Verifies that M,s0 |= alpha ]

  Description [Verifies that M,s0 |= alpha using the fair CTL model checking.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Mc\_CheckCompute(Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Compute quantitative characteristics on the model.]

  Description [Compute the given quantitative characteristics on the model.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates ex(BddFsm\_ptr fsm, BddStates g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>EX(g)</i>.]

  Description        [Computes the set of states satisfying <i>EX(g)</i>.]

  SideEffects        []

  SeeAlso            [eu ef eg]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates eu(BddFsm\_ptr fsm, BddStates f, BddStates g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>E\[ f U g \]</i>.]

  Description        [Computes the set of states satisfying <i>E\[ f U g \]</i>.]

  SideEffects        []

  SeeAlso            [ebu]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates eg(BddFsm\_ptr fsm, BddStates g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>EF(g)</i>.]

  Description        [Computes the set of states satisfying <i>EG(g)</i>.]

  SideEffects        []

  SeeAlso            [eu ex]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates ef(BddFsm\_ptr fsm, BddStates g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>EF(g)</i>.]

  Description        [Computes the set of states satisfying <i>EF(g)</i>.]

  SideEffects        []

  SeeAlso            [eu ex]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates au(BddFsm\_ptr fsm, BddStates f, BddStates g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>A\[f U g\]</i>.]

  Description        [Computes the set of states satisfying <i>A\[f U g\]</i>.]

  SideEffects        []

  SeeAlso            [ax af ex ef]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs ex\_si(BddFsm\_ptr fsm, BddStatesInputs si)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>EG(g)</i>.]

  Description        [Computes the set of states satisfying <i>EG(g)</i>.]

  SideEffects        []

  SeeAlso            [eu ex ef]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStatesInputs eu\_si(BddFsm\_ptr fsm, bdd\_ptr f, bdd\_ptr g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Computes the set of state-input pairs that satisfy
  E(f U g), with f and g sets of state-input pairs.]

  Description  []

  SeeAlso      []

  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr eg\_si(BddFsm\_ptr fsm, bdd\_ptr g\_si)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states-inputs satisfying <i>EG(g)</i>.]

  Description        []

  SideEffects        []

  SeeAlso            [eu ex]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates ebu(BddFsm\_ptr fsm, BddStates f, BddStates g, int inf, int sup)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>E\[f U^{inf..sup} g\]</i>.]

  Description        [Computes the set of states satisfying
                      <i>E\[f U^{inf..sup} g\]</i></i>.]

  SideEffects        []

  SeeAlso            [eu]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates ebf(BddFsm\_ptr fsm, BddStates g, int inf, int sup)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>EF^{inf..sup}(g)</i>.]

  Description        [Computes the set of states satisfying
                     <i>EF^{inf..sup}(g)</i>.]

  SideEffects        []

  SeeAlso            [ef]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates ebg(BddFsm\_ptr fsm, BddStates g, int inf, int sup)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>EG^{inf..sup}(g)</i>.]

  Description        [Computes the set of states satisfying
                      <i>EG^{inf..sup}(g)</i>.]

  SideEffects        []

  SeeAlso            [eg]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddStates abu(BddFsm\_ptr fsm, BddStates f, BddStates g, int inf, int sup)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set of states satisfying <i>A\[f U^{inf..sup} g\]</i>.]

  Description        [Computes the set of states satisfying
                     <i>A\[f U^{inf..sup} g\]</i>.]

  SideEffects        []

  SeeAlso            [au]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int minu(BddFsm\_ptr fsm, bdd\_ptr arg\_f, bdd\_ptr arg\_g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the minimum length of the shortest path
  from <i>f</i> to <i>g</i>.]

  Description        [This function computes the minimum length of the
  shortest path from <i>f</i> to <i>g</i>.<br>
  Starts from <i>f</i> and proceeds forward until finds a state in <i>g</i>.
  Notice that this function works correctly only if <code>-f</code>
  option is used.]

  SideEffects        []

  SeeAlso            [maxu]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int maxu(BddFsm\_ptr fsm, bdd\_ptr f, bdd\_ptr g)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This function computes the maximum length of the
  shortest path from <i>f</i> to <i>g</i>.]

  Description        [This function computes the maximum length of the
  shortest path from <i>f</i> to <i>g</i>. It starts from !g and
  proceeds backward until no states in <i>f</i> can be found. In other
  words, it looks for the maximum length of <i>f->AG!g</i>.
  Notice that this function works correctly only if <code>-f</code>
  option is used.

  Returns -1 if infinity, -2 if undefined]

  SideEffects        []

  SeeAlso            [minu]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void print\_spec(FILE *file, Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints out a CTL specification]

  Description        [Prints out a CTL specification]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void print\_compute(FILE *file, Prop\_ptr p)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints out a COMPUTE specification]

  Description        [Prints out a COMPUTE specification]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr Mc\_fair\_si\_iteration(BddFsm\_ptr fsm, BddStatesInputs states, BddStatesInputs subspace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [ ]

  Description [Perform one iteration over the list of fairness
  conditions (order is statically determined). Compute states that are
  backward reachable from each of the fairness conditions.

  MAP( ApplicableStatesInputs ) over Fairness constraints

  (Q /\ ex_si ( Z /\ AND_i eu_si(Z, (Z/\ StatesInputFC_i))))

  ]

  SeeAlso      []

  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static BddStatesInputs Mc\_get\_fair\_si\_subset(BddFsm\_ptr fsm, BddStatesInputs si)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     []

  Description [Returns the set of state-input pairs in si that are
  fair, i.e. beginning of a fair path.]

  SeeAlso      []

  SideEffects  []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{mcTrace.c}
		
	\texttt{Trace\_ptr Mc\_create\_trace\_from\_bdd\_state\_input\_list(const BddEnc\_ptr bdd\_enc, const NodeList\_ptr symbols, const char* desc, const TraceType type, node\_ptr path)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Creates a trace out of a < S (i, S)* >  bdd list]

  Description  [Creates a trace out of a < S (i, S)* >  bdd list.
                The built trace is non-volatile. For more control over
                the built trace, please see
                Mc_fill_trace_from_bdd_state_input_list ]

  SideEffects  [none]

  SeeAlso      [Trace_create, Bmc_create_trace_from_cnf_model,
                Mc_fill_trace_from_bdd_state_input_list]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Mc\_fill\_trace\_from\_bdd\_state\_input\_list(const BddEnc\_ptr bdd\_enc, Trace\_ptr trace, node\_ptr path)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Fills the given trace out of a < S (i, S)* >  bdd list]

  Description [Fills the given trace out of a < S (i, S)* > bdd list.
                The returned trace is the given one, filled with all
                steps. The given trace MUST be empty. Path must be non-Nil]

  SideEffects  [none]

  SeeAlso      [Trace_create, Bmc_fill_trace_from_cnf_model]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Mc\_trace\_step\_put\_state\_from\_bdd(Trace\_ptr trace, TraceIter step, BddEnc\_ptr bdd\_enc, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Populates a trace step with state assignments]

  Description  []

  SideEffects  [none]

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Mc\_trace\_step\_put\_input\_from\_bdd(Trace\_ptr trace, TraceIter step, BddEnc\_ptr bdd\_enc, bdd\_ptr bdd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Populates a trace step with input assignments]

  Description  []

  SideEffects  [none]

  SeeAlso      []

******************************************************************************/

	\end{verbatimtab}
	
	\section{node}
		
	\section{normalizers}
		
	\subsection{MasterNormalizer.c}
		
	\texttt{MasterNormalizer\_ptr MasterNormalizer\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterNormalizer class constructor]

  Description        [The MasterNormalizer class constructor]

  SideEffects        []

  SeeAlso            [MasterNormalizer_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr MasterNormalizer\_normalize\_node(MasterNormalizer\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Traverses the tree, and returns a possibly new tree that
  is a normalized copy of the first. Use for constant-time comparison
  of two trees]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr MasterNormalizer\_lookup\_cache(MasterNormalizer\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Looks in the internal memoization cache for a
                      match. Returns Nil if no memoized data has been found]

  Description        [Looks in the internal memoization cache for a
                      match. Returns Nil if no memoized data has been found]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void MasterNormalizer\_insert\_cache(MasterNormalizer\_ptr self, node\_ptr n, node\_ptr norm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inserts new data in the internal memoization cache.]

  Description        [Inserts new data in the internal memoization cache.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr master\_normalizer\_normalize\_node(MasterNormalizer\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal version of the method normalize_node, callable
  internally and by normalizers]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void master\_normalizer\_init(MasterNormalizer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterNormalizer class private initializer]

  Description        [The MasterNormalizer class private initializer]

  SideEffects        []

  SeeAlso            [MasterNormalizer_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void master\_normalizer\_deinit(MasterNormalizer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterNormalizer class private deinitializer]

  Description        [The MasterNormalizer class private deinitializer]

  SideEffects        []
  SeeAlso            [MasterNormalizer_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void master\_normalizer\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The NormalizerBase class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{NormalizerBase.c}
		
	\texttt{NormalizerBase\_ptr NormalizerBase\_create(const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates and initializes a normalizer.
  To be usable, the normalizer will have to be registered to a MasterNormalizer.]

  Description        [To each normalizer is associated a partition of
  consecutive indices over the symbols set. The lowest index of the
  partition is given through the parameter low, while num is the
  partition size. Name is used to easily identify normalizer instances.

  This constructor is private, as this class is virtual]

  SideEffects        []

  SeeAlso            [NormalizerBase_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL node\_ptr NormalizerBase\_normalize\_node(NormalizerBase\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the given node]

  Description [This is virtual method. BEfore calling, please ensure
  the given node can be handled by self, by calling
  NormalizerBase_can_handle.

  Note: This method will be never called by the user]

  SideEffects        []

  SeeAlso            [NormalizerBase_can_handle]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void normalizer\_base\_init(NormalizerBase\_ptr self, const char* name, int low, size\_t num, boolean can\_handle\_null)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NormalizerBase class private initializer]

  Description        [The NormalizerBase class private initializer]

  SideEffects        []

  SeeAlso            [NormalizerBase_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void normalizer\_base\_deinit(NormalizerBase\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NormalizerBase class private deinitializer]

  Description        [The NormalizerBase class private deinitializer]

  SideEffects        []

  SeeAlso            [NormalizerBase_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr normalizer\_base\_throw\_normalize\_node(NormalizerBase\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This method must be called by the virtual method
  print_node to recursively print sub nodes]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void normalizer\_base\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The NormalizerBase class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr normalizer\_base\_normalize\_node(NormalizerBase\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Virtual menthod that prints the given node]

  Description [This is a pure virtual method, to be implemented by derived
  class, and cannot be called]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{NormalizerCore.c}
		
	\texttt{NormalizerCore\_ptr NormalizerCore\_create(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The NormalizerCore class constructor]

   Description        [The NormalizerCore class constructor]

   SideEffects        []

   SeeAlso            [NormalizerCore_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void normalizer\_core\_init(NormalizerCore\_ptr self, const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The NormalizerCore class private initializer]

   Description        [The NormalizerCore class private initializer]

   SideEffects        []

   SeeAlso            [NormalizerCore_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void normalizer\_core\_deinit(NormalizerCore\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The NormalizerCore class private deinitializer]

   Description        [The NormalizerCore class private deinitializer]

   SideEffects        []

   SeeAlso            [NormalizerCore_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr normalizer\_core\_normalize\_node(NormalizerBase\_ptr self, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Virtual menthod that normalizes the given node
   (core nodes are handled here)]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void normalizer\_core\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis[The NormalizerCore class virtual finalizer]

   Description [Called by the class destructor]

   SideEffects []

   SeeAlso []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{NormalizerPsl.c}
		
	\texttt{NormalizerPsl\_ptr NormalizerPsl\_create(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The NormalizerPsl class constructor]

   Description        [The NormalizerPsl class constructor]

   SideEffects        []

   SeeAlso            [NormalizerPsl_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void normalizer\_psl\_init(NormalizerPsl\_ptr self, const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The NormalizerPsl class private initializer]

   Description        [The NormalizerPsl class private initializer]

   SideEffects        []

   SeeAlso            [NormalizerPsl_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void normalizer\_psl\_deinit(NormalizerPsl\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The NormalizerPsl class private deinitializer]

   Description        [The NormalizerPsl class private deinitializer]

   SideEffects        []

   SeeAlso            [NormalizerPsl_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr normalizer\_psl\_normalize\_node(NormalizerBase\_ptr self, node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Virtual menthod that normalizes the given node
   (core nodes are handled here)]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void normalizer\_psl\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis[The NormalizerPsl class virtual finalizer]

   Description [Called by the class destructor]

   SideEffects []

   SeeAlso []

******************************************************************************/

	\end{verbatimtab}
	
	\section{printers}
		
	\subsection{MasterPrinter.c}
		
	\texttt{MasterPrinter\_ptr MasterPrinter\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterPrinter class constructor]

  Description        [The MasterPrinter class constructor]

  SideEffects        []

  SeeAlso            [MasterPrinter_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int MasterPrinter\_print\_node(MasterPrinter\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the given node on the stream currently set]

  Description        [If the stream is a string stream, the result can be
  obtained be calling MasterPrinter_get_streamed_string. Returns
  0 if an error occurred for some reason.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int MasterPrinter\_print\_string(MasterPrinter\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the given string on the stream currently set]

  Description        [If the stream is a string stream, the result can be
  obtained be calling MasterPrinter_get_streamed_string. Returns
  0 if an error occurred for some reason.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* MasterPrinter\_get\_streamed\_string(const MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the string that has been streamed]

  Description        [Returned string belongs to self, DO NOT free it.

  Warning: this method can be called only when the current
  stream type is STREAM_TYPE_STRING.]

  SideEffects        []

  SeeAlso            [master_printer_reset_string_stream]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void MasterPrinter\_set\_stream\_type(MasterPrinter\_ptr self, StreamType type, StreamTypeArg arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Sets the stream type to be used to produce a printing
  result]

  Description [When the given type requires an argument (for example,
  STREAM_TYPE_FILE requires a file), the argument must be passed by
  using the 'arg' parameter. When not required (for example
  STREAM_TYPE_STRING), the caller can pass STREAM_TYPE_ARG_UNUSED
  as argument.

  When STREAM_TYPE_FILE is used, the argument must be the handler of an open
  writable file.
  ]


  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{StreamType MasterPrinter\_get\_stream\_type(const MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the currently set stream type]

  Description        [Returns the currently set stream type]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void MasterPrinter\_reset\_stream(MasterPrinter\_ptr self, int initial\_offset)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reset the stream]

  Description [Set the indentation offset for this stream. Negative
  offsets are silently discarded.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void MasterPrinter\_close\_stream(MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Closes the current stream, if possible or applicable]

  Description [The currently set stream is closed (file) or reset
  (string) and the stream type is set to be STREAM_TYPE_DEFAULT.
  IMPORTANT: If the current stream is nusmv_std{out,err} the stream is
  not closed.

  This function is provided to allow the called to forget the set
  stream after setting it into the master printer.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int MasterPrinter\_flush\_stream(MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Flushes the current stream, if possible or applicable]

  Description [The currently set stream is flushed out (i.e. no
  unstreamed data remains afterwards.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int master\_printer\_print\_node(MasterPrinter\_ptr self, node\_ptr n, int priority)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal version of the method print_node, callable
  internally and by printers]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void master\_printer\_init(MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterPrinter class private initializer]

  Description        [The MasterPrinter class private initializer]

  SideEffects        []

  SeeAlso            [MasterPrinter_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void master\_printer\_deinit(MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterPrinter class private deinitializer]

  Description        [The MasterPrinter class private deinitializer]

  SideEffects        []
  SeeAlso            [MasterPrinter_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void master\_printer\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The PrinterBase class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int master\_printer\_sprint(MasterPrinter\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Appends a string to the internal string stream]

  Description        [Warning: current stream type must be STREAM_TYPE_STRING]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int master\_printer\_fprint(MasterPrinter\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Stream the given string to the internally set file
  stream]

  Description        [Warning: current stream type must be compatible]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int master\_printer\_indent(MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pushes the current level of indentation]

  Description        []

  SideEffects        [The internal status of the master printer is changed]

  SeeAlso            [master_printer_deindent]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int master\_printer\_deindent(MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Restore previous level of indentation]

  Description [Restore previous level of indentation. Raises an
  internal error if an inconsisten internal state is detected.]

  SideEffects        [The internal status of the master printer is changed]

  SeeAlso            [master_printer_indent]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int master\_printer\_get\_level(MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get current level of indentation]

  Description [Returns an integer representing the current level of
  indentation (i.e. the number of whitespaces to pad the string
  with). If the internal stack is empty, assume indentation level is 0
  for backward compatibility.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void master\_printer\_reset\_string\_stream(MasterPrinter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Cleans up the stream that have been read so far.
  Any previoulsy read stream will be lost]

  Description        []

  SideEffects        []

  SeeAlso            [get_streamed_string]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PrinterBase.c}
		
	\texttt{PrinterBase\_ptr PrinterBase\_create(const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates and initializes a printer.
  To be usable, the printer will have to be registered to a MasterPrinter.]

  Description        [To each printer is associated a partition of
  consecutive indices over the symbols set. The lowest index of the
  partition is given through the parameter low, while num is the
  partition size. Name is used to easily identify printer instances. 

  This constructor is private, as this class is virtual]

  SideEffects        []

  SeeAlso            [PrinterBase_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL int PrinterBase\_print\_node(PrinterBase\_ptr self, node\_ptr n, int priority)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the given node]

  Description [This is virtual method. BEfore calling, please ensure
  the given node can be handled by self, by calling
  PrinterBase_can_handle. 

  Note: This method will be never called by the user]

  SideEffects        []

  SeeAlso            [PrinterBase_can_handle]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_base\_init(PrinterBase\_ptr self, const char* name, int low, size\_t num, boolean can\_handle\_null)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterBase class private initializer]

  Description        [The PrinterBase class private initializer]

  SideEffects        []

  SeeAlso            [PrinterBase_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_base\_deinit(PrinterBase\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterBase class private deinitializer]

  Description        [The PrinterBase class private deinitializer]

  SideEffects        []

  SeeAlso            [PrinterBase_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int printer\_base\_throw\_print\_node(PrinterBase\_ptr self, node\_ptr n, int prior)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This method must be called by the virtual method 
  print_node to recursively print sub nodes]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int printer\_base\_print\_string(PrinterBase\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Use this method to print a string to the stream currently
  set]

  Description        []

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void printer\_base\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The PrinterBase class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int printer\_base\_print\_node(PrinterBase\_ptr self, node\_ptr n, int priority)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Virtual menthod that prints the given node]

  Description [This is a pure virtual method, to be implemented by derived 
  class, and cannot be called]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PrinterIWffCore.c}
		
	\texttt{PrinterIWffCore\_ptr PrinterIWffCore\_create(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterIWffCore class constructor]

  Description        [The PrinterIWffCore class constructor]

  SideEffects        []

  SeeAlso            [PrinterIWffCore_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_iwff\_core\_init(PrinterIWffCore\_ptr self, const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterIWffCore class private initializer]

  Description        [The PrinterIWffCore class private initializer]

  SideEffects        []

  SeeAlso            [PrinterIWffCore_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_iwff\_core\_deinit(PrinterIWffCore\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterIWffCore class private deinitializer]

  Description        [The PrinterIWffCore class private deinitializer]

  SideEffects        []

  SeeAlso            [PrinterIWffCore_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int printer\_iwff\_core\_print\_node(PrinterBase\_ptr self, node\_ptr n, int priority)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Virtual menthod that prints the given node 
  (only indentantion capable nodes are handled here)]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void printer\_iwff\_core\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The PrinterWffCore class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int printer\_iwff\_core\_print\_case(PrinterIWffCore\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int printer\_iwff\_core\_print\_case\_body(PrinterIWffCore\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PrinterPsl.c}
		
	\texttt{PrinterPsl\_ptr PrinterPsl\_create(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterPsl class constructor]

  Description        [The PrinterPsl class constructor]

  SideEffects        []

  SeeAlso            [PrinterPsl_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_psl\_init(PrinterPsl\_ptr self, const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterPsl class private initializer]

  Description        [The PrinterPsl class private initializer]

  SideEffects        []

  SeeAlso            [PrinterPsl_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_psl\_deinit(PrinterPsl\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterPsl class private deinitializer]

  Description        [The PrinterPsl class private deinitializer]

  SideEffects        []

  SeeAlso            [PrinterPsl_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int printer\_psl\_print\_node(PrinterBase\_ptr self, node\_ptr n, int priority)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Virtual menthod that prints the given node
  (core nodes are handled here)]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void printer\_psl\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The PrinterPsl class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PrinterSexpCore.c}
		
	\texttt{PrinterSexpCore\_ptr PrinterSexpCore\_create(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The PrinterSexpCore class constructor]

   Description        [The PrinterSexpCore class constructor]

   SideEffects        []

   SeeAlso            [PrinterSexpCore_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_sexp\_core\_init(PrinterSexpCore\_ptr self, const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The PrinterSexpCore class private initializer]

   Description        [The PrinterSexpCore class private initializer]

   SideEffects        []

   SeeAlso            [PrinterSexpCore_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_sexp\_core\_deinit(PrinterSexpCore\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The PrinterSexpCore class private deinitializer]

   Description        [The PrinterSexpCore class private deinitializer]

   SideEffects        []

   SeeAlso            [PrinterSexpCore_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int printer\_sexp\_core\_print\_node(PrinterBase\_ptr self, node\_ptr node, int priority)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Virtual menthod that prints the given node 
   (core nodes are handled here)]

   Description []

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void printer\_sexp\_core\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis[The PrinterSexpCore class virtual finalizer]

   Description [Called by the class destructor]

   SideEffects []

   SeeAlso []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PrinterWffCore.c}
		
	\texttt{PrinterWffCore\_ptr PrinterWffCore\_create(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterWffCore class constructor]

  Description        [The PrinterWffCore class constructor]

  SideEffects        []

  SeeAlso            [PrinterWffCore_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_wff\_core\_init(PrinterWffCore\_ptr self, const char* name, int low, size\_t num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterWffCore class private initializer]

  Description        [The PrinterWffCore class private initializer]

  SideEffects        []

  SeeAlso            [PrinterWffCore_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void printer\_wff\_core\_deinit(PrinterWffCore\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PrinterWffCore class private deinitializer]

  Description        [The PrinterWffCore class private deinitializer]

  SideEffects        []

  SeeAlso            [PrinterWffCore_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int printer\_wff\_core\_print\_node(PrinterBase\_ptr self, node\_ptr n, int priority)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Virtual menthod that prints the given node 
  (core nodes are handled here)]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void printer\_wff\_core\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The PrinterWffCore class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int printer\_wff\_core\_print\_case(PrinterWffCore\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int printer\_wff\_core\_print\_case\_body(PrinterWffCore\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{MasterNodeWalker.c}
		
	\texttt{MasterNodeWalker\_ptr MasterNodeWalker\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterNodeWalker class constructor]

  Description        [The MasterNodeWalker class constructor]

  SideEffects        []

  SeeAlso            [MasterNodeWalker_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void MasterNodeWalker\_destroy(MasterNodeWalker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterNodeWalker class destructor]

  Description        [The MasterNodeWalker class destructor]

  SideEffects        []

  SeeAlso            [MasterNodeWalker_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean MasterNodeWalker\_register\_walker(MasterNodeWalker\_ptr self, NodeWalker\_ptr walker)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Registers a walker.]

  Description [Return true if successfully registered, false if
  already registered, and throws an exception if could not register, due
  to the walker's partition that collides with already registered walkers.

  Warning: If this method succeeds, the walker instance belongs to
  self, and its life cycle will be controlled by self as long as the
  walker is registered within self. The user must not destroy a
  registered walker. ]

  SideEffects        []

  SeeAlso            [unregister_walker]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeWalker\_ptr MasterNodeWalker\_unregister\_walker(MasterNodeWalker\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Unregisters a previously registered walker]

  Description [If the walker was registered returns the walker instance.
  If not registered (not found among the currently registered walkers),
  returns NULL but no error occurs. After this method is called,
  ]

  SideEffects        []

  SeeAlso            [register_walker]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeWalker\_ptr MasterNodeWalker\_get\_walker(MasterNodeWalker\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the regostered walker whose name is given]

  Description [If the walker is not found among the registered walkers,
  NULL is returned and no error occurs]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void master\_node\_walker\_init(MasterNodeWalker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterNodeWalker class private initializer]

  Description        [The MasterNodeWalker class private initializer]

  SideEffects        []

  SeeAlso            [MasterNodeWalker_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void master\_node\_walker\_deinit(MasterNodeWalker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The MasterNodeWalker class private deinitializer]

  Description        [The MasterNodeWalker class private deinitializer]

  SideEffects        []

  SeeAlso            [MasterNodeWalker_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void master\_node\_walker\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The MasterNodeWalker class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{NodeWalker.c}
		
	\texttt{NodeWalker\_ptr NodeWalker\_create(const char* name, int low, size\_t num, boolean can\_handle\_null)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates and initializes a walker.
  To be usable, the walker will have to be registered to a MasterNodeWalker]

  Description        [To each walker is associated a partition of
  consecutive indices over the symbols set. The lowest index of the
  partition is given through the parameter low, while num is the
  partition size. Name is used to easily identify walker instances. 

  Constructor is private, as this class is a virtual base class.

  can_handle_null must be set to true if the walker can handle the
  null case.  The null case is trasversal to the partitions set, so
  only the first registered walker that can handle null case will be
  called to handle the null node.]

  SideEffects        []

  SeeAlso            [NodeWalker_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeWalker\_destroy(NodeWalker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NodeWalker class destructor]

  Description [The NodeWalker class destructor. If registerd to a
  master, it unregisters itself before finalizing.]

  SideEffects        []

  SeeAlso            [NodeWalker_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean NodeWalker\_can\_handle(const NodeWalker\_ptr self, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if the given node belongs to the partition 
  associated to this walker]

  Description [Returns true if the given node belongs to the partition 
  associated to this walker. If n is Nil then the specific walker will be 
  asked]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* NodeWalker\_get\_name(const NodeWalker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the walker name as a string]

  Description        [The returned string belongs to self, do not deallocate 
  or change it.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean NodeWalker\_collides(const NodeWalker\_ptr self, const NodeWalker\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

 Synopsis [Checks if self collides with other in terms of their
 respective symbol sets]

  Description        [Returns true if self and other's symbols set collide
  (i.e. are not partitions). Returns false if they are ok.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void node\_walker\_init(NodeWalker\_ptr self, const char* name, int low, size\_t num, boolean can\_handle\_null)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NodeWalker class private initializer]

  Description        [The NodeWalker class private initializer]

  SideEffects        []

  SeeAlso            [NodeWalker_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void node\_walker\_deinit(NodeWalker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NodeWalker class private deinitializer]

  Description        [The NodeWalker class private deinitializer]

  SideEffects        []

  SeeAlso            [NodeWalker_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void node\_walker\_set\_master(NodeWalker\_ptr self, MasterNodeWalker\_ptr master)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [This method is privately called by master while registering the 
  walker]

  Description        [If already assigned to a master, it unregisters itself 
  from the old master before setting the new master]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean node\_walker\_can\_handle\_null\_node(const NodeWalker\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the walker can handle the null case]

  Description        [The null case is trasversal to the partitions set, so
  only the first registered walker that can handle null case will be
  called to handle the null node.]

  SideEffects        []

  SeeAlso            []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void node\_walker\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The NodeWalker class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{node.c}
		
	\texttt{}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Quits the <tt>node</tt> manager.]

  Description        [Quits the <tt>node</tt> manager. All the
  memory allocated it's freed.]

  SideEffects        [All the memory allocated by the <tt>node</tt>
  manager are left to the operating system.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void node\_show\_profile\_stats(FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a summary of <tt>node</tt> resources usage]

  Description        [For debug and profiling purposes only]

  SideEffects        [none]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void free\_node(node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Free a node of the <tt>node<tt> manager.]

  Description        [Free a node of the <tt>node<tt> manager. The
  node is available for next node allocation.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr new\_node(int type, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new node.]

  Description        [A new <tt>node</tt> of type <tt>type</tt> and
  left and right branch <tt>left<tt> and <tt>right</tt> respectively
  is created. The returned node is not stored in the <tt>node</tt> hash.]

  SideEffects        [None]

  SeeAlso            [find_node]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr new\_lined\_node(int type, node\_ptr left, node\_ptr right, int lineno)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new node.]

  Description        [The same as new_node except the line number
  is explicitly proved. A new <tt>node</tt> of type <tt>type</tt>, with
  left and right branch <tt>left<tt> and <tt>right</tt> respectively
  and on the line number <tt>lineno</tt> is created.
  The returned node is not stored in the <tt>node</tt> hash.]

  SideEffects        [None]

  SeeAlso            [new_node, find_node]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr find\_node(int type, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new node.]

  Description        [A new <tt>node</tt> of type <tt>type</tt> and
  left and right branch <tt>left<tt> and <tt>right</tt> respectively
  is created. The returned node is stored in the <tt>node</tt> hash.]

  SideEffects        [The <tt>node</tt> hash is modified.]

  SeeAlso            [new_node]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr find\_atom(node\_ptr a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Search the <tt>node</tt> hash for a given node.]

  Description        [Search the <tt>node</tt> hash for a given
  node. If the node is not <tt>Nil</tt>, and the node is not stored in
  the hash, the new node is created, stored in the hash and then returned.]

  SideEffects        [The node <tt>hash</tt> may change.]

  SeeAlso            [find_node]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr cons(node\_ptr x, node\_ptr y)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Conses two nodes.]

  Description        [Conses two nodes.]

  SideEffects        [None]

  SeeAlso            [car cdr]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr car(node\_ptr x)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the left branch of a node.]

  Description        [Returns the left branch of a node.]

  SideEffects        [None]

  SeeAlso            [cdr cons]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr cdr(node\_ptr x)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the right branch of a node.]

  Description        [Returns the right branch of a node.]

  SideEffects        [None]

  SeeAlso            [car cons]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void setcar(node\_ptr x, node\_ptr y)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the car of X with Y]

  Description        [Replaces the car of X with Y]

  SideEffects        [The car of X is replaced by Y.]

  SeeAlso            [car cdr cons setcdr]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void setcdr(node\_ptr x, node\_ptr y)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the cdr of X with Y]

  Description        [Replaces the cdr of X with Y]

  SideEffects        [The cdr of X is replaced by Y.]

  SeeAlso            [car cdr cons setcar]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void node\_set\_type (node\_ptr x, int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Replaces the type of the node]

  Description        [Replaces the type of the node]

  SideEffects        [Replaces the type of the node]

  SeeAlso            [car cdr cons setcar node_get_type]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int node\_is\_failure(node\_ptr x)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns 0 if given node is not a FAILURE node]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int node\_is\_leaf(node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Tells if the given node is a numeric/boolean leaf]

   Description [Returns 0 if the given node is not a numeric/boolean/failure
   constant.  This is done a purely syntactic manner. To know if a
   *symbol* is constant declared within a symbol tablea, use method
   SymbTable_is_symbol_constant instead.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr new\_list()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new empty list]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr copy\_list(node\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a copy of a list]

  Description        [An invoker should free the returned list.]

  SideEffects        [free_list]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void free\_list(node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees all the elements of the list.]

  Description        [Frees all the elements of the list for further use.]

  SideEffects        [None]

  SeeAlso            [car]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int is\_list\_empty(node\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns 1 is the list is empty, 0 otherwise]

  Description        []

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int in\_list(node\_ptr n, node\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks list R to see if it contains the element N.]

  Description        [Checks list R to see if it contains the element N.]

  SideEffects        [None]

  SeeAlso            [node_subtract]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int llength(node\_ptr r)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the length of list r.]

  Description        [Returns the length of list r.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr append(node\_ptr x, node\_ptr y)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Appends two lists and returns the result.]

  Description        [Constructs a new list by concatenating its arguments.]

  SideEffects        [The modified list is returned. Side effects on
  the returned list were performed. It is equivalent to the lisp NCONC]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr append\_ns(node\_ptr x, node\_ptr y)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Appends two lists and returns the result.]

  Description        [Constructs a new list by concatenating its arguments.]

  SideEffects        [The modified list is returned. No side effects on
  the returned list were performed.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr reverse(node\_ptr x)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reverse a list.]

  Description        [Returns a new sequence containing the same
  elements as X but in reverse order.]

  SideEffects        [The orignial list is modified]

  SeeAlso            [last car cons append]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr reverse\_ns(node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [reverses the list with no side-effect]

  Description        [Returns a reversed version of the given list.
  The original list is NOT modified]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr last(node\_ptr x)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the last cons in X.]

  Description        [Returns the last cons in X.]

  SideEffects        [None]

  SeeAlso            [car]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr map(NPFN fun, node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies FUN to successive cars of LISTs and
  returns the results as a list.]

  Description        [Applies FUN to successive cars of LISTs and
  returns the results as a list.]

  SideEffects        [None]

  SeeAlso            [map2 walk]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr map2(NPFNN fun, node\_ptr l1, node\_ptr l2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies FUN to successive cars of LISTs and
  returns the results as a list. Lists l1 and l2 are traversed in parallel.]

  Description        [Applies FUN to successive cars of LISTs and
  returns the results as a list. l1 and l2 must have the same length]

  SideEffects        [None]

  SeeAlso            [map walk]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr odd\_elements(node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Extracts odd elements of list L.]

  Description        [Extracts odd elements of list L.]

  SideEffects        [None]

  SeeAlso            [even_elements]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr even\_elements(node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Extracts even elements of list L.]

  Description        [Extracts even elements of list L.]

  SideEffects        [None]

  SeeAlso            [odd_elements]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void walk(VPFN fun, node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies FUN to successive cars of LISTs.]

  Description        [Applies FUN to successive cars of LISTs.]

  SideEffects        [None]

  SeeAlso            [map]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_subtract(node\_ptr set1, node\_ptr set2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deletes from list set2 the elements of list set1.]

  Description        [Deletes elements of list set1 from list set2
  without doing side effect. The resulting list is returned.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void swap\_nodes(node\_ptr *n1, node\_ptr *n2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Swaps two nodes.]

  Description        [Swaps two nodes.]

  SideEffects        [The two nodes are swapped.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{/* [MR2??]: elements out of the node package introducing circular dependencies. */ node\_ptr node\_normalize(node\_ptr sexp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Traverses the tree, and returns a possibly new tree that
  is a normalized copy of the first. Use for constant-time comparison
  of two trees]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr node\_normalize\_list(node\_ptr sexp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Does the same thing as node_normalize but
  do it more efficiently if sexp is a list]

  Description [node_normalize is 100% recursive.
  This function instead expects the input to be a list (right
  directional and of AND or CONS) which will be processed in a loop
  instead of recursively.  For some examples this allowed to avoid
  stack overflow.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void node\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the <tt>node</tt> manager.]

  Description        [The <tt>node</tt> manager is initialized.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void node\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [De-initializes the <tt>node</tt> manager.]

  Description        [The <tt>node</tt> manager is de-initialized.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr insert\_node(node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inserts a node in the <tt>node</tt> hash.]

  Description        [Checks if node is in the cache, if it is the
  case then the hashed value is returned, else a new one is created,
  stored in the hash and returned.]

  SideEffects        [None]

  SeeAlso            [find_node]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline unsigned int node\_hash\_fun(node\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Hash function for <tt>node</tt>s.]

  SideEffects        [None]

  SeeAlso            [node_eq_fun]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static unsigned node\_eq\_fun(node\_ptr node1, node\_ptr node2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Equality function for <tt>node</tt> hash.]

  SideEffects        [None]

  SeeAlso            [node_hash_fun]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int node\_cmp\_fun(node\_ptr node1, node\_ptr node2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Comparison function for <tt>node</tt> sorted insertion.
  Returns is < 0 if node1 < node2, 0 if node1 == node2, and > 0 if
  node1 > node2]

  SideEffects        [None]

  SeeAlso            [node_hash_fun]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr node\_alloc()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Allocates NODE_MEM_CHUNK records and stores them
  in the free list of the <tt>node</tt> manager.]

  Description        [Allocates NODE_MEM_CHUNK records and stores them
  in the free list of the <tt>node</tt> manager.]

  SideEffects        [The free list of the <tt>node</tt> manager is
  updated by appending the new allocated nodes.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void \_node\_realloc\_nodelist()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reallocation of the hash]

  Description [If possible (i.e. upper limit not reached yet)
  reallcoates the hash table of nodes. There are two strategies:
  the first try allocating a new bunch of memory, the second (if
  the former fails due to low memory) tries to enarge the existing
  hash. The hash is reallocated when a given load threashold is
  reached, when inserting nodes in the hash.]

  SideEffects        [None]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int profile\_info\_cmp(const void *a, const void *b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Comparison function used for profiling]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{nodePkg.c}
		
	\texttt{void node\_pkg\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the node package]

  Description        [Creates master and printers, and initializes the node 
  structures]

  SideEffects        []

  SeeAlso            [node_pkg_quit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void node\_pkg\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Deinitializes the packages, finalizing all internal
  structures]

  Description        []

  SideEffects        []

  SeeAlso            [node_pkg_init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{MasterNormalizer\_ptr node\_pkg\_get\_global\_master\_normalizer()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the global master normalizer]

  Description        [Returns the global master normalizer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{MasterPrinter\_ptr node\_pkg\_get\_global\_master\_wff\_printer()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the global master wff printer]

  Description        [Returns the global master wff printer.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{MasterPrinter\_ptr node\_pkg\_get\_global\_master\_sexp\_printer()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the global master wff printer]

  Description        [Returns the global master wff printer.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{MasterPrinter\_ptr node\_pkg\_get\_indenting\_master\_wff\_printer()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the indenting master wff printer]

  Description        [Returns the indenting master wff printer.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{nodePrint.c}
		
	\texttt{void print\_array\_type(FILE* output\_stream, const node\_ptr body)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Print an ARRAY_TYPE structure in smv]

  Description        []

  SideEffects        []

  SeeAlso            [print_sexp]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void print\_array\_type\_rec(FILE* out, const node\_ptr body)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private function of print_array_type]

  Description        []

  SideEffects        []

  SeeAlso            [print_array_type]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{nodeWffPrint.c}
		
	\texttt{int print\_node(FILE *stream, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pretty print a formula on a file]

  Description        [Pretty print a formula on a file]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* sprint\_node(node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pretty print a formula into a string]

  Description        [Pretty print a formula into a string. The returned 
  string must be freed after using it. Returns NULL in case of failure.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int print\_node\_indent\_at(FILE *stream, node\_ptr n, int ofs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pretty print a formula on a file (indenting)]

  Description [Pretty print a formula on a file (indenting), starting
  at given offset.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* sprint\_node\_indent\_at(node\_ptr n, int ofs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pretty print a formula into a string (indenting) ]

  Description [Pretty print a formula into a string (indenting),
  starting at given offset. The returned string must be freed after
  using it. Returns NULL in case of failure.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int print\_node\_indent(FILE *stream, node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pretty print a formula on a file (indenting)]

  Description [Pretty print a formula on a file (indenting), starting
  at column 0.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* sprint\_node\_indent(node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pretty print a formula into a string (indenting) ]

  Description [Pretty print a formula into a string (indenting),
  starting at column 0. The returned string must be freed after using
  it. Returns NULL in case of failure.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{opt}
		
	\subsection{OptsHandler.c}
		
	\texttt{OptsHandler\_ptr OptsHandler\_get\_instance()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the global options handler instance]

  Description        [Get the global options handler instance]

  SideEffects        [If called for the first time,
                      instanciates the options handler]

  SeeAlso            [OptsHandler_instance_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void OptsHandler\_instance\_destroy()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Free the global options handler instance]

  Description        [Free the global options handler instance]

  SideEffects        []

  SeeAlso            [OptsHandler_get_instance]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{OptsHandler\_ptr OptsHandler\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an empty option handler]

  Description        [Creates an empty option handler. ]

  SideEffects        [None]

  SeeAlso            [OptsHandler_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void OptsHandler\_destroy(OptsHandler\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees an option handler.]

  Description        [Frees an option handler.]

  SideEffects        [None]

  SeeAlso            [OptsHandler_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_register\_option(OptsHandler\_ptr self, const char* name, const char* def, Opts\_CheckFnType check, Opts\_ReturnFnType get, boolean is\_public, Option\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Registers an option in an option handler.]

  Description        [Registers an option in an option handler. Returns
  true if the registration of the option succeeds, false otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_register\_generic\_option(OptsHandler\_ptr self, const char* name, const char* def, boolean is\_public)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Registers a generic option in the option handler.]

  Description        [Registers an option in an option handler. Returns
  true if the registration of the option succeeds, false otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_register\_user\_option(OptsHandler\_ptr self, const char* name, const char* value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Registers a user-defined option in the option handler.]

  Description        [Registers a user-defined option in the option handler.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_register\_enum\_option(OptsHandler\_ptr self, const char* name, const char* def, Opts\_EnumRec pv[], int npv, boolean is\_public)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Registers an enumerative option in an option handler.]

  Description        [Registers an enumerative option in an option
  handler. The possible values are stored in an array of strings given
  in input. The user is not required to provide any function to check
  and return a value. Returns true if the registration of the option succeeds,
  false otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_register\_bool\_option(OptsHandler\_ptr self, const char* name, boolean value, boolean is\_public)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Registers a boolean option in an option handler.]

  Description        [Registers a boolean option in an option
  handler. The user is not required to provide any function to check
  and return a value. Returns true if the registration of the option succeeds,
  false otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_register\_int\_option(OptsHandler\_ptr self, const char* name, int value, boolean is\_public)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Registers an integer option in an option handler.]

  Description        [Registers an integer option in an option
  handler. The user is not required to provide any function to check
  and return a value. Returns true if the registration of the option succeeds,
  false otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_is\_option\_public(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given is public or not.]

  Description        [Checks if the given is public or not.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_is\_user\_option(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given option is user-defined]

  Description        [Checks if the given option is user-defined]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_is\_bool\_option(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given option is boolean]

  Description        [Checks if the given option is boolean]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_is\_int\_option(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given option is integer]

  Description        [Checks if the given option is integer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_is\_enum\_option(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given option is enumerative]

  Description        [Checks if the given option is enumerative]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_is\_generic\_option(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given option is generic]

  Description        [Checks if the given option is generic]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void OptsHandler\_get\_enum\_option\_values(OptsHandler\_ptr self, const char* name, char*** values, int* num\_values)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the string representation of option's possible values]

  Description        [Get the string representation of option's possible values]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_is\_option\_registered(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if an option has already been registered.]

  Description        [Checks if an option has already been
  registered. Returns true if it has been already registered false otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_is\_option\_not\_registered(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if an option has already been registered.]

  Description        [Checks if an option has already been
  registered. Returns false if it has been already registered true otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_unregister\_option(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Unregisters an option in an option handler.]

  Description        [Unregisters an option in an option handler. Returns
  true if the unregistration of the option succeeds, false otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_set\_option\_value(OptsHandler\_ptr self, const char* name, const char* value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Assigns the given value to a registered option.]

  Description        [Assigns the given value to an option registered
  in an option handler. Returns true if the setting of the value
  succeeds, false if the option name is not registered in the option
  handler or if the value to assigns does not is of the type allowed
  for the option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_set\_enum\_option\_value(OptsHandler\_ptr self, const char* name, const char* value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Assigns the given value to a registered option.]

  Description        [Assigns the given value to an option registered
  in an option handler. Returns true if the setting of the value
  succeeds, false if the option name is not registered in the option
  handler or if the value to assigns does not is of the type allowed
  for the option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_set\_bool\_option\_value(OptsHandler\_ptr self, const char* name, boolean value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Assigns the given value to a registered option.]

  Description        [Assigns the given value to an option registered
  in an option handler. Returns true if the setting of the value
  succeeds, false if the option name is not registered in the option
  handler or if the value to assigns does not is of the type allowed
  for the option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_set\_int\_option\_value(OptsHandler\_ptr self, const char* name, int value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Assigns the given value to a registered option.]

  Description        [Assigns the given value to an option registered
  in an option handler. Returns true if the setting of the value
  succeeds, false if the option name is not registered in the option
  handler or if the value to assigns does not is of the type allowed
  for the option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_reset\_option\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Assigns the default value to a registered option.]

  Description        [Assigns the default value to an option registered
  in an option handler. Returns true if the setting of the value
  succeeds, false if the option name is not registered in the option
  handler.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* OptsHandler\_get\_option\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the value of a registered option.]

  Description        [Returns the value of an option registered
  in an option. OPTS_VALUE_ERROR is returned if the option is not a
  registered option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* OptsHandler\_get\_option\_default\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the default value of a registered option.]

  Description        [Returns the default value of an option registered
                      in an option. OPTS_VALUE_ERROR is returned if
                      the option is not a registered option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* OptsHandler\_get\_string\_representation\_option\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the string representation of the value]

  Description        [Returns the string representation of the value.
                      The returned string must be freed, if not NULL.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* OptsHandler\_get\_string\_representation\_option\_default\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the string representation of the default value]

  Description        [Returns the string representation of the default value.
                      The returned string must be freed, if not NULL.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* OptsHandler\_get\_string\_option\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the value of a string option]

  Description        [Returns the value of a string option.
                      Depending on the return function, the string may be freed.
                      The internal getter function duplicates the string.
                      Caller should free the string]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* OptsHandler\_get\_string\_option\_default\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the default value of a string option]

  Description        [Returns the default value of a string option.
                      Depending on the return function, the string may be freed.
                      The internal getter function duplicates the string.
                      Caller should free the string]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int OptsHandler\_get\_enum\_option\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the value of an enum option.]

  Description        [Returns the value of an enum option
  value. OPTS_VALUE_ERROR is returned if the option is not a
  registered option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int OptsHandler\_get\_enum\_option\_default\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the default value of an enum option.]

  Description        [Returns the default value of an enum option
  value. OPTS_VALUE_ERROR is returned if the option is not a
  registered option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_get\_bool\_option\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the value of a boolean option.]

  Description        [Returns the value of a boolean option
  value. OPTS_VALUE_ERROR is returned if the option is not a
  registered option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_get\_bool\_option\_default\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the default value of a boolean option.]

  Description        [Returns the default value of a boolean option
                      value. OPTS_VALUE_ERROR is returned if the
                      option is not a registered option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int OptsHandler\_get\_int\_option\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the value of an int option.]

  Description        [Returns the value of an enum option
  value. OPTS_VALUE_ERROR is returned if the option is not a
  registered option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int OptsHandler\_get\_int\_option\_default\_value(OptsHandler\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the value of an int option.]

  Description        [Returns the value of an enum option
  value. OPTS_VALUE_ERROR is returned if the option is not a
  registered option.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Opts\_Gen\_init(OptsHandler\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes a generator for an option handler.]

  Description        [Initializes a generator handler which when used
  with Opts_Gen_next() will progressively return each (name, value)
  record in the option handler.]

  SideEffects        [None]

  SeeAlso            [Opts_Gen_next Opts_Gen_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Opts\_Gen\_next(OptsHandler\_ptr self, char **name, char **value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the next pair (name, value) for an option handler.]

  Description        [Given a generator created by Opts_GenInit(),
     this routine returns the next (name, value) pair in the
     generation sequence. When there are no more items in the
     generation sequence,  the routine returns 0.]

  SideEffects        [None]

  SeeAlso            [Opts_Gen_init Opts_Gen_deinit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Opts\_Gen\_deinit(OptsHandler\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees an option generator for an option handler.]

  Description        [After generating all items in a generation
  sequence, this routine must be called to reclaim the resources
  associated with the created generator.]

  SideEffects        [None]

  SeeAlso            [Opts_Gen_next Opts_Gen_init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_add\_option\_trigger(OptsHandler\_ptr self, const char* name, Opts\_TriggerFnType trigger)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints all the options on a file]

  Description        [Prints all the options stored in the option
  handler on a given file.]

  SeeAlso            [Opts_GenFree Opts_Gen Opts_GenInit Opts_PrintAllOptions]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean OptsHandler\_remove\_option\_trigger(OptsHandler\_ptr self, const char* name, Opts\_TriggerFnType trigger)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints all the options on a file]

  Description        [Prints all the options stored in the option
  handler on a given file.]

  SeeAlso            [Opts_GenFree Opts_Gen Opts_GenInit Opts_PrintAllOptions]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void OptsHandler\_print\_all\_options(OptsHandler\_ptr self, FILE* fd, boolean print\_private)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints all the options on a file]

  Description        [Prints all the options stored in the option
  handler on a given file.]

  SeeAlso            [Opts_GenFree Opts_Gen Opts_GenInit Opts_PrintAllOptions]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char* opts\_strsav(const char *s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of the given string]

  Description        [Creates a copy of the given string. Must be freed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opts\_check\_string(OptsHandler\_ptr opts, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dummy function for string options handling]

  Description        [Dummy function for string options handling]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* opts\_get\_string(OptsHandler\_ptr opts, const char* value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dummy function for string options handling]

  Description        [Dummy function for string options handling]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opts\_isinteger(OptsHandler\_ptr opts, const char *name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if a string represents an integer]

  Description        [Check if a string represents an integer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* opts\_getinteger(OptsHandler\_ptr opts, const char *value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the integer representation of the given string]

  Description        [Get the integer representation of the given string]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static opt\_ptr option\_alloc(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Allocates an instance of option]

  Description        [Allocates an instance of option]

  SideEffects        []

  SeeAlso            [option_free]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void option\_free(opt\_ptr* p)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees the given option instance]

  Description        [Frees the given option instance]

  SideEffects        []

  SeeAlso            [option_alloc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static opts\_st\_retval opts\_hash\_free(char *key, char *data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Option Hash table freeing function]

  Description        [Option Hash table freeing function]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static opt\_ptr option\_create(const char* name, const char* default\_value, const char* value, ovl\_ptr pvalues, Opts\_CheckFnType check, Opts\_ReturnFnType getvalue, boolean is\_public, Option\_Type type, boolean user\_defined)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates and initializes a new instance of option]

  Description        [Creates and initializes a new instance of option]

  SideEffects        []

  SeeAlso            [option_alloc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_enum\_check(OptsHandler\_ptr opts, const char* value, ovl\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given enumerative is in the given ovl]

  Description        [Checks if the given enumerative is in the given ovl]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* opt\_enum\_get(OptsHandler\_ptr opts, const char* value, ovl\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gen the given enumerative value]

  Description        [Gen the given enumerative value]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ovl\_ptr ovl\_rec\_alloc(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Allocates and initializes an ovl_ptr]

  Description        [Allocates and initializes an ovl_ptr]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ovl\_ptr ovl\_create\_empty(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an empty ovl_ptr (represented by NULL)]

  Description        [Creates an empty ovl_ptr (represented by NULL)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int ovl\_isempty(ovl\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given ovl is empty]

  Description        [Checks if the given ovl is empty]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int ovl\_isnotempty(ovl\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the given ovl is not empty]

  Description        [Checks if the given ovl is not empty]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ovl\_ptr ovl\_create(const char* values, int valuee)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new instance of ovl and sets
                      it with the given values]

  Description        [Creates a new instance of ovl and sets
                      it with the given values]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ovl\_ptr ovl\_get\_next(ovl\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the next ovl in the list]

  Description        [Get the next ovl in the list]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ovl\_ptr ovl\_set\_next(ovl\_ptr l, ovl\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the next ovl in the list]

  Description        [Sets the next ovl in the list]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ovl\_free(ovl\_ptr *l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees the given ovl instance]

  Description        [Frees the given ovl instance]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int ovl\_ispresent(ovl\_ptr l, const char *value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks whatever the given value is in the given list]

  Description        [Checks whatever the given value is in the given list]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean check\_boolean(ovl\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the given list contains boolean values]

  Description        [Check if the given list contains boolean values]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opts\_handler\_register\_generic\_option(OptsHandler\_ptr self, const char* name, const char* def, ovl\_ptr ovl, Opts\_CheckFnType check, Opts\_ReturnFnType get, boolean is\_public, Option\_Type type, boolean user\_defined)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal function for option registration]

  Description        [Internal function for option registration]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opts\_handler\_run\_triggers(OptsHandler\_ptr self, opt\_ptr opt, const char* name, const char* val, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal function for trigger run]

  Description        [Internal function for trigger run]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{optCmd.c}
		
	\texttt{void init\_options()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Initialize the NuSMV options.]

   Description        [The NuSMV options are initialized. A pointer to
   a structure containing the NuSMV options is allocated, its fields
   are initialized and the pointer is returned.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void init\_options\_cmd()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Initialize the NuSMV options command]

   Description        [This function declares the interactive shell
   commands necessary to manipulate NuSMV options.]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandSetVariable(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis          [Sets an environment variable]

   CommandName       [set]

   CommandSynopsis   [Sets an environment variable]

   CommandArguments  [\[-h\] \[&lt;name&gt;\] \[&lt;value&gt;\]]

   CommandDescription [ A variable environment is maintained by the command
   interpreter.
   The "set" command sets a variable to a particular value, and the
   "unset" command removes the definition of a variable.
   If "set" is given no arguments, it prints the current value of all variables.<p>

   Command options:<p>
   <dl> <dt> -h
   <dd> Prints the command usage.
   </dl>
   <dl> <dt> &lt;name&gt;
   <dd> Variable name
   </dl>
   <dl> <dt> &lt;value&gt;
   <dd> Value to be assigned to the variable.
   </dl>

   <p>
   Interpolation of variables is allowed when using the set command. The
   variables are referred to with the prefix of '$'. So for example,
   what follows can be done to check the value of a set variable:<br>
   <code>
   NuSMV> set foo bar<br>
   NuSMV> echo $foo<br>
   bar <br>
   </code>

   The last line "bar" will be the output produced by NuSMV.<p>

   Variables can be extended by using the character ':' to concatenate
   values. For example: <br>
   <code>
   NuSMV> set foo bar<br>
   NuSMV> set foo $foo:foobar<br>
   NuSMV> echo $foo<br>
   bar:foobar<br>
   </code>
   The variable <code> foo </code> is extended with the value <code>
   foobar </code>. <p>

   Whitespace characters may be present within quotes. However, variable
   interpolation lays the restriction that the characters ':' and '/' may
   not be used within quotes. This is to allow for recursive interpolation.
   So for example, the following is allowed<br>
   <code>
   NuSMV> set "foo bar" this<br>
   NuSMV> echo $"foo bar"<br>
   this <br>
   </code>
   The last line will be the output produced by NuSMV. <br>
   But in the following, the  value of the variable <code> foo/bar </code>
   will not be interpreted correctly:<p>
   <code>
   NuSMV> set "foo/bar" this<br>
   NuSMV> echo $"foo/bar"<br>
   foo/bar<br>
   </code>
   If a variable is not set by the "set" command, then the variable is returned
   unchanged.
   <p>

   Different commands use environment information for different purposes.
   The command interpreter makes use of the following parameters:<p>

   <dl>
   <dt><b>autoexec</b>
   <dd>     Defines a command string to be automatically executed after every
   command processed by the command interpreter.
   This is useful for things like timing commands, or tracing the
   progress of optimization.
   </dl>


   <dl><dt><b>open_path</b>
   <dd>      "open_path" (in analogy to the shell-variable PATH) is a list of
   colon-separated strings giving directories to be searched whenever
   a file is opened for read.  Typically the current directory (.) is
   the first item in this list. The standard system library (typically
   $NuSMV_LIBRARY_PATH) is always implicitly appended to the current
   path.
   This provides a convenient short-hand mechanism for reaching
   standard library files.
   </dl>
   <dl><dt> <b>nusmv_stderr </b>
   <dd>   Standard error (normally stderr) can be re-directed to a file
   by setting the variable nusmv_stderr.
   </dl>

   <dl><dt>  <b>nusmv_stdout</b>
   <dd>           Standard output (normally stdout) can be re-directed to a file
   by setting the variable nusmv_stdout.
   </dl>
   ]

   SideEffects        []

   SeeAlso            [unset]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandUnsetVariable(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis          [Unsets an environment variable]

   CommandName       [unset]

   CommandSynopsis   [Unsets an environment variable]

   CommandArguments  [\[-h\] &lt;variables&gt;]

   CommandDescription [A variable environment is maintained by the command
   interpreter.
   The "set" command sets a variable to a particular value, and the
   "unset" command removes the definition of a variable. <p>
   Command options:<p>
   <dl><dt> -h
   <dd> Prints the command usage.
   </dl>
   <dl><dt> &lt;variables&gt;
   <dd> Variables to be unset
   </dl>
   ]

   SideEffects        []

   SeeAlso            [set]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static char* remove\_non\_existant\_pps(const char* pp\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Finds all preprocessor names occurring in the given string
   that are not actually available, and returns the set of the only
   available ones]

   Description        [Returned string must be freed]

   SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static const char* opt\_check\_invar\_fb\_heuristic\_to\_string (FB\_Heuristic h)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Convert the FB_Heuristic to it's string representation]

   Description [Convert the FB_Heuristic to it's string representation]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static const char* opt\_check\_invar\_bddbmc\_heuristic\_to\_string (Bdd2bmc\_Heuristic h)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Convert the Bdd2bmc_Heuristic to it's string representation]

   Description [Convert the Bdd2bmc_Heuristic to it's string representation]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_check\_sat\_solver(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check function for the sat_solver option.]

   Description [Check function for the sat_solver option.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* opt\_get\_sat\_solver(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [get function for the sat_solver option.]

   Description [get function for the sat_solver option.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void * opt\_get\_integer(OptsHandler\_ptr opts, const char *value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Get the integer representation of the given string]

   Description        [Get the integer representation of the given string]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_input\_file\_trigger(OptsHandler\_ptr opts, const char* name, const char* val, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Input file check function]

   Description [Input file check function]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_check\_word\_format(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check function for the output word format]

   Description [Check function for the output word format]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_check\_shown\_states(OptsHandler\_ptr opts, const char* val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Check function for the number of shown states]

   Description [Check function for the number of shown states]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_set\_reachable\_states\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Trigger that sets the use_reachable_states flag if needed]

   Description [Trigger that sets the use_reachable_states flag if needed]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_reorder\_method\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [reordering method trigger: enables / disables dd_autodyn]

   Description [reordering method trigger: enables / disables dd_autodyn]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_dynamic\_reorder\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Dynamic reordering trigger: enables / disables dd_autodyn]

   Description [Dynamic reordering trigger: enables / disables dd_autodyn]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_trace\_plugin\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Trigger for the default_trace_plugin option. ]

   Description [Trigger for the default_trace_plugin option: Updates the
   default plugin in the trace pkg.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_trans\_order\_file\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Trigger function for the trans_order_file option]

   Description [Trigger function for the trans_order_file option:
   Enables/disables AFFINITY_CLUSTERING if needed]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_run\_cpp\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Trigger function for the run_cpp option]

   Description [Trigger function for the run_cpp option: Tells that the
   option is deprecated. No side-effect on the option
   value will be performed]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_pp\_list\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Trigger function for the pp_list option]

   Description [Trigger function for the pp_list option. Checks that
                the given list of preprocessors is valid or not]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_rbc\_inlining\_lazy\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action action)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Trigger function for the run_cpp option]

   Description [Trigger function for the run_cpp option: Tells that the
   option is deprecated. No side-effect on the option
   value will be performed]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean opt\_traces\_regexp\_trigger(OptsHandler\_ptr opts, const char* opt, const char* value, Trigger\_Action act)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Trigger function for the traces_regexp option]

   Description [Trigger function for the counter_examples_show_re
   option: tries to compile regexp pattern and rejects it if
   compilation fails.]

   SideEffects []

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{parser}
		
	\section{idlist}
		
	\subsection{ParserIdList.c}
		
	\texttt{ParserIdList\_ptr ParserIdList\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserIdList\_destroy(ParserIdList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserIdList\_parse\_from\_file(ParserIdList\_ptr self, FILE* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserIdList\_parse\_from\_string(ParserIdList\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr ParserIdList\_get\_id\_list(const ParserIdList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of variables read by the parser]

  Description        [Returned list is owned by self, and should not be 
  changed or destroyed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserIdList\_reset(ParserIdList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void parser\_id\_list\_add\_id(ParserIdList\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_id\_list\_mk\_dot(ParserIdList\_ptr self, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_id\_list\_mk\_array(ParserIdList\_ptr self, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_id\_list\_mk\_bit(ParserIdList\_ptr self, node\_ptr left, int suffix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_id\_list\_mk\_atom(ParserIdList\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_id\_list\_mk\_num(ParserIdList\_ptr self, const int num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_id\_list\_init(ParserIdList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_id\_list\_deinit(ParserIdList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{ord}
		
	\subsection{ParserOrd.c}
		
	\texttt{ParserOrd\_ptr ParserOrd\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserOrd\_destroy(ParserOrd\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserOrd\_parse\_from\_file(ParserOrd\_ptr self, FILE* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserOrd\_parse\_from\_string(ParserOrd\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr ParserOrd\_get\_vars\_list(const ParserOrd\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the list of variables read by the parser]

  Description        [Returned list is owned by self, and should not be 
  changed or destroyed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ParserOrd\_reset(ParserOrd\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void parser\_ord\_add\_var(ParserOrd\_ptr self, node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_ord\_mk\_dot(ParserOrd\_ptr self, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_ord\_mk\_array(ParserOrd\_ptr self, node\_ptr left, node\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_ord\_mk\_bit(ParserOrd\_ptr self, node\_ptr left, int suffix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_ord\_mk\_atom(ParserOrd\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr parser\_ord\_mk\_num(ParserOrd\_ptr self, const int num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_ord\_init(ParserOrd\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_ord\_deinit(ParserOrd\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{psl}
		
	\subsection{psl.c}
		
	\subsection{pslConv.c}
		
	\texttt{node\_ptr PslNode\_convert\_psl\_to\_core(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Reduces the given PSL formula to an equivalent formula that
                    uses only core symbols. Resulting formula is
                    either LTL of CTL, and can be used for model
                    checking.]

Description [This is the high fcuntion used at system level to convert
                    PSL expression to equivalent expressions that can
                    be managed at system level.  Warning: the
                    resulting expression may have a different
                    structure, do not refer to its structure to report
                    errors to the user, use it internally intstead.]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr PslNode\_convert\_id(PslNode\_ptr id, PslOpConvType type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Converts an id to a different id type, for example a PSL id
to a SMV id]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr PslNode\_pslobe2ctl(PslNode\_ptr expr, PslOpConvType type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Takes a PSL OBE expression and builds the corresponding
CTL expression ]

Description [Takes a PSL OBE expression and builds the corresponding
CTL expression.]

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_pslobe2ctl(PslNode\_ptr expr, PslOpConvType type, NodeList\_ptr replicator\_id\_stack)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis    [Private service for high level function PslNode_pslobe2ctl]

Description [Private service for high level function PslNode_pslobe2ctl]

SideEffects        [required]

SeeAlso            [PslNode_pslobe2ctl]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr PslNode\_remove\_forall\_replicators(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Takes a PSL expression and expands all forall constructs
contained in the expression]

Description [Takes a PSL expression and expands all forall constructs
contained in the expression. Visits the syntax tree of the expressions
and whenever it finds a forall construct it expands the expression in
its scope.]

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_remove\_forall\_replicators(PslNode\_ptr expr, NodeList\_ptr replicator\_id\_stack)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Private service for high level function
          PslNode_remove_forall_replicators]

Description [Private service for high level function
             PslNode_remove_forall_replicators. In removing nested
             forall it takes into accaount possible clashes on the
             names of the bounded variables.]

SideEffects        [required]

SeeAlso            [PslNode_remove_forall_replicators]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr PslNode\_pslltl2ltl(PslNode\_ptr expr, PslOpConvType type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Takes a PSL LTL expression and builds the
corresponding LTL expression ]


Description [Takes a PSL LTL expression and builds the corresponding
LTL expression. This ignores SERE that can be easily mapped to the
corresponding LTL expression.  The parameter replicator_id_stack is
used to prevent ID duplication of nested forall (replicators).]

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_pslltl2ltl(PslNode\_ptr expr, PslOpConvType type, NodeList\_ptr replicator\_id\_stack)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Takes a PSL LTL expression and builds the
corresponding LTL expression ]


Description [Takes a PSL LTL expression and builds the corresponding
LTL expression. This ignores SERE that can be easily mapped to the
corresponding LTL expression.  The parameter replicator_id_stack is
used to prevent ID duplication of nested forall (replicators).
type can be PSL2SMV or PSL2PSL]

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr PslNode\_remove\_sere(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Converts the given expression (possibly containing sere)
into an equivalent LTL formula]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslOp psl\_conv\_op(PslOpConvType type, PslOp op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Converts the given operator into either a PSL operator, or
a SMV operator, depending on the value of 'type']

Description        []

SideEffects        [required]

SeeAlso            [PSL_OP_CONV]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_expand\_next\_event(PslOp op, PslNode\_ptr f, PslNode\_ptr b, PslOpConvType type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [During the conversion to LTL, this function is invoked
when the expansion of next_event family is required.]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_subst\_id(PslNode\_ptr expr, PslNode\_ptr id, PslNode\_ptr v, boolean is\_top\_level)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [This is used to rename IDs occurring in the tree, when
the replicator 'foreach' statement is resolved]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_expand\_replicator(PslNode\_ptr rep, PslNode\_ptr wff, PslOp op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Expansion of a replicator 'forall' statement]

Description [Wff must not have been converted to smv yet when this
   function is called. Each replicated expression wff will be joined
   with the others by using the passed operator op. The result still
   contains only psl tokens.]

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_disj(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Removes the disjunction among SERE, by distributing it]

Description [ This function assumes that expression is a disjunction
of concat/fusion]

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_insert\_inside\_holes(PslNode\_ptr e, PslNode\_ptr to\_be\_inserted, boolean* inserted)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Service due to way concat_fusion expansion is implemented]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_concat\_fusion2ltl(PslNode\_ptr e, PslNode\_ptr phi)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Resolves concat/fusion and converts it to an equivalent LTL
expression]

Description        [This function assumes that expression is a concat/fusion]

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_translate(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [High-level service of exported function PslNode_remove_sere]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_sere\_is\_disj(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expression is a disjunction of SEREs.]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_distrib\_disj(PslNode\_ptr e, boolean *modified)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Distributes the disjunction among SEREs]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_star\_count(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolves starred SEREs]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_sere\_is\_ampersand(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given SERE is in the form {a} & {b}]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_get\_leftmost(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the leftmost element of e that is not a SERE]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_get\_rightmost(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the rightmost element of e that is not a SERE]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_plus(PslNode\_ptr e, boolean toplevel)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolve SERE \[+\]]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_remove\_suffix\_implication(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolves suffix implication]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_star(PslNode\_ptr e, boolean toplevel, boolean* modified)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolves starred SEREs]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_trailing\_star(PslNode\_ptr e, boolean* modified)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolves trailing standalone stars]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_trailing\_plus(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolves the last trailing standalone plus]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_ampersand(PslNode\_ptr e, boolean* modified)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolves {a}&{a}]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_2ampersand(PslNode\_ptr e, boolean *modified)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolves {a} && {a}]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static PslNode\_ptr psl\_node\_sere\_remove\_fusion(PslNode\_ptr e, boolean *modified)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Resolves {a}:{a}]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{pslExpr.c}
		
	\texttt{static void psl\_expr\_print\_klass(FILE* file, SyntaxClass type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [required]

   Description        [optional]

   SideEffects        [required]

   SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int psl\_expr\_is\_boolean(const PslExpr psl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Returns 1 if the given node is boolean compatible type, 0
   otherwise]

   Description        [optional]

   SideEffects        []

   SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int psl\_expr\_check\_klass(const PslExpr psl, SyntaxClass expected)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [returns 0 if the given psl expr is not compatible with the
   given klass]

   Description        [optional]

   SideEffects        []

   SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int psl\_expr\_base\_num\_to\_val(char* base\_num)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis [Converts from base to number: TO BE IMPLEMENTED]

   Description        [optional]

   SideEffects        []

   SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void psl\_expr\_require\_klass(const PslExpr psl, SyntaxClass expected)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks that given expression is compatible with the
   given required syntactic class]

   Description        [optional]

   SideEffects        []

   SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void psl\_expr\_is\_valid\_flproperty(PslOp op\_id, const PslExpr* left, const PslExpr* right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Checks that there is no violation of types for
                       operators '=', '!=' and '==', that cannot be
                       used with FL_PROPERTY expressions]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{pslNode.c}
		
	\texttt{PslNode\_ptr PslNode\_convert\_from\_node\_ptr(node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Casts a PslNode_ptr to a node_ptr]

Description        [The returned structure will still contain operators
in the SMV parser's domain]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr PslNode\_convert\_to\_node\_ptr(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Casts a node_ptr to a PslNode_ptr]

Description        [The returned structure will still contain operators
in the PSL parser's domain]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr PslNode\_new\_context(PslNode\_ptr ctx, PslNode\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Creates a psl node that represents a contestualized
node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean PslNode\_is\_handled\_psl(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true iff given expression can be translated
into LTL.]

Description        []

SideEffects        [None]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean PslNode\_is\_propositional(const PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks for a formula being a propositional formula]

Description        [Checks for a formula being a propositional formula]

SideEffects        [None]

SeeAlso            [PslNode_is_trans_propositional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean PslNode\_is\_trans\_propositional(const PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks for a formula being a propositional formula]

Description        [Checks for a formula being a propositional formula,
                    next operator here leaves the formula propositional]

SideEffects        [None]

SeeAlso            [PslNode_is_propositional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean PslNode\_propositional\_contains\_next(const PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks if a propositional formula contains a next]

Description        [Checks for a formula being a propositional formula]

SideEffects        [None]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean PslNode\_is\_obe(const PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks for a formula being an CTL formula]

Description        [Checks for a formula being an CTL formula]

SideEffects        [None]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean PslNode\_is\_ltl(const PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks for a formula being an LTL formula]

Description        [Checks for a formula being an LTL formula]

SideEffects        [None]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_new\_node(PslOp op, PslNode\_ptr left, PslNode\_ptr right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Creates a new PSL node, re-using already an existing
node if there is one]

Description [WARNING: If this function is being called to build a
 branch of the parse-tree from a branch coming from the parsing phase
 (i.e. it is a token, and not a symbol), the token *must* be converted
 to a PSL node by calling psl_conv_op(TOK2PSL, op) ]

SideEffects        [None]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslOp psl\_node\_get\_op(PslNode\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the given expression's top level operator]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_left(PslNode\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the given expression's left branch]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_right(PslNode\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the given expression's right branch]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void psl\_node\_set\_left(PslNode\_ptr n, PslNode\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Sets the given expression's left branch]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void psl\_node\_set\_right (PslNode\_ptr n, PslNode\_ptr r)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Sets the given expression's right branch]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_true()}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Creates a new TRUE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_true(PslNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks if a node is a TRUE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_false()}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Creates a new FALSE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_false(PslNode\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks if a node is a FALSE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_sere(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a SERE]

Description        [A SERE can be in the form {a}, {a};{b}, {a}:{b},
{a}\[*\], {a}\[+\], {a}|{b}, {a}&{a}, {a}&&{b} ]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_serebrackets(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a SERE in the form {a}]

Description        []

SideEffects        [None]

SeeAlso            [psl_node_is_sere]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_star\_get\_count(const PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the count of a starred sere.]

Description        [Returned value can be either a positive integer value, or
the constant PSL_EMPTYSTAR to represent an empty starred sere.]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_handled\_star(PslNode\_ptr expr, boolean toplevel)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given starred sere can be handled by the
system. ]

Description        [precond: expr must be a repeated sere]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_propositional(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given sere contains a single
propositional expression]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_repeated(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expr is a repeated sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_star(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expr is a starred repeated sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_stareq(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expr is a starred-eq repeated sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_starminusgt(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expr is a starred-minusgt repeated sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_standalone\_star(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expr is in the form <empty>\[*\],
with or without a counter.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_plus(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression a plus repeated sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_standalone\_plus(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given repeated sere is in the form
<empty>\[+\]]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_star\_count(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given starred repeated sere as also
a counter]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_star\_count\_zero(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expr is a star sere with
count zero]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_propositional\_get\_expr(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the expression in a propositional sere.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_compound\_get\_left(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the left operand of a compound sere.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_compound\_get\_right(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the right operand of a compound sere.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_repeated\_get\_expr(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns the repeated expression associated to the repeated
sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_repeated\_get\_count(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns the count associated to the repeated sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslOp psl\_node\_sere\_repeated\_get\_op(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns the count associated to the repeated sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_sere\_propositional(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a propositional sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_sere\_concat(PslNode\_ptr seq1, PslNode\_ptr seq2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a concatenation sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_sere\_star(PslNode\_ptr seq)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a star sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_star\_get\_starred(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Getter for a star sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_sere\_2ampersand(PslNode\_ptr seq1, PslNode\_ptr seq2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a && sere]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_sere\_compound(PslNode\_ptr seq1, PslOp op, PslNode\_ptr seq2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for the sere compound]

Description        [Warning: the operator must be a symbol, not a token.
This means that psl_conv_op must be called to convert tokens before.]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_sere\_compound\_binary(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a sere compound]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_suffix\_implication(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expression is a suffix
implication]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_suffix\_implication\_weak(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a weak suffix
implication]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_suffix\_implication\_strong(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a strong suffix
implication]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_suffix\_implication\_get\_premise(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the premise of the given suffix implication]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_suffix\_implication\_get\_consequence(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the consequence of the given suffix implication]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_concat\_holes\_free(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if there are no holes in the given concat sere
to be filled in.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_concat\_fusion(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expression is a concat or fusion
sere.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_concat(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a concat.]

Description        [Returns true if the top level operator is a concat.]

SideEffects        [None]

SeeAlso            [psl_node_sere_is_concat_fusion,
                    psl_node_sere_is_fusion]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_concat\_get\_left(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the left operand of a concat.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_concat\_get\_right(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the right operand of a concat.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_concat\_get\_leftmost(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the leftmost element of a concat sere]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_concat\_get\_rightmost(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the rightmost element of a concat sere]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_concat\_cut\_leftmost(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Cuts the leftmost element of a concat sere]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_fusion\_get\_left(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the left operand of a fusion.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_sere\_fusion\_get\_right(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the right operand of a fusion.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_fusion(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a fusion.]

Description        [Returns true if the top level operator is a fusion.]

SideEffects        [None]

SeeAlso            [psl_node_sere_is_concat_fusion,
                    psl_node_sere_is_concat]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_or(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is an or.]

Description        [Duplicate of psl_node_sere_is_disj.]

SideEffects        [None]

SeeAlso            [psl_node_sere_is_disj]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_concat\_fusion\_holes\_free(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [[Returns true if there are no holes in the given
fusion/concat sere to be filled in.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_prune(PslNode\_ptr tree, PslNode\_ptr branch)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Prunes aways the given branch from the given tree]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_propstar(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expression is a propositional
starred sere.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_sere\_is\_2ampersand(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a sere in the form
{ s2 && s1 } ]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_cons(PslNode\_ptr elem, PslNode\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a list]

Description        [This gets the element to insert at top level, and
the list for next]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_cons\_new(PslNode\_ptr elem, PslNode\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a list, does not use find_node]

Description        [This gets the element to insert at top level, and
the list for next]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_cons(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given node is a list]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_cons\_get\_element(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the currently pointed element of a list]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_cons\_get\_next(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the next element of a list]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_cons\_reverse(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reverse a list.]

  Description        [Returns a new sequence containing the same
  elements as 'e' but in reverse order]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_ite(PslNode\_ptr \_ite)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is If Then Else]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_ite\_cond(PslNode\_ptr \_ite)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the condition of the given ITE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_ite\_then(PslNode\_ptr \_ite)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the 'then' branch of the given ITE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_ite\_else(PslNode\_ptr \_ite)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the 'else' branch of the given ITE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_case(PslNode\_ptr \_case)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a case expression]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_case\_cond(PslNode\_ptr \_case)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the condition of the given case node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_case\_then(PslNode\_ptr \_case)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the 'then' branch of the given case node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_case\_next(PslNode\_ptr \_case)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the next case node of the given case.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_range(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given node is a range]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_range\_get\_low(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the low bound of the given range]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_range\_get\_high(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the high bound of the given range]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_number(int value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a NUMBER node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_case(PslNode\_ptr \_cond, PslNode\_ptr \_then, PslNode\_ptr \_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a CASE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_failure(const char* msg, FailureKind kind)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a FAILURE node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_number(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is an integer number]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_word\_number(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is a word number]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int psl\_node\_number\_get\_value(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns the integer value associated with the given number
node. ]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_make\_extended\_next(PslOp op, PslNode\_ptr expr, PslNode\_ptr when, PslNode\_ptr condition)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Maker for a NEXT* family node]

Description        [Warning: the operator must be a symbol, not a token.
This means that psl_conv_op must be called to convert tokens before.]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_extended\_next(PslNode\_ptr e)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given a psl node returns true iff the expression belongs to
the next operators family.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_extended\_next\_get\_expr(PslNode\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the FL expression of a next expression node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_extended\_next\_get\_when(PslNode\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the when component of a next expression node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_extended\_next\_get\_condition(PslNode\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns the boolean condition of a next expression node]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_boolean\_type(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given node is the PSL syntactic type
'boolean']

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_infinite(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given node is the PSL syntactic value
'inf']

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_id(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given node is an identifier]

Description [The top level operator of an ID can be DOT,
ATOM or ARRAY]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_id\_equal(PslNode\_ptr \_id1, PslNode\_ptr \_id2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if two ids are equal]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_num\_equal(PslNode\_ptr \_id1, PslNode\_ptr \_id2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given numbers are equal]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_leaf(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given node is a leaf, i.e. PSL_NULL, a
   number, a boolean constant, or an atom.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_repl\_prop(PslNode\_ptr \_prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expression is a replicated
property]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_repl\_prop\_get\_replicator(PslNode\_ptr \_prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Given a replicated property, returns the node that contains
the replicator.]

Description        []

SideEffects        [None]

SeeAlso            [psl_node_repl_prop_get_property]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_repl\_prop\_get\_property(PslNode\_ptr \_prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given a replicated property, returns the node that contains
the property.]

Description        []

SideEffects        [None]

SeeAlso            [psl_node_repl_prop_get_replicator]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean psl\_node\_is\_replicator(PslNode\_ptr \_repl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis [Returns true if the given expression represents a
replicator.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_replicator\_id(PslNode\_ptr \_repl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given a replicator, returns the its ID]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_replicator\_range(PslNode\_ptr \_repl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given a replicator, returns its range]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_replicator\_value\_set(PslNode\_ptr \_repl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given a replicator, returns the its values set.]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslOp psl\_node\_get\_replicator\_join\_op(PslNode\_ptr \_repl)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given a replicator, returns the operator joining each
replicated expression]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_get\_replicator\_normalized\_value\_set(PslNode\_ptr rep)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Given a replicator, returns its values set as a list
of the enumerated values]

Description        []

SideEffects        [required]

SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PslNode\_ptr psl\_node\_context\_to\_main\_context(PslNode\_ptr context)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Contestualizes a context node into the 'main' context ]

Description        [This function is used to build the internal structure of
   the context (e.g. module instance name) from the parse tree. The
   function is needed since with the grammar it is not possible/simple
   to build directly the desired structure.]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_equal(PslNode\_ptr e, PslNode\_ptr f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           []

Description [To compare structures like {{a}} and {{{{a}}}} and check
   whether the innermost {a}'s are actually the same node pointer]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_star\_free(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given sere is star-free]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_unbound\_star\_free(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given sere doesn't contain any unbound
                    star]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_emptystar\_free(PslNode\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Returns true if the given expression is empty star-free]

Description        []

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_handled\_sere(PslNode\_ptr e, boolean toplevel)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Private service of PslNode_is_handled_psl]

Description        []

SideEffects        [None]

SeeAlso            [PslNode_is_handled_psl]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_handled\_next(PslNode\_ptr next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Private service of PslNode_is_handled_psl]

Description        []

SideEffects        [None]

SeeAlso            [PslNode_is_handled_psl]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_handled\_fl\_op(PslOp op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Private service of PslNode_is_handled_psl]

Description        []

SideEffects        [None]

SeeAlso            [PslNode_is_handled_psl]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_fl\_op(PslOp op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Private service of PslNode_is_handled_psl]

Description        []

SideEffects        [None]

SeeAlso            [PslNode_is_handled_psl]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_obe\_op(PslOp op)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Private service of PslNode_is_handled_psl]

Description        []

SideEffects        [None]

SeeAlso            [PslNode_is_handled_psl]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean psl\_node\_is\_propositional(const PslNode\_ptr expr, boolean accept\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Checks for a formula being a propositional formula]

Description        [Checks for a formula being a propositional formula]

SideEffects        [None]

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{parserCmd.c}
		
	\texttt{void Parser\_Init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the parser]

  Description        [Initializes the parser]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Parser\_Quit(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deinitializes the parser]

  Description        [Deinitializes the parser]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandReadModel(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reads a NuSMV file into NuSMV.]

  CommandName        [read_model]

  CommandSynopsis    [Reads a NuSMV file into NuSMV.]

  CommandArguments   [\[-h\] \[-i model-file\]]

  CommandDescription [Reads a NuSMV file. If the <tt>-i</tt> option is
  not specified, it reads from the file specified in the environment
  variable <tt>input_file</tt>.<p>
  Command options:<p>
  <dl>
    <dt> <tt>-i model-file</tt>
       <dd> Sets the environment variable <tt>input_file</tt> to
           <tt>model-file</tt>, and reads the model from the specified file.
  </dl>]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{parserUtil.c}
		
	\texttt{extern FILE* psl\_yyin; void Parser\_OpenInput(const char *filename)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Open a file and inform the parser to read from it]

  Description        [Open a file and inform the parser to start
  reading tokens from this file. If no input file is provided, then it
  inform the parser to start reading tokens from the standard input.
  Invoke Parser_CloseInput to close the file and associated buffer. ]

  SideEffects        []

  SeeAlso            [Parser_CloseInput]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Parser\_CloseInput()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Close the input file]

  Description        [Closes the input file and corresponding buffer used
  by the parser to read tokens.
  NB: This function should be invoked only after successive invocation
  of parser_open_input_pp.]

  SideEffects        []

  SeeAlso            [Parser_OpenInput]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_ReadSMVFromFile(const char *filename)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parse SMV code from a given file.]

  Description        [Parse SMV code from a given file. If
  no file is provided, parse from stdin. If a parsing error occurs then
  return 1, else return 0. The result of parsing is stored in
  the global variable <tt>parsed_tree</tt> to be used from the caller.]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_ReadCmdFromString(int argc, const char** argv, const char* head, const char* tail, node\_ptr* pc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parse a comand from a given string.]

  Description        [Create a string for a command, and then call
  <tt>yyparse</tt> to read from the created string.
  If a parsing error occurs than return 1, else return 0.
  The result of parsing is stored in <tt>pc</tt> to be used from the caller.]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_ReadCmdFromFile(const char *filename, node\_ptr* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parse a command expression from file]

  Description [ The resulting parse tree is returned through res. If a
  parsing error occurs then return 1, else return 0. ]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_ReadNextExprFromFile(const char *filename, node\_ptr* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parse a next expression from file]

  Description [ The resulting parse tree is returned through res. If a
  parsing error occurs then return 1, else return 0. ]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_ReadSimpExprFromString(const char* str\_expr, node\_ptr* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parse a simple expression from string]

  Description [ The resulting parse tree is returned through res. If a
  parsing error occurs then return 1, else return 0. ]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_ReadNextExprFromString(const char* str\_expr, node\_ptr* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parse a next expression from string]

  Description [ The resulting parse tree is returned through res. If a
  parsing error occurs then return 1, else return 0. ]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_ReadIdentifierExprFromString(const char* str\_expr, node\_ptr* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parse an identifier expression from string]

  Description [ The resulting parse tree is returned through res. If a
  parsing error occurs then return 1, else return 0. ]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_ReadLtlExprFromFile(const char *filename)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parse LTL expression from a given file.]

  Description        [Parse SMV code from a given file. If
  no file is provided, parse from stdin. If a parsing error occurs then
  return 1, else return 0. The result of parsing is stored in
  the global variable <tt>parsed_tree</tt> to be used from the caller.]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_read\_psl\_from\_string(int argc, const char** argv, node\_ptr* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parses a PSL expression from the given string.]

  Description        [The PSL parser is directly called. The resulting
  parse tree is returned through res. 1 is returned if an error occurred.]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Parser\_read\_psl\_from\_file(const char* filename, node\_ptr* res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Parses a PSL expression from the given file.]

  Description        [The PSL parser is directly called. The resulting
  parse tree is returned through res. 1 is returned if an error occurred.]

  SideEffects        []

  SeeAlso            []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Parser\_get\_syntax\_errors\_list()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a list of SYNTAX_ERROR nodes]

  Description [Each node of the list can be passed to
  Parser_get_syntax_error to get information out of it. The
  returned lists must be NOT modified or freed by the caller.]

  SideEffects        []

  SeeAlso            [Parser_get_syntax_error]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Parser\_get\_syntax\_error(node\_ptr node, const char** out\_filename, int* out\_lineno, const char** out\_token, const char** out\_message)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns information out of nodes contained in list
  returned by Parser_get_syntax_errors_list.]

  Description [Each node contains information which will be set in
  output params filename, lineno and message. Those information
  must be NOT modified or freed by the caller. If not interested in
  an information, pass NULL with the respective parameter.]

  SideEffects        []

  SeeAlso            [Parser_get_syntax_errors_list]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Parser\_print\_syntax\_error(node\_ptr error, FILE* fout)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Prints information contained in one node ot the list
  returned by Parser_get_syntax_errors_list.]

  Description [The syntax error information contained in the given
  node is printed to the given output file.]

  SideEffects        []

  SeeAlso            [Parser_get_syntax_errors_list]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void parser\_add\_syntax\_error(const char* fname, int lineno, const char* token, const char* err\_msg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Add a new syntax error to the list]

  Description        [This is called by the parser when needed]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void parser\_free\_parsed\_syntax\_errors()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Frees the list of structures containing the syntax
  errors built by the parser. ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_open\_input\_pp(const char* filename)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Open a file and inform the parser to read from it]

  Description        [Open a file, pre-process it, and inform the parser to
  start reading tokens from this file. The directory in which the original file
  statements used by the second or later pre-processor work properly.]

  SideEffects        [Creates temporary files which are subsequently deleted.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void parser\_close\_input\_pp()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Close the input file]

  Description        [Closes the input file used from parser to read tokens.]

  SideEffects        [Deletes any temporary files created by
  parser_open_input_pp.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{prop}
		
	\subsection{Prop.c}
		
	\texttt{Prop\_ptr Prop\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Prop class constructor]

  Description        [Allocate a property. If no more room is available
                      then a call to <tt>numsv_exit</tt> is
                      performed. All the fields of the prop
                      structure are initialized to either NULL or
                      the corresponding default type
                      (e.g. Prop_NoType for property type).]

  SideEffects        []

  SeeAlso            [Prop_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Prop\_ptr Prop\_create\_partial(Expr\_ptr expr, Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a property, but does not insert it within the
                      database, so the property can be used on the
                      fly.]

  Description        [Creates a property structure filling only the
                      property and property type fields. The
                      property index within the db is not set.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_destroy(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Prop class destructor]

  Description        [Free a property. Notice that before freeing the
                      property all the elements of the property
                      that needs to be freed will be automatically
                      freed.]

  SideEffects        []

  SeeAlso            [Prop_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL Expr\_ptr Prop\_get\_expr(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the property as it has been parsed and created]

  Description [Returns the property stored in the prop. If the
  property is PSL, the result should be converted to core symbols
  before model checking (see Prop_get_expr_core or
  PslNode_convert_psl_to_core).]

  SideEffects        []

  SeeAlso            [Prop_get_expr_core]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Prop\_get\_expr\_core(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the property, but it is converted before in
                      terms of core symbols.]

  Description        [Returns the property in a form that it can be
                      handled by the system (model checking,
                      dependency finder, etc.).  This may imply a
                      conversion and a different structure of the
                      resulting formula. For example in PSL FORALLs
                      are expanded, SERE are removed, global
                      operators G and AG are simplified, etc.

                      Use this function at system-level, and
                      Prop_get_expr to get the original formula instead]

  SideEffects        []

  SeeAlso            [Prop_get_expr]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr Prop\_get\_expr\_core\_for\_coi(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        [Derived from Prop_get_expr_core, but for PSL only
                      removes forall replicators rather than
                      converting the whole expression into LTL. ]

  SideEffects        [prop_get_expr_core_for_coi]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Prop\_get\_cone(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the cone of a property]

  Description        [If the cone of influence of a property has been
                      computed, this function returns it.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_cone(Prop\_ptr self, Set\_t cone)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the cone of a property]

  Description        [Stores the cone of influence of the property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Prop\_Type Prop\_get\_type(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the property type]

  Description        [Returns the property kind of the stroed
  property, i.e. CTL, LTL, ...]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Prop\_Status Prop\_get\_status(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the status of the property]

  Description        [Returns the status of the property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_status(Prop\_ptr self, Prop\_Status s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the status of the property]

  Description        [Sets the status of the property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Prop\_get\_number(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of the property]

  Description        [For COMPUTE properties returns the number resulting
                      from the evaluation of the property.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_number(Prop\_ptr self, int n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the number of the property]

  Description        [Sets the number resulting from the
                      evaluation of the property.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_number\_infinite(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the number of the property to INFINITE]

  Description        [Sets the to INFINITE the number resulting from the
                      evaluation of the property.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_number\_undefined(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the number of the property to UNDEFINED]

  Description        [Sets the to UNDEFINED the number resulting from the
                      evaluation of the property.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Prop\_get\_trace(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the trace number associated to a property]

  Description        [For unsatisfied properties, the trace number of the
                      asscociated counterexample is returned. 0 is
                      returned if no trace is available]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_trace(Prop\_ptr self, int t)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the trace number]

  Description        [Sets the trace number for an unsatisfied property.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Prop\_get\_index(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the index of a property]

  Description        [Returns the unique identifier of a property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_index(Prop\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the index of a property]

  Description        [Sets the unique identifier of a property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Prop\_get\_name(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the name of a property]

  Description        [Get the property name]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* Prop\_get\_name\_as\_string(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Gets the name of a property as a string]

  Description        [Get the property name as a string, must be freed]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_name(const Prop\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the name of a property]

  Description        [Sets the name of a property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SexpFsm\_ptr Prop\_compute\_ground\_sexp\_fsm (const Prop\_ptr self, const FsmBuilder\_ptr builder, const SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes ground scalar sexp fsm for property \"self\"]

  Description []

  SideEffects [Ground sexp fsm is computed (taking COI into account if
  needed) and registered into self.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddFsm\_ptr Prop\_compute\_ground\_bdd\_fsm (const Prop\_ptr self, const FsmBuilder\_ptr builder)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes ground bdd fsm for property \"self\"]

  Description []

  SideEffects [Ground bdd fsm is computed (taking COI into account if
  needed) and registered into self.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BeFsm\_ptr Prop\_compute\_ground\_be\_fsm (const Prop\_ptr self, const FsmBuilder\_ptr builder)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes ground be fsm for property \"self\"]

  Description [Ground be fsm is computed (taking COI into account if
  needed) and registered into self.]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SexpFsm\_ptr Prop\_get\_scalar\_sexp\_fsm(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the scalar FSM of a property]

  Description        [Returns the scalar FSM associated to the
                      property. Self keeps the ownership of the
                      given fsm]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_scalar\_sexp\_fsm(Prop\_ptr self, SexpFsm\_ptr fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the scalar FSM of a property]

  Description        [The given fsm will be duplicated, so the caller keeps
                      the ownership of fsm]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BoolSexpFsm\_ptr Prop\_get\_bool\_sexp\_fsm(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the boolean FSM of a property]

  Description        [Returns the boolean FSM associated to the
                      property. Self keeps the ownership of the
                      given fsm]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_bool\_sexp\_fsm(Prop\_ptr self, BoolSexpFsm\_ptr fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the boolean FSM of a property]

  Description        [The given fsm will be duplicated, so the caller
                      keeps the ownership of fsm]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddFsm\_ptr Prop\_get\_bdd\_fsm(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the BDD FSM of a property]

  Description        [Returns the BDD FSM associated to the property. Self
                      keeps the ownership of the given fsm]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_bdd\_fsm(Prop\_ptr self, BddFsm\_ptr fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the boolean FSM in BDD of a property]

  Description        [The given fsm will be duplicated, so the caller
                      keeps the ownership of fsm]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BeFsm\_ptr Prop\_get\_be\_fsm(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the BE FSM  of a property]

  Description        [Returns the boolean BE FSM associated to the
                      property. Self keeps the ownership of the
                      given fsm]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_set\_be\_fsm(Prop\_ptr self, BeFsm\_ptr fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the boolean BE FSM of a property]

  Description        [The given fsm will be duplicated, so the caller keeps
                      the ownership of fsm]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Prop\_needs\_rewriting(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Check if the given property needs rewriting to be
                       checked ]

  Description        [ Returns true if the property needs rewriting,
                       false otherwise]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Prop\_compute\_cone(Prop\_ptr self, FlatHierarchy\_ptr hierarchy, SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the COI for the given property]

  Description        [Computes the COI for the given property.
                      The caller should free the returned set]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_apply\_coi\_for\_scalar(Prop\_ptr self, FsmBuilder\_ptr helper, FlatHierarchy\_ptr hierarchy, SymbTable\_ptr symb\_table)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies cone of influence to the given property]

  Description        [The COI is applied only on the scalar FSM]

  SideEffects        [Internal Scalar FSM is computed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_apply\_coi\_for\_bdd(Prop\_ptr self, FsmBuilder\_ptr helper)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies cone of influence to the given property]

  Description        [The COI is applied only for BDD-based model
                      checking.  To apply for BMC, use
                      Prop_apply_coi_for_bmc. If psl2core is false,
                      then the PSL property is only expanded to
                      remove forall, otherwise it is converted into LTL.]

  SideEffects        [Internal FSMs are computed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_apply\_coi\_for\_bmc(Prop\_ptr self, FsmBuilder\_ptr helper)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies cone of influence to the given property]

  Description        [The COI is applied only for BMC-based model
                      checking.  To apply for BDD, use
                      Prop_apply_coi_for_bdd. This method creates a
                      new layer for those determinization vars that
                      derives from the booleanization of the fsm
                      deriving from the property cone. That layer
                      will be committed to the BoolEnc and BeEnc
                      encodings only, not to the BddEnc. The newly
                      created layer will be assigned to a name that
                      depends on the property number within the
                      database DbProp. If psl2core is false, then
                      the PSL property is only expanded to remove
                      forall, otherwise it is converted into LTL.]

  SideEffects        [Internal FSMs are computed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Prop\_destroy\_coi\_for\_bmc(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Cleans up part of the stuff generated by
                      Prop_apply_coi_for_bmc]

  Description        [Removes the layer created by Prop_apply_coi_for_bmc
                      from be_enc, bdd_enc, and bool_enc and
                      destroys layer. Fsms are assumed to be
                      destroyed upon destroying the property.]

  SideEffects        [Prop_apply_coi_for_bmc]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* Prop\_get\_number\_as\_string(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number value as a string (only for compute
  types)]

  Description        [Returns a number, 'Inifinite' or 'Unchecked'. The
                      returned string is dynamically created, and
                      caller must free it.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* Prop\_get\_context\_text(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the context name of a property]

  Description        [If the property has no explicit context, 'Main' will
                      be returned. The returned string must be
                      deleted by the caller.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* Prop\_get\_text(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the property text, with no explicit context]

  Description        [The returned string must be deleted by the caller.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL const char* Prop\_get\_type\_as\_string(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the a string associated to a property type]

  Description        [Returns the string corresponding to a property type
                      for printing it. Returned string must NOT be
                      deleted]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Prop\_get\_status\_as\_string(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the a string associated to a property status]

  Description        [Returns the string corresponding to a property
                      status for printing it. The caller must NOT
                      free the returned string, dince it is a
                      constant.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Prop\_check\_type(const Prop\_ptr self, Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if a property in the database is of a given type]

  Description        [Checks if a property in the database is of a given
                      type.  If the type is correct, value 0 is
                      returned, otherwise an error message is
                      emitted and value 1 is returned.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void Prop\_verify(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Verifies a given property]

  Description        [Depending the property, different model checking
                      algorithms are called. The status of the
                      property is updated accordingly to the result
                      of the verification process.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void Prop\_print(const Prop\_ptr self, FILE* file, Prop\_PrintFmt fmt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a property]

  Description        [Prints a property.  PSL properties are specially
  handled.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void Prop\_print\_db(const Prop\_ptr self, FILE* file, PropDb\_PrintFmt fmt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a property with info or its position and status
                      within the database]

  Description        [Prints a property on the specified FILE stream. Some
                      of the information stored in the property
                      structure are printed out (e.g. property,
                      property kind, property status, ...).

                      The property is printed in the given format. Use
                      PROPDB_PRINT_FMT_DEFAULT for a default format.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Prop\_is\_psl\_ltl(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the property is PSL property and it
  is LTL compatible]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Prop\_is\_psl\_obe(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the property is PSL property and it
  is CTL compatible]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_init(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Prop class private initializer]

  Description        [The Prop class private initializer]

  SideEffects        []

  SeeAlso            [Prop_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_deinit(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Prop class private deinitializer]

  Description        [The Prop class private deinitializer]

  SideEffects        []

  SeeAlso            [Prop_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr prop\_get\_expr(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the property as it has been parsed and created]

  Description [Returns the property stored in the prop. If the
  property is PSL, the result should be converted to core symbols
  before model checking (see Prop_get_expr_core or
  PslNode_convert_psl_to_core).]

  SideEffects        []

  SeeAlso            [Prop_get_expr_core]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* prop\_get\_type\_as\_string(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [ Returns the a string associated to the propertys type. ]

  Description [ Returns the string corresponding to the propertys type
                for printing it. Returned string must NOT be
                deleted. ]

  SideEffects [ ]

  SeeAlso     [ ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_print(const Prop\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a property]

  Description        [Prints a property. PSL properties are specially
  handled.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_print\_truncated(const Prop\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a property]

  Description        [Prints a property. PSL properties are specially
  handled. The formula is truncated after the first 40 characters]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_print\_db\_tabular(const Prop\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a property with info or its position and status
  within the database]

  Description        [Prints a property on the specified FILE
  stream. Some of the information stored in the property structure are
  printed out (e.g. property, property kind, property status, ...).]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_print\_db\_xml(const Prop\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints a property with info or its position and status
  within the database, in XML format]

  Description [Prints a property on the specified FILE stream, in XML
  format. Some of the information stored in the property structure are
  printed out (e.g. property, property kind, property status, ...).]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_verify(Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Verifies a given property]

  Description        [Depending the property, different model checking
                      algorithms are called. The status of the
                      property is updated accordingly to the result
                      of the verification process.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* PropType\_to\_string(const Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the a string associated to a property type]

  Description        [Returns the string corresponding to a property type
                      for printing it. Returned string must NOT be
                      deleted]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_set\_scalar\_sexp\_fsm(Prop\_ptr self, SexpFsm\_ptr fsm, const boolean duplicate)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_set\_bool\_sexp\_fsm(Prop\_ptr self, BoolSexpFsm\_ptr fsm, const boolean duplicate)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_set\_bdd\_fsm(Prop\_ptr self, BddFsm\_ptr fsm, const boolean duplicate)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_set\_be\_fsm(Prop\_ptr self, BeFsm\_ptr fsm, const boolean duplicate)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void prop\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The Prop class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr prop\_get\_expr\_core\_for\_coi(const Prop\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        [Derived from Prop_get_expr_core, but for PSL only
                      removes forall replicators rather than
                      converting the whole expression into
                      LTL. Written to be used with
                      Prop_apply_coi_for_{bdd,bmc}.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PropDb.c}
		
	\texttt{PropDb\_ptr PropDb\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PropDb class constructor]

  Description        [The PropDb class constructor]

  SideEffects        []

  SeeAlso            [PropDb_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_destroy(PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PropDb class destructor]

  Description        [The PropDb class destructor]

  SideEffects        []

  SeeAlso            [PropDb_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_clean(PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Disposes the DB of properties]

  Description        [Disposes the DB of properties]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int PropDb\_fill(PropDb\_ptr self, SymbTable\_ptr symb\_table, node\_ptr ctlspec, node\_ptr computespec, node\_ptr ltlspec, node\_ptr pslspec, node\_ptr invarspec)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Fills the DB of properties]

  Description        [Given for each kind of property a list of
  respective formulae, this function is responsible to fill the DB with
  them. Returns 1 if an error occurred, 0 otherwise]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean PropDb\_add(PropDb\_ptr self, Prop\_ptr p)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inserts a property in the DB of properties]

  Description        [Insert a property in the DB of properties.
  If not previously set, sets the property index.
  Returns true if out of memory]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL int PropDb\_prop\_create\_and\_add(PropDb\_ptr self, SymbTable\_ptr symb\_table, node\_ptr spec, Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inserts a property in the DB of properties]

  Description        [Given a formula and its type, a property is
  created and stored in the DB of properties. It returns either -1 in
  case of failure, or the index of the inserted property.
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Prop\_ptr PropDb\_get\_last(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the last entered property in the DB]

  Description        [Returns the last entered property in the DB of
                      properties.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Prop\_ptr PropDb\_get\_prop\_at\_index(const PropDb\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the property indexed by index]

  Description        [Returns the property whose unique identifier is
  provided in input. Returns NULL if not found.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int PropDb\_get\_prop\_name\_index(const PropDb\_ptr self, const node\_ptr name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the property with the given name]

  Description        [Returns the property with the given name, rapresented
                      as flattened nodes hierarchy, -1 if not found.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int PropDb\_get\_size(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the size of the DB]

  Description        [Returns the size (i.e. the number of entries)
  stored in the DB of properties.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Prop\_ptr PropDb\_get\_master(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the master property]

  Description        [Returned property does NOT belong to the caller]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Prop\_ptr PropDb\_set\_master(PropDb\_ptr self, Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the master property]

  Description        [Passed property no-longer belongs to the caller.
  Returns the previoulsy set property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SexpFsm\_ptr PropDb\_master\_get\_scalar\_sexp\_fsm(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the scalar FSM]

  Description        [Returns the scalar FSM stored in the master
                      property. Returned instance DOES not belong
                      to the caller.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_master\_set\_scalar\_sexp\_fsm(PropDb\_ptr self, SexpFsm\_ptr fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the scalar FSM]

  Description        [Set the scalar FSM of the master prop. This method
                      destroys the previously set FSM if any. self
                      becomes the owner of the fsm, and the passed
                      fsm no longer belongs to the caller.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BoolSexpFsm\_ptr PropDb\_master\_get\_bool\_sexp\_fsm(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the boolean FSM in sexp]

  Description [Returns the boolean FSM in sexp stored in the master
  prop. self becomes the owner of the given fsm. The
  returned value may be NULL when coi is enabled]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_master\_set\_bool\_sexp\_fsm(PropDb\_ptr self, BoolSexpFsm\_ptr fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the boolean FSM in sexp]

  Description        [Set the boolean FSM in sexp of the master prop. The
  prop package becomes the owner of the given fsm. This method
  destroys the previously set FSM if any.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddFsm\_ptr PropDb\_master\_get\_bdd\_fsm(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the boolean FSM in BDD]

  Description        [Returns the boolean FSM in BDD stored in the master
                      prop. The returned value may be NULL when coi
                      is enabled. Returned fsm belongs to self, and
                      NOT to the caller.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_master\_set\_bdd\_fsm(PropDb\_ptr self, BddFsm\_ptr fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the boolean FSM in BDD]

  Description        [Set the boolean FSM in BDD of the master prop. self
                      becomes the owner of the given fsm. This
                      method destroys the previously set FSM if any.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BeFsm\_ptr PropDb\_master\_get\_be\_fsm(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the boolean FSM in BE]

  Description        [Returns the boolean FSM in BE stored in the master
                      prop. The returned value may be NULL when coi
                      is enabled. Returned fsm belongs to self]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_master\_set\_be\_fsm(PropDb\_ptr self, BeFsm\_ptr fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set the boolean FSM in BE]

  Description        [Set the boolean FSM in BE of the master prop. self
                      becomes the owner of the given fsm. This
                      method destroys the previously set FSM if any.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void PropDb\_set\_fsm\_to\_master(PropDb\_ptr self, Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copies master prop FSM data into prop]

  Description        [Copies the FSM informations stored in the master
  prop into the corresponding fields of the given prop structure.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PropDb\_PrintFmt PropDb\_get\_print\_fmt(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the currently set print format]

  Description        [When printing, the currenlty set format is used.]

  SideEffects        []

  SeeAlso            [PropDb_set_print_fmt]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PropDb\_PrintFmt PropDb\_set\_print\_fmt(const PropDb\_ptr self, PropDb\_PrintFmt new\_fmt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the current print format]

  Description        [When printing, the given format will be used.
  Returns the previously set format.]

  SideEffects        []

  SeeAlso            [PropDb_get_print_fmt]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_print\_list\_header(const PropDb\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the header of the property list]

  Description        [This method has to be called before
  PropDb_print_list_footer.]

  SideEffects        [PropDb_print_list_footer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_print\_list\_footer(const PropDb\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the footer of the property list]

  Description        [This method has to be called after
  PropDb_print_list_header.]

  SideEffects        [PropDb_print_list_header]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int PropDb\_print\_prop\_at\_index(const PropDb\_ptr self, FILE* file, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the specified property from the DB]

  Description        [Prints on the given file stream the property
  whose unique identifier is specified]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_print\_all(const PropDb\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints all the properties stored in the DB]

  Description        [Prints on the given file stream all the property
  stored in the DB of properties.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_print\_all\_status\_type(const PropDb\_ptr self, FILE* file, Prop\_Status status, Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints all the properties stored in the DB]

  Description        [Prints on the given file stream all the property
  stored in the DB of properties whose type and status match the
  requested ones. Prop_NoStatus and Prop_NoType serve as wildcards.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_print\_all\_type(const PropDb\_ptr self, FILE* file, Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints all the properties stored in the DB]

  Description        [Prints on the given file stream all the property
  stored in the DB of properties whose type match the requested one.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_print\_all\_status(const PropDb\_ptr self, FILE* file, Prop\_Status status)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints all the properties stored in the DB]

  Description        [Prints on the given file stream all the property
  stored in the DB of properties whose status match the requested one.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList PropDb\_get\_ordered\_props\_of\_type(const PropDb\_ptr self, const FlatHierarchy\_ptr hierarchy, const Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return the list of properties of a given type,
                      ordered by COI size]

  Synopsis           [Given a property type returns the list of properties
  of that type currently located into the property database]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{lsList PropDb\_get\_props\_of\_type(const PropDb\_ptr self, const Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return the list of properties of a given type]

  Synopsis           [Given a property type returns the list of properties
  of that type currently located into the property database]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int PropDb\_prop\_parse\_and\_add(const PropDb\_ptr self, SymbTable\_ptr symb\_table, const char* str, const Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Add a property to the database from a string and a type]

  Description        [Parses and creates a property of a given type from
  a string. If the formula is correct, it is added to the
  property database and its index is returned.
  Otherwise, -1 is returned.
  Valid types are Prop_Ctl, Prop_Ltl, Prop_Psl, Prop_Invar and Prop_Compute.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int PropDb\_prop\_parse\_name(const PropDb\_ptr self, const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a string representing a property name,
                      returns the property index, if it exists]

  Description        [Parses the given name, builds it's node_ptr
                      interpretation and looks into the PropDb if the
                      property exists.]

  SideEffects        []

  SeeAlso            [PropDb_get_prop_name_index]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int PropDb\_get\_prop\_index\_from\_string(const PropDb\_ptr self, const char* idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get a valid property index from a string]

  Description        [Gets the index of a property form a string.
  If the string does not contain a valid index, an error message is emitted
  and -1 is returned.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int PropDb\_get\_prop\_index\_from\_trace\_index(const PropDb\_ptr self, const int trace\_idx)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the index of the property associated to a trace.]

  Description        [Returns the index of the property associated to a trace.
  -1 if no property is associated to the given trace.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_verify\_prop\_at\_index(const PropDb\_ptr self, const int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************
  Synopsis           [Verifies a given property]

  Description        [The DB of properties is searched for a property
  whose unique identifier match the identifier provided and then if
  such a property exists it will be verified calling the appropriate
  model checking algorithm. If the property was checked before, then
  the property is not checked again.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_verify\_all\_type(const PropDb\_ptr self, Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Verifies all properties of a given type]

  Description        [The DB of properties is searched for a property
  of the given type. All the found properties are then verified
  calling the appropriate model checking algorithm. Properties already
  checked will be ignored.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void PropDb\_verify\_all(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Verifies all the properties in the DB]

  Description        [All the properties stored in the database not
  yet verified will be verified. The properties are verified following
  the order CTL/COMPUTE/LTL/INVAR.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_ordered\_verify\_all(const PropDb\_ptr self, const FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Verifies all the properties in the DB]

  Description        [All the properties stored in the database not
  yet verified will be verified. The properties are verified following
  the COI size order (from smaller to bigger)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropDb\_ordered\_verify\_all\_type(const PropDb\_ptr self, const FlatHierarchy\_ptr hierarchy, const Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Verifies all properties of a given type, ordered by COI
                      size]

  Description        [The DB of properties is searched for a property
  of the given type. All the found properties are then verified
  calling the appropriate model checking algorithm. Properties already
  checked will be ignored. Properties found with the given type are checked
  in order, based on the COI size. If type is Prop_NoType, all properties
  are checked]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr PropDb\_get\_ordered\_properties(const PropDb\_ptr self, const FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the list of properties ordered by COI size]

  Description        [Get the list of properties ordered by COI size.

                      List elements are couples made using cons: the
                      car part points to the property, while the cdr
                      part points to the COI. The list and it's
                      elements (cons nodes and COI sets) should be
                      freed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr PropDb\_get\_coi\_grouped\_properties(const PropDb\_ptr self, const FlatHierarchy\_ptr hierarchy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the list of properties, grouped by COI]

  Description        [Get the list of properties, grouped by COI.
                      A list of couples is returned. The left part of
                      the couple is the COI (represented as a
                      Set_t). The right part of the couple is a Set
                      containing all properties with that COI.  The
                      returned list is ordered by COI size.  The list,
                      all couples and all sets should be freed by the
                      caller ]

  SideEffects        []

  SeeAlso            [PropDb_get_ordered_properties]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_db\_init(PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PropDb class private initializer]

  Description        [The PropDb class private initializer]

  SideEffects        []

  SeeAlso            [PropDb_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_db\_deinit(PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PropDb class private deinitializer]

  Description        [The PropDb class private deinitializer]

  SideEffects        []

  SeeAlso            [PropDb_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int prop\_db\_prop\_create\_and\_add(PropDb\_ptr self, SymbTable\_ptr symb\_table, node\_ptr spec, Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inserts a property in the DB of properties]

  Description        [Given a formula and its type, a property is
  created and stored in the DB of properties. It returns either -1 in
  case of failure, or the index of the inserted property.
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_db\_set\_fsm\_to\_master(PropDb\_ptr self, Prop\_ptr prop)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copies master prop FSM data into prop]

  Description        [Copies the FSM informations stored in the master
  prop into the corresponding fields of the given prop structure.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void prop\_db\_verify\_all(const PropDb\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Verifies all the properties in the DB]

  Description        [All the properties stored in the database not
  yet verified will be verified. The properties are verified following
  the order CTL/COMPUTE/LTL/INVAR.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void prop\_db\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The PropDb class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int prop\_db\_prop\_parse\_from\_arg\_and\_add(PropDb\_ptr self, SymbTable\_ptr symb\_table, int argc, const char** argv, const Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Add a property to the database from an arg structure
  and a type]

  Description        [Parses and creates a property of a given type from
  an arg structure. If the formula is correct, it is added to the
  property database and its index is returned.
  Otherwise, -1 is returned.
  Valid types are Prop_Ctl, Prop_Ltl, Prop_Psl, Prop_Invar and Prop_Compute.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static const char* prop\_db\_get\_prop\_type\_as\_parsing\_string(PropDb\_ptr self, const Prop\_Type type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the parsing type given the property type]

  Description        [Returns the parsing type given the property type.
  The returned string must NOT be freed.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{propCmd.c}
		
	\texttt{void PropPkg\_init\_cmd(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initiliaze the prop package for commands]

  Description [Initialize the prop package for commands.  This must be
  called independently from the package initialization function]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropPkg\_quit\_cmd(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Quit the prop package for commands]

  Description        [This must be called independently from
  the package initialization function]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandShowProperty(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Shows the currently stored properties]

  CommandName        [show_property]

  CommandSynopsis    [Shows the currently stored properties]

  CommandArguments   [\[-h\] \[\[-c | -l | -i | -q\] \[-u | -t | -f\]\]
  | \[-n property_number\] | \[-P property_name\] | \[-s\] 
  \[-m | -o output-file\] \[-F format\]]

  CommandDescription [
  Shows the properties currently stored in the list of properties. This list
  is initialized with the properties (CTL, LTL, INVAR, COMPUTE) present
  in the input file, if any; then all of the properties added by the user
  with the relative <tt>check</tt> or <tt>add_property<\tt> commands are appended
  to this list.
  For every property, the following informations are displayed:
  <ul>
  <li>the identifier of the property (a progressive number);
  <li>the property formula;
  <li>the type (CTL, LTL, INVAR, COMPUTE)
  <il>the status of the formula (Unchecked, True, False) or the result of the
  quantitative expression, if any (it can be infinite);
  <li>if the formula has been found to be false, the number of the
  corresponding counterexample trace.
  </ul>
  By default, all the properties currently stored in the list of properties
  are shown. Specifying the suitable options, properties with a certain
  status (Unchecked, True, False) and/or of a certain type (e.g. CTL,
  LTL), or with a given identifier, it is possible to let the system show a
  restricted set of properties. It is allowed to insert only one option
  per status and one option per type.
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-c</tt>
       <dd> Prints only CTL properties.
    <dt> <tt>-l</tt>
       <dd> Prints only LTL properties.
    <dt> <tt>-i</tt>
       <dd> Prints only INVAR properties.
    <dt> <tt>-q</tt>
       <dd> Prints only quantitative (COMPUTE) properties.
    <dt> <tt>-u</tt>
       <dd> Prints only unchecked properties.
    <dt> <tt>-t</tt>
       <dd> Prints only those properties found to be true.
    <dt> <tt>-f</tt>
       <dd> Prints only those properties found to be false.
    <dt> <tt>-n property-number</tt>
       <dd> Prints out the property numbered <tt>property-number</tt>.
    <dt> <tt>-P property-name</tt>
       <dd> Prints out the property named <tt>property-name</tt>.
    <dt> <tt>-m</tt>
       <dd> Pipes the output through the program specified by the
       <tt>PAGER</tt> shell variable if defined, else through the
       <tt>UNIX</tt> "more" command.
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command to <tt>output-file<\tt>.
    <dt> <tt>-F format</tt>
       <dd> print with given format. Use -F help to see available formats.
    <dt> <tt>-s Prints the number of stored properties. </tt>
       <dd> <\tt>.
  </dl>]

  SideEffects        []

  SeeAlso            [add_property check_spec check_ltlspec check_invar compute]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandAddProperty (int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a property to the list of properties]

  CommandName        [add_property]

  CommandSynopsis    [Adds a property to the list of properties]

  CommandArguments   [\[-h\] \[(-c | -l | -i | -q | -s) -p "formula \[IN context\]"\] \[-n "name"\]]

  CommandDescription [
  Adds a property in the list of properties. It is possible to insert
  LTL, CTL, INVAR, PSL and quantitative (COMPUTE) properties. Every
  newly inserted property is initialized to unchecked. A type option
  must be given to properly execute the command.
  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-c</tt>
       <dd> Adds a CTL property.
    <dt> <tt>-l</tt>
       <dd> Adds an LTL property.
    <dt> <tt>-i</tt>
       <dd> Adds an INVAR property.
    <dt> <tt>-s</tt>
       <dd> Adds a PSL property.
    <dt> <tt>-q</tt>
       <dd> Adds a quantitative (COMPUTE) property.
    <dt> <tt>-p "formula \[IN context\]"</tt>
       <dd> Adds the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
    <dt> <tt>-n name</tt>
       <dd> Names the added property as "name"
  </dl>]

  SeeAlso            [show_property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandCheckProperty (int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks properties]

  CommandName        [check_property]

  CommandSynopsis    [Checks a property into the current list of properties,
  or a newly specified property]

  CommandArguments   [\[-h\] \[-n number | -P "name"\] | \[(-c | -l | -i | -s | -q )
  \[-p "formula \[IN context\]"\]\] ]

  CommandDescription [
  Checks the specified property taken from the property list, or adds
  the new specified property and checks it.

  <p>
  Command options:<p>
  <dl>
    <dt> <tt>-h</tt>
       <dd> Prints the help.
    <dt> <tt>-c</tt>
       <dd> Checks all the CTL properties not already checked
    <dt> <tt>-l</tt>
       <dd> Checks all the LTL properties not already checked
    <dt> <tt>-i</tt>
       <dd> Checks all the INVAR properties not already checked
    <dt> <tt>-s</tt>
       <dd> Checks all the PSL properties not already checked
    <dt> <tt>-q</tt>
       <dd> Checks all the COMPUTE properties not already checked
    <dt> <tt>-n number</tt>
       <dd> Checks the property with id <tt>number</tt> in the
            property list if it exists.
    <dt> <tt>-P name</tt>
       <dd> Checks the property named <tt>named</tt> in the
            property list if it exists.
    <dt> <tt>-p "formula \[IN context\]"</tt>
       <dd> Checks the <tt>formula</tt> specified on the command-line. <BR>
            <tt>context</tt> is the module instance name which the variables
            in <tt>formula</tt> must be evaluated in.
  </dl>
  If no property has been specified via <tt>-n</tt> or <tt>-p</tt> or <tt>-P</tt>,
  then all the properties (of a given type) in the property list will be
  evaluated.]

  SeeAlso            [check_property]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{propPkg.c}
		
	\texttt{void PropPkg\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the package: master property and 
  property database are allocated]

  Description        [After you had called this, you must also call 
  PropPkg_init_cmd if you need to use the interactive shell for 
  commands]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropPkg\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Quits the package]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PropDb\_ptr PropPkg\_get\_prop\_database()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the global property database instance]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void PropPkg\_set\_prop\_database(PropDb\_ptr db)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the global property database instance]

  Description        [Simply overwrites global_prop_database with a new
  value. Hence, caller is responsible for freeing
  global_prop_database before calling this function. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\section{rbc}
		
	\section{clg}
		
	\subsection{clgClg.c}
		
	\texttt{clause\_graph Clg\_Lit(int literal)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create a CLG representing a single literal]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{clause\_graph Clg\_Conj(clause\_graph left, clause\_graph right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create a CLG representing a conjunction of two CLGs]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{clause\_graph Clg\_Disj(clause\_graph left, clause\_graph right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create a CLG representing a disjunction of two CLGs]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Clg\_Size(clause\_graph graph)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return the number of clauses stored in the CLG]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Clg\_Free(clause\_graph graph)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Free all CLGs]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Clg\_Extract(clause\_graph head, int type, Clg\_Commit commit, void *data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Extract the real clauses from the CLG]

  Description        [Calls commit with each extracted clause as an argument.
                      type indicates the style of clause (eg, ZChaff 
		      all-positive integer format); *data is passed to commit
		      as an extra argument.

		      Clauses have duplicated literals suppressed and
		      clauses with both positive and negative
		      occurrences of the same literal are skipped.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void Extract(clause\_graph head, node\_ptr follow, int clause\_size, int type, Clg\_Commit commit, void *data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Extract the clauses, passing them to commit]

  Description        [Walk the data structure from the head, creating clauses 
                      each time one is seen complete. See Footnote 936 for 
		      details of algorithm]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int AddToClause(int pos\_lit, int neg\_lit, int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Insert a literal into the current clause]

  Description [Insert pos_lit, where neg_lit is the corresponding
               literal of opposite polarity. If neg_lit is already in
               the clause then the clause is cancelled; if pos_lit is
               already in the clause then it is not reinserted.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static clause\_graph new\_clg(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Allocate a new CLG node.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ConjSet.c}
		
	\texttt{ConjSet\_ptr ConjSet\_create(Rbc\_Manager\_t* rbcm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjSet class constructor]

  Description        [The ConjSet class constructor]

  SideEffects        []

  SeeAlso            [ConjSet_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ConjSet\_ptr ConjSet\_copy(const ConjSet\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy constructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ConjSet\_destroy(ConjSet\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjSet class destructor]

  Description        [The ConjSet class destructor]

  SideEffects        []

  SeeAlso            [ConjSet_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ConjSet\_add\_var\_assign(ConjSet\_ptr self, Rbc\_t* var, Rbc\_t* expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a new variable assignment to set]

  Description [Will be kept onlt if 'better' then the possibly
  previous assigment]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ConjSet\_inherit\_from(ConjSet\_ptr self, const ConjSet\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Inherits as much as possible (provided that what it
  inherits is not worse than what it has collected so far) from the given
  ConjSet]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ConjSet\_flattenize(ConjSet\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes the ConjSet flattened.]

  Description [Flattens the ConjSet, making minimal the graph of
  dependencies. A flatten ConjSet can then be used to substitute
  an expression]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* ConjSet\_substitute(ConjSet\_ptr self, Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Substitutes all variables occurring into f that belong
	to self with the corresponding expression.]

  Description [If self was previously flattened, the resulting RBC
	will be flattened as well, but only about those parts that has
	the same language of self]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* ConjSet\_conjoin(ConjSet\_ptr self, Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the conjuction of self with the given formula]

  Description        [Returns a formula like:
	    for all v,exp belonging to self,
          (/\ (v <-> exp)) /\ f
	]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ConjSet\_print(const ConjSet\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints debugging information about self]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void conj\_set\_init(ConjSet\_ptr self, Rbc\_Manager\_t* mgr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjSet class private initializer]

  Description        [The ConjSet class private initializer]

  SideEffects        []

  SeeAlso            [ConjSet_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void conj\_set\_copy(const ConjSet\_ptr self, ConjSet\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjSet class private copy constructor]

  Description        [The ConjSet class private copy constructor]

  SideEffects        []

  SeeAlso            [ConjSet_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void conj\_set\_deinit(ConjSet\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjSet class private deinitializer]

  Description        [The ConjSet class private deinitializer]

  SideEffects        []

  SeeAlso            [ConjSet_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void conj\_set\_flattenize(ConjSet\_ptr self, Rbc\_t* var, hash\_ptr pvars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service for ConjSet_flattenize]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean conj\_set\_insert\_element(ConjSet\_ptr self, Rbc\_t* var, ConjElem\_ptr el)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Inserts 'el' only if it is better then what it has been
  collected so far]

  Description        [Returns true if el has been accepted, false otherwise.
  If false is returned, it is likely that the caller needs to destroy el]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ConjElem\_ptr ConjElem\_create(Rbc\_Manager\_t* mgr, Rbc\_t* expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjElem class constructor]

  Description        [The ConjElem class constructor]

  SideEffects        []

  SeeAlso            [ConjElem_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ConjElem\_destroy(ConjElem\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjElem class destructor]

  Description        [The ConjElem class destructor]

  SideEffects        []

  SeeAlso            [ConjElem_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ConjElem\_ptr ConjElem\_copy(const ConjElem\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy constructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean ConjElem\_is\_smaller(const ConjElem\_ptr self, const ConjElem\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Predicate to decide whether a ConjElem_ptr is better
	than another]

  Description [The better ConjElem has less dependencies that the
  worse]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void conj\_elem\_init(ConjElem\_ptr self, Rbc\_Manager\_t* mgr, Rbc\_t* expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjElem class private initializer]

  Description        [The ConjElem class private initializer]

  SideEffects        []

  SeeAlso            [ConjElem_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void conj\_elem\_deinit(ConjElem\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The ConjElem class private deinitializer]

  Description        [The ConjElem class private deinitializer]

  SideEffects        []

  SeeAlso            [ConjElem_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{InlineResult.c}
		
	\texttt{InlineResult\_ptr InlineResult\_create(Rbc\_Manager\_t* mgr, Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The InlineResult class constructor]

  Description        [The InlineResult class constructor]

  SideEffects        []

  SeeAlso            [InlineResult_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{InlineResult\_ptr InlineResult\_copy(const InlineResult\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The InlineResult class copy constructor]

  Description        [The InlineResult class copy constructor]

  SideEffects        []

  SeeAlso            [InlineResult_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void InlineResult\_destroy(InlineResult\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The InlineResult class destructor]

  Description        [The InlineResult class destructor]

  SideEffects        []

  SeeAlso            [InlineResult_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* InlineResult\_get\_original\_f(InlineResult\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the original formula f that was submitted to
                      the constructor]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* InlineResult\_get\_inlined\_f(InlineResult\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the inlined formula, _without_ the conjuction
  set]

  Description [A lazy approach to SAT can exploit the fact that if
  a model satisfies inlined f, then it satisfies f as well. If a
  counterexample must be shown though, inlined f must be conjuct
  with the conjuction set.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* InlineResult\_get\_inlined\_f\_and\_c(InlineResult\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the inlined f conjucted with the conjuction set]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* InlineResult\_get\_c(InlineResult\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a formula representing the conjuction set]

  Description        [The conjuction set is made into a formula like:

        foreach (v,exp) belonging to the conjuction set,

  (\/ v <-> exp) \/ inlined_f
        ]

  SideEffects        []

  SeeAlso            [ConjSet]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void inline\_result\_init(InlineResult\_ptr self, Rbc\_Manager\_t* rbcm, Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The InlineResult class private initializer]

  Description        [The InlineResult class private initializer]

  SideEffects        []

  SeeAlso            [InlineResult_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void inline\_result\_copy(const InlineResult\_ptr self, InlineResult\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The InlineResult class private copy constructor]

  Description        [The InlineResult class private copy constructor]

  SideEffects        []

  SeeAlso            [InlineResult_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void inline\_result\_calc\_cset(InlineResult\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The InlineResult class private deinitializer]

  Description        [The InlineResult class private deinitializer]

  SideEffects        []

  SeeAlso            [InlineResult_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void inline\_result\_deinit(InlineResult\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The InlineResult class private deinitializer]

  Description        [The InlineResult class private deinitializer]

  SideEffects        []

  SeeAlso            [InlineResult_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int inline\_set(Rbc\_t* f, char* \_data, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Checks for a var assignment and adds it to the conjuction set]

  Description [First, looks for the rbc f in cache and eventually gets the
               previous result.
               Else, checks the symbol of f for an IFF or for its two
               level AND equivalent. In these cases if finds a var assignment
               (one vertex being a VAR and the other not), adds it to the
               conjunction set.
               Returns 1 for backtracking, -1 if it does not need.]

  SideEffects [data->tmp_res is always set, except when the symbol of f is
               RBCVAR or a not negated RBCAND.
               if a var assignment is found, _data->res->conj is updated.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void inline\_first(Rbc\_t* f, char* \_data, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [DFS private function]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void inline\_back(Rbc\_t* f, char* \_data, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [DFS private function]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void inline\_last(Rbc\_t* f, char* \_data, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [DFS private function]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcCnf.c}
		
	\texttt{int Rbc\_Convert2Cnf(Rbc\_Manager\_t* rbcManager, Rbc\_t* f, int polarity, Slist\_ptr clauses, Slist\_ptr vars, int* literalAssignedToWholeFormula)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Translates the rbc into the corresponding (equisatisfiable)
               set of clauses.]

  Description [This calls the user's choice of translation procedure]

  SideEffects [`clauses' and `vars' are filled up. `clauses' is the empty
               list if `f' was true, and contains a single empty clause if
               `f' was false. 'polarity' is used to determine if the clauses
               generated should represent the RBC positively, negatively, or
               both (1, -1 or 0 respectively). For an RBC that is known to be
               true, the clauses that represent it being false are not needed
               (they would be removed anyway by propogating the unit literal
               which states that the RBC is true). Similarly for when the RBC
               is known to be false. This parameter is only used with the
               compact cnf conversion algorithm, and is ignored if the simple
               algorithm is used.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Rbc\_CnfVar2RbcIndex(Rbc\_Manager\_t* rbcManager, int cnfVar)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the RBC index corresponding to a particular CNF var]

  Description [Returns -1, if there is no original RBC variable
  corresponding to CNF variable, this may be the case if CNF variable
  corresponds to an internal node (not leaf) of RBC tree. Input CNF
  variable should be a correct variable generated by RBC manager.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Rbc\_RbcIndex2CnfVar(Rbc\_Manager\_t* rbcManager, int rbcIndex)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the associated CNF variable of a given RBC index]

  Description [Returns 0, if there is no original RBC variable
  corresponding to CNF variable. This may be the case if particular RBC
  node (of the given variable) has never been converted into CNF]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Rbc\_get\_node\_cnf(Rbc\_Manager\_t* rbcm, Rbc\_t* f, int* maxvar)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Given a rbc node, this function returns the corrensponding
  CNF var if it had been already allocated one. Otherwise it will allocate a
  new CNF var and will increment given maxvar value. If f is RBCDUMMY,
  a new variable will be always allocated (intended to be a non-terminal var,
  but a corresponding RBC var will be not allocated)]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_2CnfAlgorithm Rbc\_CnfConversionAlgorithmFromStr(const char * str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Conversion from string to CNF conversion algorithm enumerative]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char * Rbc\_CnfConversionAlgorithm2Str(Rbc\_2CnfAlgorithm algo)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Conversion from CNF conversion algorithm enumerative to string]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char * Rbc\_CnfGetValidRbc2CnfAlgorithms()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [String of valid conversion algorithms]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcCnfCompact.c}
		
	\texttt{int Rbc\_Convert2CnfCompact(Rbc\_Manager\_t* rbcManager, Rbc\_t* f, int polarity, Slist\_ptr clauses, Slist\_ptr vars, int* literalAssignedToWholeFormula)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Translates the rbc into the corresponding (equisatisfiable)
               set of clauses.]

  Description [Given `rbcManager' and `f', `clauses' is filled with the
               disjunctions corresponding to the rbc nodes according to
               the 'compact' algorithm by Dan Sheridan.
               `vars' is filled with the variables that occurred in `f'
               (original or model variables). It is user's responsibility
               to create `clauses' and `vars' *before* calling the function.
               New variables are added by the conversion: the maximum
               index (the last added variable) is returned by the function.
               The function returns 0 when `f' is true or false. 'polarity'
               defines whether 'f' has to be true, false, or either (1, -1
               or 0 respectively). If 'polarity' is 1/-1 then only the
               clauses representing the true/false RBC are returned. Otherwise,
               both sets are returned.]

  SideEffects [`clauses' and `vars' are filled up. `clauses' is the empty
               list if `f' was true, and contains a single empty clause if
               `f' was false.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CnfCompactPolSet(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for CNF conversion.]

  Description [Dfs Set for CNF conversion polarity computation.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfCompactPolFirstBack(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit and BackVisit for CNF conversion.]

  Description [Dfs FirstVisit and BackVisit for CNF conversion polarity
               computation.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CnfCompactSet(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for CNF conversion.]

  Description [Dfs Set for CNF conversion.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfCompactFirst(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for CNF conversion.]

  Description [Dfs FirstVisit for CNF conversion.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfCompactBack(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs BackVisit for CNF conversion.]

  Description [Dfs BackVisit for CNF conversion.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfCompactLast(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for CNF conversion.]

  Description [Dfs LastVisit for CNF conversion.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CnfCompactCleanSet(Dag\_Vertex\_t* f, char* cleanData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for cleaning.]

  Description [Dfs Set for cleaning.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfCompactCleanFirst(Dag\_Vertex\_t* f, char* cleanData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for cleaning.]

  Description [Dfs FirstVisit for cleaning.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfEmpty(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs empty function.]

  Description [Empty function as null operation during DFS]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void rename\_clauses(clause\_graph* clauses, int var, clause\_graph* saved)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Renames a set of clauses.]

  Description [Renames a set of clauses by adding -var to each clause
  and adding each clause to the list of saved clauses. Allocates a new variable
  if var==0. Returns var or the new variable. Refuses to rename a single
  clause; returns 0 in this case]

  SideEffects [clauses refers to the singleton clause set referring to the
  renamed clauses]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void disjunction(clause\_graph* Left, clause\_graph* Right, int* maxVar, clause\_graph* clauses, Rbc\_Manager\_t* rbcm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Compute the disjunction of two clause sets]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void disjunction2(clause\_graph* Left1, clause\_graph* Right1, clause\_graph* Left2, clause\_graph* Right2, int* maxVar, clause\_graph* clauses, Rbc\_Manager\_t* rbcm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Compute the disjunction of two clause sets]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline int testSizes(clause\_graph left, clause\_graph right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Check whether two clause sets are big enough to require renaming]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfCompactCommit(void* data, int* cl, int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Extracts the cnf from the CLG]

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcCnfSimple.c}
		
	\texttt{int Rbc\_Convert2CnfSimple(Rbc\_Manager\_t* rbcManager, Rbc\_t* f, Slist\_ptr clauses, Slist\_ptr vars, int* literalAssignedToWholeFormula)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Translates the rbc into the corresponding (equisatisfiable)
               set of clauses.]

  Description [Given `rbcManager' and `f', `clauses' is filled with the
               disjunctions corresponding to the rbc nodes according to
               the rules:

               f = A & B => -f A              f = A <-> B =>  f  A  B
                            -f B                              f -A -B
                             f -A -B                         -f -A  B
                                                             -f  A -B

               f = if A then B else C =>  f  A -C
                                          f -A -B
                                         -f  A  C
                                         -f -A  B

               `vars' is filled with the variables that occurred in `f'
               (original or model variables converted into corresponding CNF
               variables). It is user's responsibility
               to create `clauses' and `vars' *before* calling the function.
               New variables are added by the conversion: the maximum
               index is returned by the function.
               The literal associated to 'f' is assigned to parameter
               *literalAssignedToWholeFormula (it may be negative).
               Special case - A CONSTANT (this is consistent with description
                 of Be_Cnf_ptr): if the formula is a constant
                 then *literalAssignedToWholeFormula will be INT_MAX
                 and the return value will 0.
                 if formula is true, `clauses' is the empty list,
                 if formula is false, `clauses' contains a single empty clause.]

  SideEffects [`clauses', `vars' and '*literalAssignedToWholeFormula'
              are filled up. Fields inside rbcManager might change ]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int CnfSet(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for CNF conversion.]

  Description [Dfs Set for CNF conversion.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfFirst(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for CNF conversion.]

  Description [Dfs FirstVisit for CNF conversion.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfBack(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs BackVisit for CNF conversion.]

  Description [Dfs BackVisit for CNF conversion.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void CnfLast(Rbc\_t* f, char* cnfData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for CNF conversion.]

  Description [Dfs LastVisit for CNF conversion.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static lsGeneric SwapSign(lsGeneric data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Swaps the sign of the argument.]

  Description [Swaps the sign of the argument.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcFormula.c}
		
	\texttt{Rbc\_t* Rbc\_GetOne(Rbc\_Manager\_t* rbcManager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Logical constant 1 (truth).]

  Description [Returns the rbc that stands for logical truth.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_GetZero(Rbc\_Manager\_t* rbcManager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Logical constant 0 (falsity).]

  Description [Returns the rbc that stands for logical falsity.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Rbc\_IsConstant(Rbc\_Manager\_t* manager, Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the given rbc is a constant value,
                      such as either False or True]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_GetIthVar(Rbc\_Manager\_t* rbcManager,int varIndex)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a variable.]

  Description [Returns a pointer to an rbc node containing the requested
               variable. Works in three steps:
               <ul>
               <li> the requested variable index exceeds the current capacity:
                    allocated more room up to the requested index;
               <li> the variable node does not exists: inserts it in the dag
                    and makes it permanent;
               <li> returns the variable node.
               </ul>]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_MakeNot(Rbc\_Manager\_t* rbcManager, Rbc\_t* left)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the complement of an rbc.]

  Description [Returns the complement of an rbc.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_MakeAnd( Rbc\_Manager\_t* rbcManager, Rbc\_t* left, Rbc\_t* right, Rbc\_Bool\_c sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Makes the conjunction of two rbcs.]

  Description [Makes the conjunction of two rbcs.
               Works in three steps:
               <ul>
               <li> performs boolean simplification: if successfull, returns
                    the result of the simplification;
               <li> orders left and right son pointers;
               <li> looks up the formula in the dag and returns it.
               </ul>

               If RBC_ENABLE_LOCAL_MINIMIZATION_WITHOUT_BLOWUP is defined,
               applies all the rules proposed in "R. Brummayer and
               A. Biere. Local Two-Level And-Inverter Graph Minimization
               without Blowup". In Proc. MEMICS 2006.  The expressions o1, o2,
               o3, o4 refers to the four level of optimization proposed in the
               paper.  The rules are implemented as macros in order to avoid
               repetitions]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_MakeOr( Rbc\_Manager\_t* rbcManager, Rbc\_t* left, Rbc\_t* right, Rbc\_Bool\_c sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Makes the disjunction of two rbcs.]

  Description [Makes the disjunction of two rbcs: casts the connective to
               the negation of a conjunction using De Morgan's law.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_MakeIff( Rbc\_Manager\_t* rbcManager, Rbc\_t* left, Rbc\_t* right, Rbc\_Bool\_c sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Makes the coimplication of two rbcs.]

  Description [Makes the coimplication of two rbcs.
               Works in four steps:
               <ul>
               <li> performs boolean simplification: if successfull, returns
                    the result of the simplification;
               <li> orders left and right son pointers;
               <li> re-encodes the negation
               <li> looks up the formula in the dag and returns it.

               <li> If the coimplication mode is disable, expands the connective
                    in three AND nodes.
               </ul>]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_MakeXor( Rbc\_Manager\_t* rbcManager, Rbc\_t* left, Rbc\_t* right, Rbc\_Bool\_c sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Makes the exclusive disjunction of two rbcs.]

  Description [Makes the exclusive disjunction of two rbcs: casts the
               connective as the negation of a coimplication.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_MakeIte( Rbc\_Manager\_t* rbcManager, Rbc\_t* i, Rbc\_t* t, Rbc\_t* e, Rbc\_Bool\_c sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Makes the if-then-else of three rbcs.]

  Description [Makes the if-then-else of three rbcs: expands the connective
              into the corresponding product-of-sums.

              If the if-then-else mode is disable, expands the connective in
              three AND nodes]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_GetLeftOpnd(Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the left operand.]

  Description [Gets the left operand.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_GetRightOpnd(Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the right operand.]

  Description [Gets the right operand.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Rbc\_GetVarIndex(Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the variable index.]

  Description [Returns the variable index,
               -1 if the rbc is not a variable.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_Mark( Rbc\_Manager\_t* rbc, Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Makes a node permanent.]

  Description [Marks the vertex in the internal dag. This saves the rbc
               from being wiped out during garbage collection.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_Unmark( Rbc\_Manager\_t* rbc, Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Makes a node volatile.]

  Description [Unmarks the vertex in the internal dag. This exposes the rbc
               to garbage collection.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Rbc\_is\_top(Rbc\_t* rbc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Check if a rbc type is RBCTOP]

  Description [Check if a rbc type is RBCTOP]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Rbc\_is\_and(Rbc\_t* rbc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Check if a rbc type is RBCAND]

  Description [Check if a rbc type is RBCAND]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Rbc\_is\_iff(Rbc\_t* rbc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Check if a rbc type is RBCIFF]

  Description [Check if a rbc type is RBCIFF]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Rbc\_is\_var(Rbc\_t* rbc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Check if a rbc type is RBCVAR]

  Description [Check if a rbc type is RBCVAR]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Rbc\_is\_ite(Rbc\_t* rbc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Check if a rbc type is RBCITE]

  Description [Check if a rbc type is RBCITE]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Rbc\_t* Reduce( Rbc\_Manager\_t* rbcManager, int op, Rbc\_t* left, Rbc\_t* right)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Reduction (simplification) of rbcs.]

  Description [Reduction (simplification) of rbcs.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcInline.c}
		
	\texttt{InlineResult\_ptr RbcInline\_apply\_inlining(Rbc\_Manager\_t* rbcm, Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Calculates the inlining of the given formula]

  Description [Returned InlineResult instance is cached and must be _NOT_ 
	destroyed by the caller]

  SideEffects [None]

  SeeAlso     [InlineResult]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void rbc\_inlining\_cache\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inline caching private service]

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void rbc\_inlining\_cache\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inline caching private service]

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void rbc\_inlining\_cache\_add\_result(Rbc\_t* f, InlineResult\_ptr res)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inline caching private service]

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{InlineResult\_ptr rbc\_inlining\_cache\_lookup\_result(Rbc\_t* f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inline caching private service]

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcManager.c}
		
	\texttt{Rbc\_Manager\_t * Rbc\_ManagerAlloc( int varCapacity )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a new RBC manager.]

  Description [Creates a new RBC manager:
               <ul>
               <li> <i>varCapacity</i> how big is the variable index
                    (this number must be strictly greater than 0) 
               </ul>
               Returns the allocated manager if varCapacity is greater than 0,
               and NIL(Rbc_Manager_t) otherwise.]

  SideEffects [none]

  SeeAlso     [Rbc_ManagerFree]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_ManagerReserve( Rbc\_Manager\_t * rbcManager, int newVarCapacity )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Reserves more space for new variables.]

  Description [If the requested space is bigger than the current one
               makes room for more variables in the varTable.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Rbc\_ManagerCapacity( Rbc\_Manager\_t * rbcManager )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the current variable capacity of the rbc.]

  Description [This number is the maximum number of variables (starting from 0)
               that can be requested without causing any memory allocation.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_ManagerFree( Rbc\_Manager\_t * rbcManager )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deallocates an RBC manager.]

  Description [Frees the variable index and the internal dag manager.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_ManagerReset( Rbc\_Manager\_t * rbcManager )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Resets RBC manager]

  Description []

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_ManagerGC( Rbc\_Manager\_t * rbcManager )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Garbage collection in the RBC manager.]

  Description [Relies on the internal DAG garbage collector.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcOutput.c}
		
	\texttt{void Rbc\_OutputDaVinci( Rbc\_Manager\_t * rbcManager, Rbc\_t * f, FILE * outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Print out an rbc using DaVinci graph format.]

  Description [Print out an rbc using DaVinci graph format.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_OutputSexpr( Rbc\_Manager\_t * rbcManager, Rbc\_t * f, FILE * outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Print out an rbc using LISP S-expressions.]

  Description [Print out an rbc using LISP S-exrpressions.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int DaVinciSet( Rbc\_t * f, char * daVinciData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for DaVinci output.]

  Description [Dfs Set for DaVinci output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void DaVinciFirst( Rbc\_t * f, char * DaVinciData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for DaVinci output.]

  Description [Dfs FirstVisit for DaVinci output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void DaVinciBack( Rbc\_t * f, char * daVinciData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs BackVisit for DaVinci output.]

  Description [Dfs BackVisit for DaVinci output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void DaVinciLast( Rbc\_t * f, char * daVinciData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for DaVinci output.]

  Description [Dfs LastVisit for DaVinci outputon.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int SexprSet( Rbc\_t * f, char * SexprData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for Sexpr output.]

  Description [Dfs Set for Sexpr output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SexprFirst( Rbc\_t * f, char * SexprData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for Sexpr output.]

  Description [Dfs FirstVisit for Sexpr output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SexprBack( Rbc\_t * f, char * SexprData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs BackVisit for Sexpr output.]

  Description [Dfs BackVisit for Sexpr output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SexprLast( Rbc\_t * f, char * SexprData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for Sexpr output.]

  Description [Dfs LastVisit for Sexpr outputon.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_OutputGdl( Rbc\_Manager\_t * rbcManager, Rbc\_t * f, FILE * outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Print out an rbc using Gdl graph format.]

  Description [Print out an rbc using Gdl graph format.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int GdlSet( Rbc\_t * f, char * GdlData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for Gdl output.]

  Description [Dfs Set for Gdl output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void GdlFirst( Rbc\_t * f, char * GdlData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for Gdl output.]

  Description [Dfs FirstVisit for Gdl output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void GdlBack( Rbc\_t * f, char * GdlData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs BackVisit for Gdl output.]

  Description [Dfs BackVisit for Gdl output.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void GdlLast( Rbc\_t * f, char * GdlData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for Gdl output.]

  Description [Dfs LastVisit for Gdl outputon.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcStat.c}
		
	\texttt{void Rbc\_PrintStats( Rbc\_Manager\_t * rbcManager, int clustSz, FILE * outFile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Prints various statistics.]

  Description [Prints various statistics.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcSubst.c}
		
	\texttt{Rbc\_t * Rbc\_Subst(Rbc\_Manager\_t * rbcManager, Rbc\_t * f, int * subst)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a fresh copy G(Y) of the rbc F(X) such 
               that G(Y) = F(X)[Y/X] where X and Y are vectors of
               variables.]

  Description [Given `rbcManager', the rbc `f', and the array of
               integers `subst', replaces every occurence of the
               variable x_i in in `f' with the variable x_j
               provided that subst[i] = j. There is no need for
               `subst' to contain all the variables, but it should
               map at least the variables in `f' in order for the
               substitution to work properly.

               Here the substitution is performed completely at
               physical level (i.e. at the level of pure rbc
               indices). For a substitution at logical level, see
               Rbc_LogicalSubst.

  !!!!!! WARNING   WARNING   WARNING   WARNING   WARNING   WARNING !!!!!
  !!                                                                  !!
  !!  This function cannot be used with the new encoding BeEnc. As    !!
  !!  substitution involves the traversal of the logical layer within !!
  !!  the BeEnc, simple shifting is no longer usable, and will        !!
  !!  produce unpredictable results if used on variables handled by   !!
  !!  a BeEnc instance.                                               !!
  !!                                                                  !!
  !!  Use Rbc_LogicalSubst instead.                                   !!
  !!                                                                  !!
  !!!!!! WARNING   WARNING   WARNING   WARNING   WARNING   WARNING !!!!!

]

  SideEffects [none]

  SeeAlso     [Rbc_LogicalSubst]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_LogicalSubst(Rbc\_Manager\_t* rbcManager, Rbc\_t* f, int* subst, const int* log2phy, const int* phy2log)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a fresh copy G(Y) of the rbc F(X) such 
               that G(Y) = F(X)[Y/X] where X and Y are vectors of
         variables.] 

  Description [Given `rbcManager', the rbc `f', and the array of integers
               `subst', replaces every occurence of the variable
         x_i in in `f' with the variable x_j provided that 
         subst[i] = j. 

         Notice that in this context, 'i' and 'j' are LOGICAL
         indices, not physical, i.e. the substitution array is
         provided in terms of logical indices, and is related
         only to the logical level.

         For a substitution at physical level, see Rbc_Subst.

         There is no need for `subst' to contain all the
         variables, but it should map at least the variables in
         `f' in order for the substitution to work properly.

         The two indices arrays log2phy and phy2log map
         respectively the logical level to the physical level,
         and the physical level to the logical levels. They
         allow the be encoder to freely organize the variables
         into a logical and a physical level. This feature has
         been introduced with NuSMV-2.4 that ships dynamic
         encodings.]

  SideEffects [none]

  SeeAlso     [Rbc_Subst]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_Shift(Rbc\_Manager\_t* rbcManager, Rbc\_t* f, int shift)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a fresh copy G(X') of the rbc F(X) by shifting 
               each variable index of a certain amount.]

  Description [Given `rbcManager', the rbc `f', and the integer `shift',
               replaces every occurence of the variable x_i in in `f' with 
         the variable x_(i + shift).

  !!!!!! WARNING   WARNING   WARNING   WARNING   WARNING   WARNING !!!!!
  !!                                                                  !!
  !!  This function cannot be used with the new encoding BeEnc,       !!
  !!  with NuSMV-2.4. As shifting involves the traversal of the       !!
  !!  logical layer within the                                        !!
  !!  BeEnc, simple shifting is no longer usable, and will produce    !!
  !!  unpredictable results if used on variables handled by a BeEnc   !!
  !!  instance.                                                       !!
  !!                                                                  !!
  !!  Use Rbc_LogicalShiftVar instead.                                !!
  !!                                                                  !!
  !!!!!! WARNING   WARNING   WARNING   WARNING   WARNING   WARNING !!!!!

]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_LogicalShift(Rbc\_Manager\_t* rbcManager, Rbc\_t* f, int shift, const int* log2phy, const int* phy2log)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a fresh copy G(X') of the rbc F(X) by shifting 
               each variable index of a certain amount.]

  Description [Given `rbcManager', the rbc `f', and the integer `shift',
               replaces every occurence of the variable x_i in in `f' with 
         the variable x_(i + shift).

         Notice that in this context, 'i' is a LOGICAL
         index, not physical, i.e. the substitution array is
         provided in terms of logical indices, and is related
         only to the logical level.

         For a substitution at physical level, see Rbc_SubstRbc.
         
         The two indices arrays log2phy and phy2log map
         respectively the logical level to the physical level,
         and the physical level to the logical levels. They
         allow the be encoder to freely organize the variables
         into a logical and a physical level. This feature has
         been introduced with NuSMV-2.4 that ships dynamic
         encodings.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t * Rbc\_SubstRbc( Rbc\_Manager\_t * rbcManager, Rbc\_t * f, Rbc\_t ** substRbc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a fresh copy G(S) of the rbc F(X) such 
               that G(S) = F(X)[S/X] where X is a vector of variables and
         S is a corresponding vector of formulas.] 

  Description [Given `rbcManager', the rbc `f', and the array of rbcs
               `substRbc', replaces every occurence of the variable
         x_i in in `f' with the rbc r_i provided that 
         substRbc[i] = r_i. There is no need for `substRbc' to contain
         all the  variables, but it should map at least the variables
         in `f' in order for the substitution to work properly.

         Here the substitution is performed completely at
         physical level (i.e. at the level of pure rbc
         indices). For a substitution at logical level, see
         Rbc_LogicalSubstRbc.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Rbc\_t* Rbc\_LogicalSubstRbc(Rbc\_Manager\_t* rbcManager, Rbc\_t* f, Rbc\_t** substRbc, int* phy2log)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a fresh copy G(S) of the rbc F(X) such 
               that G(S) = F(X)[S/X] where X is a vector of variables and
         S is a corresponding vector of formulas.] 

  Description [Given `rbcManager', the rbc `f', and the array of rbcs
               `substRbc', replaces every occurence of the variable
         x_i in in `f' with the rbc r_i provided that 
         substRbc[i] = r_i. 

         Notice that in this context, 'i' is a LOGICAL index,
         not physical.

         There is no need for `substRbc' to contain
         all the  variables, but it should map at least the variables
         in `f' in order for the substitution to work properly.

         The two indices arrays log2phy and phy2log map
         respectively the logical level to the physical level,
         and the physical level to the logical levels. They
         allow the be encoder to freely organize the variables
         into a logical and a physical level. This feature has
         been introduced with NuSMV-2.4 that ships dynamic
         encodings.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int SubstSet(Rbc\_t * f, char * SubstData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for substitution.]

  Description [Dfs Set for substitution.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SubstFirst(Rbc\_t * f, char * SubstData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for substitution.]

  Description [Dfs FirstVisit for substitution.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SubstBack(Rbc\_t * f, char * SubstData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs BackVisit for substitution.]

  Description [Dfs BackVisit for substitution.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SubstLast(Rbc\_t* f, char* SubstData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for Substitution.]

  Description [Dfs LastVisit for Substitution.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void LogicalSubstLast(Rbc\_t* f, char* SubstData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for logical Substitution.]

  Description [Dfs LastVisit for logical Substitution.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int ShiftSet(Rbc\_t * f, char * shiftData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for shifting.]

  Description [Dfs Set for shifting.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ShiftFirst(Rbc\_t * f, char * shiftData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for shifting.]

  Description [Dfs FirstVisit for shifting.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ShiftBack(Rbc\_t * f, char * shiftData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs BackVisit for shifting.]

  Description [Dfs BackVisit for shifting.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void ShiftLast(Rbc\_t * f, char * shiftData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for shifting.]

  Description [Dfs LastVisit for shifting.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void LogicalShiftLast(Rbc\_t* f, char* shiftData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for logical shifting.]

  Description [Dfs LastVisit for logical shifting.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int SubstRbcSet(Rbc\_t * f, char * SubstRbcData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs Set for substitution (variables to formulas).]

  Description [Dfs Set for substitution (variables to formulas).]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SubstRbcFirst(Rbc\_t * f, char * SubstRbcData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs FirstVisit for substitution (variables to formulas).]

  Description [Dfs FirstVisit for substitution (variables to formulas).]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SubstRbcBack(Rbc\_t * f, char * SubstRbcData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs BackVisit for substRbcitution.]

  Description [Dfs BackVisit for substRbcitution.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void SubstRbcLast(Rbc\_t * f, char * SubstRbcData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for SubstRbcitution.]

  Description [Dfs LastVisit for SubstRbcitution.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void LogicalSubstRbcLast(Rbc\_t* f, char* SubstRbcData, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Dfs LastVisit for logical Rbc Substitution.]

  Description [Dfs LastVisit for logical Rbc Substitution.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{rbcUtils.c}
		
	\texttt{void Rbc\_pkg\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Package initialization]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_pkg\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Package deinitialization]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr RbcUtils\_get\_dependencies(Rbc\_Manager\_t* rbcManager, Rbc\_t* f, boolean reset\_dag)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_Dfs\_exported(Rbc\_t* rbc, RbcDfsFunctions\_t* dfsFun, void* dfsData, Rbc\_Manager\_t* rbc\_manager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Calls the internal DFS]

   Description [This is an external function that call the internal DFS]

   SideEffects []

   SeeAlso     [Dag_Dfs()]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Rbc\_Dfs\_clean\_exported(Rbc\_t* rbc, Rbc\_Manager\_t* rbc\_manager)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Calls the internal DFS clean]

   Description [This is an external function that call the internal DFS clean]

   SideEffects []

   SeeAlso     [Dag_Dfs()]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int rbc\_dep\_set(Rbc\_t* f, char* \_data, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void rbc\_dep\_last(Rbc\_t* f, char* \_data, nusmv\_ptrint sign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{sat}
		
	\section{solvers}
		
	\subsection{SatMinisat.c}
		
	\texttt{SatMinisat\_ptr SatMinisat\_create(const char* name, boolean enable\_proof\_logging)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a Minisat SAT solver and initializes it.]

  Description [The first parameter is the name of the solver.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatMinisat\_destroy (SatMinisat\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys an instance of a MiniSat SAT solver]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sat\_minisat\_cnfLiteral2minisatLiteral(SatMinisat\_ptr self, int cnfLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Convert a cnf literal into an internal literal used by minisat]

  Description [The literal may not be 0 (because 0 cannot have sign).
  First, the function obtains the cnf variable (removes the sign),
  obtains associated internal var through hash table(creates if necessary
  an internal variable)
  and then converts it in minisat literal (just adjust the sign).
  If necessary a new minisat variable is created.]

  SideEffects []

  SeeAlso     [sat_minisat_minisatLiteral2cnfLiteral]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sat\_minisat\_minisatLiteral2cnfLiteral(SatMinisat\_ptr self, int minisatLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Convert an internal minisat literal into a cnf literal]

  Description [The variable in the literal has to be created by
   sat_minisat_cnfLiteral2minisatLiteral only.
  First, the function obtains the minisat variable from the literal,
  obtains associated cnf variable (there must already be the association),
  and then converts it in cnf literal (adjust the sign)]

  SideEffects []

  SeeAlso     [sat_minisat_cnfLiteral2minisatLiteral]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_add(const SatSolver\_ptr solver, const Be\_Cnf\_ptr cnfProb, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Adds a clause to the solver database.]

  Description [converts all CNF literals into the internal literals,
  adds a group id to every clause (if group is not permament) and then add
  obtained clauses to actual Minisat]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_set\_polarity(const SatSolver\_ptr solver, const Be\_Cnf\_ptr cnfProb, int polarity, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the polarity of the formula.]

  Description [Sets the polarity of the formula.
  Polarity 1 means the formula is considered as positive, and -1 means
  the negation of the formula will be solved.
  A unit clause of the literal (with sign equal to polarity)
  corresponding to the given CNF formula is added to the solve.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_set\_preferred\_variables(const SatSolver\_ptr solver, const Slist\_ptr cnfVars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets preferred variables in the solver]

  Description [Sets preferred variables in the solver. A preferred variable is
               split upon with priority, with respect to non-preferedd ones.]

  SideEffects []

  SeeAlso     [SatSolver_clear_preferred_variables]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_clear\_preferred\_variables(const SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Clears preferred variables in the solver]

  Description [Clears preferred variables in the solver. A preferred variable
               is split upon with priority, with respect to non-preferedd
               ones.]

  SideEffects []

  SeeAlso     [SatSolver_set_preferred_variables]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_minisat\_solve\_all\_groups(const SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tries to solve all added formulas]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_minisat\_solve\_permanent\_group\_assume(const SatSolver\_ptr sol, const Slist\_ptr assumptions)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Solves the permanent group under set of assumptions]

  Description [Obtain set of conflicting assumptions with
  sat_minisat_get_conflict]

  SideEffects []

  SeeAlso     [sat_minisat_get_conflict, sat_minisat_make_conflicts]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sat\_minisat\_get\_conflicts(const SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns set of conflicting assumptions]

  Description [Only use with SatMinisat_solve_permanent_group_assume]

  SideEffects []

  SeeAlso     [sat_minisat_solve_permanent_group_assume,
  sat_minisat_make_conflicts]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sat\_minisat\_make\_model (const SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function creates a model (in the original CNF variables)]

  Description [The previous invocation of SAT_Solve should have been successful]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverGroup sat\_minisat\_create\_group(const SatIncSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a new group and returns its ID ]

  Description [Adds the group at the END of the existing groups list]

  SideEffects []

  SeeAlso     [SatIncSolver_destroy_group,
  SatIncSolver_move_to_permanent_and_destroy_group]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_destroy\_group(const SatIncSolver\_ptr solver, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroy an existing group (which has been returned by
  SatIncSolver_create_group) and all formulas in it. ]

  Description [Just adds to the solver a unit clause with positive literal
  of a variable with index  equal to group id ]

  SideEffects []

  SeeAlso     [SatIncSolver_create_group]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_move\_to\_permanent\_and\_destroy\_group(const SatIncSolver\_ptr solver, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Moves all formulas from a group into the permanent group of
  the solver and then destroy the given group.]


  Description [just adds  to minisat a unit clause with negative literal
  of a variable with index equal to group id]

  SideEffects []

  SeeAlso     [SatIncSolver_create_group, SatSolver_get_permanent_group,
  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_minisat\_solve\_groups(const SatIncSolver\_ptr solver, const Olist\_ptr groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tries to solve formulas from the groups in the list.]

  Description [The permanent group is automatically added to the list.
  Returns a flag whether the solving was successful. If it was successful only
  then SatSolver_get_model may be invoked to obtain the model ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_minisat\_solve\_without\_groups(const SatIncSolver\_ptr solver, const Olist\_ptr groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tries to solve formulas in groups belonging to the solver
  except the groups in the list.]

  Description [The permanent group must not be in the list.
  Returns a flag whether the solving was successful. If it was successful only
  then SatSolver_get_model may be invoked to obtain the model ]

  SideEffects []

  SeeAlso     [SatSolverResult,SatSolver_get_permanent_group,
  SatIncSolver_create_group, SatSolver_get_model]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sat\_minisat\_make\_conflicts(const SatMinisat\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Obtains the set of conflicting assumptions from MiniSat]

  Description []

  SideEffects []

  SeeAlso     [sat_minisat_solve_permanent_group_assume,
  sat_minisat_get_conflict]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_set\_random\_mode(SatSolver\_ptr solver, double seed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, sets random polarity mode if seed is
  not zero, otherwise sets default non-random polarity mode.]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.
  It is an error if the last solving was unsuccessful.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_set\_polarity\_mode(SatSolver\_ptr solver, int mode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, sets polarity mode accordingly to the
  passed value.]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.
  It is an error if the last solving was unsuccessful.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sat\_minisat\_get\_polarity\_mode(const SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Pure virtual function, returns currently set polarity mode.]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.
  It is an error if the last solving was unsuccessful.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int* sat\_minisat\_get\_minisatClause (const SatMinisat\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Getter for minisatClause]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sat\_minisat\_get\_minisatClauseSize (const SatMinisat\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Getter for minisatClauseSize]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_enlarge\_minisatClause (const SatMinisat\_ptr self, unsigned int minSize)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Enlarge minisatClause, adapt minisatClauseSize]

  Description [Enlarges minisatClause until it has at least size minSize.]

  SideEffects [minisatClause might be reallocated, minisatClauseSize
               changes value.]

  SeeAlso     [sat_minisat_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SatSolverItpGroup sat\_minisat\_curr\_itp\_group(SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SatSolverItpGroup sat\_minisat\_new\_itp\_group(SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Term sat\_minisat\_extract\_interpolant(SatSolver\_ptr solver, int nof\_ga\_groups, SatSolverItpGroup* ga\_groups, TermFactoryCallbacks\_ptr callbacks, TermFactoryCallbacksUserData\_ptr user\_data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_init(SatMinisat\_ptr self, const char* name, boolean enable\_proof\_logging)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes Sat Minisat object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_minisat\_deinit(SatMinisat\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deinitializes SatMinisat object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sat\_minisat\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finalize method of SatMinisat class.]

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int \_get\_clause\_size(const int * clause)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes the size of a clause.]

  Description [Computes the size of a clause.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SatZchaff.c}
		
	\texttt{SatZchaff\_ptr SatZchaff\_create(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a Zchaff SAT solver and initializes it.]

  Description [The first parameter is the name of the solver.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatZchaff\_destroy (SatZchaff\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys a Zchaff SAT solver instence]

  Description [The first parameter is the name of the solver.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sat\_zchaff\_cnfLiteral2zchaffLiteral(SatZchaff\_ptr self, int cnfLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Convert a cnf literal into an internal literal used by zchaff]

  Description [The literal may not be 0 (because 0 cannot have sign).
  First, the function obtains the cnf variable (removes the sign),
  obtains associated internal var through hash table(creates if necessary
  an internal variable)
  and then converts it in zchaff literal (var*2+sign, see ZChaff SAT.h).
  If necessary a new minisat variable is created.]

  SideEffects []

  SeeAlso     [sat_zchaff_zchaffLiteral2cnfLiteral]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sat\_zchaff\_zchaffLiteral2cnfLiteral(SatZchaff\_ptr self, int zchaffLiteral)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Convert an internal zchaff literal into a cnf literal]

  Description [The variable in the literal has to be created by
  sat_zchaff_cnfLiteral2zchaffLiteral only.
  First, the function obtains the zchaff variable from the literal,
  obtains associated cnf variable (there must already be the association),
  and then converts it in cnf literal (add the sign)]

  SideEffects []

  SeeAlso     [sat_zchaff_cnfLiteral2zchaffLiteral]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_zchaff\_add(const SatSolver\_ptr solver, const Be\_Cnf\_ptr cnfProb, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Adds a clause to the solver database.]

  Description [converts all CNF literals into the internal literals,
  adds a group id to every clause (if group is not permament) and then add
  obtained clauses to actual ZChaff]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_zchaff\_set\_polarity(const SatSolver\_ptr solver, const Be\_Cnf\_ptr cnfProb, int polarity, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the polarity of the formula.]

  Description [Sets the polarity of the formula.
  Polarity 1 means the formula is considered as positive, and -1 means
  the negation of the formula will be solved.
  A unit clause of the literal (with sign equal to polarity)
  corresponding to the given CNF formula is added to the solve.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_zchaff\_set\_preferred\_variables(const SatSolver\_ptr solver, const Slist\_ptr cnfVars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets preferred variables in the solver]

  Description [Sets preferred variables in the solver]

  SideEffects []

  SeeAlso     [sat_zchaff_clear_preferred_variables]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_zchaff\_clear\_preferred\_variables(const SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Clears preferred variables in the solver]

  Description [Clears preferred variables in the solver]

  SideEffects []

  SeeAlso     [sat_zchaff_set_preferred_variables]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_zchaff\_solve\_all\_groups(const SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tries to solve all added formulas]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_zchaff\_solve\_permanent\_group\_assume(const SatSolver\_ptr self, const Slist\_ptr assumptions)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Solves the permanent group under set of assumptions]

  Description [Obtain set of conflicting assumptions with
  sat_minisat_get_conflict]

  SideEffects []

  SeeAlso     [sat_zchaff_get_conflict, sat_zchaff_make_conflict]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sat\_zchaff\_get\_conflicts(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns set of conflicting assumptions]

  Description [Only use with SatMinisat_solve_permanent_group_assume]

  SideEffects []

  SeeAlso     [sat_minisat_solve_permanent_group_assume,
  sat_minisat_make_conflict]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sat\_zchaff\_make\_model (const SatSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function creates a model (in the original cnf variables)]

  Description [The previous invocation of SAT_Solve should have been successful]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverGroup sat\_zchaff\_create\_group(const SatIncSolver\_ptr solver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a new group and returns its ID ]

  Description [Adds the group at the END of the existing groups list]

  SideEffects []

  SeeAlso     [SatIncSolver_destroy_group,
  SatIncSolver_move_to_permanent_and_destroy_group]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_zchaff\_destroy\_group(const SatIncSolver\_ptr solver, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroy an existing group (which has been returned by
  SatIncSolver_create_group) and all formulas in it. ]

  Description [Just adds to the solver a unit clause with positive literal
  of a variable with index  equal to group id ]

  SideEffects []

  SeeAlso     [SatIncSolver_create_group]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_zchaff\_move\_to\_permanent\_and\_destroy\_group(const SatIncSolver\_ptr solver, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Moves all formulas from a group into the permanent group of
  the solver and then destroy the given group.]

  Description [just adds to zchaff a unit clause with negative literal
  of a variable with index equal to group id]

  SideEffects []

  SeeAlso     [SatIncSolver_create_group, SatSolver_get_permanent_group,
  ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_zchaff\_solve\_groups(const SatIncSolver\_ptr solver, const Olist\_ptr groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tries to solve formulas from the groups in the list.]

  Description [The permanent group is automatically added to the list.
  Returns a flag whether the solving was successful. If it was successful only
  then SatSolver_get_model may be invoked to obtain the model ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_zchaff\_solve\_without\_groups(const SatIncSolver\_ptr solver, const Olist\_ptr groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tries to solve formulas in groups belonging to the solver
  except the groups in the list.]

  Description [The permanent group must not be in the list.
  Returns a flag whether the solving was successful. If it was successful only
  then SatSolver_get_model may be invoked to obtain the model ]

  SideEffects []

  SeeAlso     [SatSolverResult,SatSolver_get_permanent_group,
  SatIncSolver_create_group, SatSolver_get_model]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sat\_zchaff\_make\_conflicts(const SatZchaff\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Obtains the set of conflicting assumptions from zCahdd]

  Description []

  SideEffects []

  SeeAlso     [sat_zchaff_solve_permanent_group_assume,
  sat_zchaff_get_conflict]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_zchaff\_init(SatZchaff\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes Sat Zchaff object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_zchaff\_deinit(SatZchaff\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deinitializes SatZchaff object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sat\_zchaff\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finalize method of SatZchaff class.]

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int \_get\_clause\_size(const int * clause)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Computes the size of a clause.]

  Description [Computes the size of a clause.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SatIncSolver.c}
		
	\texttt{void SatIncSolver\_destroy(SatIncSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys an instance of a SAT incremental solver]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverGroup SatIncSolver\_create\_group(const SatIncSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a new group and returns its ID. To destroy a group use
  SatIncSolver_destroy_group or
  SatIncSolver_move_to_permanent_and_destroy_group]

  Description []

  SideEffects []

  SeeAlso     [SatIncSolver_destroy_group,
  SatIncSolver_move_to_permanent_and_destroy_group]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatIncSolver\_destroy\_group(const SatIncSolver\_ptr self, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroy an existing group (which has been returned by
  SatIncSolver_create_group) and all formulas in it. ]

  Description []

  SideEffects []

  SeeAlso     [SatIncSolver_create_group]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatIncSolver\_move\_to\_permanent\_and\_destroy\_group(const SatIncSolver\_ptr self, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Moves all formulas from a group into the permanent group of
  the solver and then destroy the given group.
  (Permanent group may have more efficient implementation,
  but it can not be destroyed).]

  Description []

  SideEffects []

  SeeAlso     [SatIncSolver_create_group, SatSolver_get_permanent_group]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult SatIncSolver\_solve\_groups(const SatIncSolver\_ptr self, const Olist\_ptr groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tries to solve formulas from the groups in the list.]

  Description [The permanent group is automatically added to the list.
  Returns a flag whether the solving was successful. If it was successful only
  then SatSolver_get_model may be invoked to obtain the model ]

  SideEffects []

  SeeAlso     [SatSolverResult,SatSolver_get_permanent_group,
  SatIncSolver_create_group, SatSolver_get_model]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult SatIncSolver\_solve\_without\_groups(const SatIncSolver\_ptr self, const Olist\_ptr groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tries to solve formulas in groups belonging to the solver
  except the groups in the list.]

  Description [The permanent group must not be in the list.
  Returns a flag whether the solving was successful. If it was successful only
  then SatSolver_get_model may be invoked to obtain the model ]

  SideEffects []

  SeeAlso     [SatSolverResult,SatSolver_get_permanent_group,
  SatIncSolver_create_group, SatSolver_get_model]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverGroup sat\_inc\_solver\_create\_group (const SatIncSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, create a new group]

  Description [It is a pure virtual function and SatIncSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     [SatIncSolver_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_inc\_solver\_destroy\_group (const SatIncSolver\_ptr self, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, destroys existing group]

  Description [It is a pure virtual function and SatIncSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     [SatIncSolver_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_inc\_solver\_move\_to\_permanent\_and\_destroy\_group (const SatIncSolver\_ptr self, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, moves all formulas from
  a given group into the permanent one, and then destroys the given group]

  Description [It is a pure virtual function and SatIncSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     [SatIncSolver_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_inc\_solver\_solve\_groups (const SatIncSolver\_ptr self, const Olist\_ptr groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, tries to solve formulas from
  the groups in the list. the permanent group is automatically added to
  the list]

  Description [It is a pure virtual function and SatIncSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     [SatIncSolver_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_inc\_solver\_solve\_without\_groups (const SatIncSolver\_ptr self, const Olist\_ptr groups)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, tries to solve formulas from
  the groups belonging to the solver except the groups in the list.
  the permanent group must not be in the list]

  Description [It is a pure virtual function and SatIncSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     [SatIncSolver_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_inc\_solver\_init(SatIncSolver\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function initializes the SatIncSolver class.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_inc\_solver\_deinit(SatIncSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function de-initializes the SatIncSolver class.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sat\_inc\_solver\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finalize method of SatIncSolver class.]

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SatSolver.c}
		
	\texttt{void SatSolver\_destroy(SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destoys an instance of a  SAT solver]

  Description        []

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverGroup SatSolver\_get\_permanent\_group(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the permanent group of this class instance.]

  Description [Every solver has one permanent group that can not be destroyed.
  This group may has more efficient representation and during invocations
  of any 'solve' functions, the permanent group will always be
  included into the groups to be solved.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatSolver\_add(const SatSolver\_ptr self, const Be\_Cnf\_ptr cnfProb, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Adds a CNF formula to a group ]

  Description [
  The function does not specify the polarity of the formula.
  This should be done by SatSolver_set_polarity.
  In general, if polarity is not set any value can be assigned to the formula
  and its variables  (this may potentially slow down the solver because
  there is a number of variables whose value can be any and solver will try to
  assign values to them though it is not necessary). Moreover, some solver
  (such as ZChaff) can deal with non-redundent clauses only, so the input
  clauses must be non-redundent: no variable can be in the same clause twice.
  CNF formular may be a constant.]

  SideEffects []

  SeeAlso     [SatSolver_set_polarity]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatSolver\_set\_polarity(const SatSolver\_ptr self, const Be\_Cnf\_ptr cnfProb, int polarity, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function*********************************************************************

  Synopsis    [Sets the polarity of a CNF formula in a group]

  Description [Polarity 1 means the formula will be considered in this group
  as positive. Polarity -1 means the formula will be considered in this group
  as negative. The formula is not added to the group, just the formula's
  polarity. The formula can be added to a group with SatSolver_add.
  The formula and its polarity can be added to different groups.
  CNF formular may be a constant.]

  SideEffects []

  SeeAlso     [SatSolver_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatSolver\_set\_preferred\_variables(const SatSolver\_ptr self, const Slist\_ptr cnfVars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets preferred variables in the solver]

  Description [Sets preferred variables in the solver]

  SideEffects []

  SeeAlso     [SatSolver_clear_preferred_variables]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatSolver\_clear\_preferred\_variables(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Clear preferred variables in the solver]

  Description [Clear preferred variables in the solver]

  SideEffects []

  SeeAlso     [SatSolver_set_preferred_variables]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult SatSolver\_solve\_all\_groups(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Solves all groups belonging to the solver and returns the flag]

  Description []

  SideEffects []

  SeeAlso     [SatSolverResult]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult SatSolver\_solve\_all\_groups\_assume(const SatSolver\_ptr self, Slist\_ptr assumptions)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Solves all groups belonging to the solver assuming the cnf
  assumptions, and returns the flag]

  Description []

  SideEffects []

  SeeAlso     [SatSolverResult]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr SatSolver\_get\_conflicts(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the conflicts resulting from a previous call
  to solving under assumptions]

  Description []

  SideEffects []

  SeeAlso     [SatSolverResult]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr SatSolver\_get\_model(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the model (of previous solving)]

  Description [ The previous solving call should have returned SATISFIABLE.
  The returned list is a list of values in dimac form (positive literal
  is included as the variable index, negative literal as the negative
  variable index, if a literal has not been set its value is not included).

  Returned list belongs to self and must be not destroyed or changed.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SatSolver\_get\_cnf\_var(const SatSolver\_ptr self, int var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatSolver\_set\_random\_mode(SatSolver\_ptr self, double seed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Enables or disables random mode for polarity.]

  Description [If given seed is != 0, then random polarity mode is enabled
  with given seed, otherwise random mode is disabled]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SatSolver\_set\_polarity\_mode(SatSolver\_ptr self, int mode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the current polarity mode]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SatSolver\_get\_polarity\_mode(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the current polarity mode]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* SatSolver\_get\_name(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the name of the solver]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{long SatSolver\_get\_last\_solving\_time(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the time of last solving]

  Description []

  SideEffects []

  SeeAlso     []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverItpGroup SatSolver\_curr\_itp\_group(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns current itp group]

  Description []

  SideEffects []

  SeeAlso     []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverItpGroup SatSolver\_new\_itp\_group(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the time of last solving]

  Description []

  SideEffects []

  SeeAlso     []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Term SatSolver\_extract\_interpolant(const SatSolver\_ptr self, int nof\_ga\_groups, SatSolverItpGroup* ga\_groups, TermFactoryCallbacks\_ptr callbacks, TermFactoryCallbacksUserData\_ptr user\_data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the time of last solving]

  Description []

  SideEffects []

  SeeAlso     []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_solver\_add(const SatSolver\_ptr self, const Be\_Cnf\_ptr cnfProb, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, adds a formula to a group]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     [SatSolver_add]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_solver\_set\_polarity(const SatSolver\_ptr self, const Be\_Cnf\_ptr cnfProb, int polarity, SatSolverGroup group)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, sets the polarity of a formula ]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     [SatSolver_set_polarity]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_solver\_solve\_all\_groups(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, tries to solve formulas in the group and
  the permanent group ]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolverResult sat\_solver\_solve\_all\_groups\_assume(const SatSolver\_ptr self, Slist\_ptr assumption)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, tries to solve formulas in the group and
  the permanent group under assumption ]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sat\_solver\_make\_model(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, creates a model for last successful
  solving]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.
  It is an error if the last solving was unsuccessful.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sat\_solver\_get\_cnf\_var(const SatSolver\_ptr self, int lit)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, get CNF literal corresponding to given
  internal Minisat literal]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr sat\_solver\_get\_conflicts(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, returns the conflicts after
  a previous call to solve udner assumption]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.
  It is an error if the last solving was unsuccessful.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_solver\_set\_random\_mode(SatSolver\_ptr self, double seed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, sets random polarity mode if seed is
  not zero, otherwise sets default non-random polarity mode.]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.
  It is an error if the last solving was unsuccessful.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_solver\_set\_polarity\_mode(SatSolver\_ptr self, int mode)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Pure virtual function, sets polarity mode accordingly to the
  passed value.]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.
  It is an error if the last solving was unsuccessful.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int sat\_solver\_get\_polarity\_mode(const SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Pure virtual function, returns currently set polarity mode.]

  Description [It is a pure virtual function and SatSolver is an abstract
  base class. Every derived class must ovewrwrite this function.
  It is an error if the last solving was unsuccessful.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SatSolverItpGroup sat\_solver\_curr\_itp\_group(SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static SatSolverItpGroup sat\_solver\_new\_itp\_group(SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Term sat\_solver\_extract\_interpolant(SatSolver\_ptr self, int nof\_ga\_groups, SatSolverItpGroup* ga\_groups, TermFactoryCallbacks\_ptr callbacks, TermFactoryCallbacksUserData\_ptr user\_data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_solver\_RemoveFromList(lsList list, const lsGeneric element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [removes an element from the list]

  Description [If there is no such element in the list => do nothing]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_solver\_init(SatSolver\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function initializes the SatSolver class.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_solver\_deinit(SatSolver\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function de-initializes the SatSolver class.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sat\_solver\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finalize method of SatSolver class.]

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{satUtils.c}
		
	\texttt{SatSolver\_ptr Sat\_CreateNonIncSolver(const char* satSolver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a SAT solver (non-incremental) of a given name.]

  Description        [The name of a solver is case-insensitive. Returns NULL
  if requested sat solver is not available.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatSolver\_ptr Sat\_CreateNonIncProofSolver(const char* satSolver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Creates a SAT solver (non-incremental) of a given
  name. Proof-logging may be enabled if needed.]

  Description [The name of a solver is case-insensitive. Returns NULL
  if requested sat solver is not available. Proof logging is currently
  available only with MiniSat.]

  SideEffects []

  SeeAlso     []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatIncSolver\_ptr Sat\_CreateIncSolver(const char* satSolver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates an incremental SAT solver instance of a given
  name.]

  Description        [The name of a solver is case-insensitive. Returns NULL
  if requested sat solver is not available.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SatIncSolver\_ptr Sat\_CreateIncProofSolver(const char* satSolver)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Creates an incremental proof logging SAT solver instance
  of a given name.]

  Description        [The name of a solver is case-insensitive. Returns NULL
  if requested sat solver is not available.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Sat\_NormalizeSatSolverName(const char* solverName)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a string representing the name of a sat solver,
  returns a normalized solver name -- just potential changes in character cases
  ]

  Description        [In case of an error, if an input string does not
  represented any solver, returns (const char*) NULL. Returned string
  must not be freed.]

  SideEffects        []

  SeeAlso            []
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Sat\_PrintAvailableSolvers(FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints out the sat solvers names the system currently
  supplies]

  Description        []

  SideEffects        []

  SeeAlso            [Sat_GetAvailableSolversString]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* Sat\_GetAvailableSolversString()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves a string with the sat solvers names the
                      system currently supplies]

  Description        [Returned string must be freed]

  SideEffects        []

  SeeAlso            [Sat_PrintAvailableSolvers]
******************************************************************************/

	\end{verbatimtab}
	
	\section{set}
		
	\subsection{setSet.c}
		
	\texttt{void set\_pkg\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the set package]

  Description [Initializes the set package. See also Set_Quit() to
  deinitialize it]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void set\_pkg\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [De-Initializes the set package]

  Description [De-Initializes the set package. Use after Set_init()]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_MakeEmpty()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Create a generic empty set]

  Description        [This function creates an empty set.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_Make(node\_ptr l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a list, builds a corresponding set]

  Description        [Given a list, builds a corresponding set]

  SideEffects        []

  SeeAlso            [Set_MakeSingleton]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_MakeSingleton(Set\_Element\_t el)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a Singleton]

  Description        [Creates a set with a unique element.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_MakeFromUnion(node\_ptr \_union)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given an union node, builds a corresponding set]

  Description        [Given an union node, builds a corresponding set]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_Copy(const Set\_t set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the independent copy of a set]

  Description [If the set was frozen, returned set is equal to the set
  given as input, and its reference counting is incremented. See
  description about the structure Set_t for further information]

  SideEffects        []

  SeeAlso            [Set_MakeSingleton]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Set\_ReleaseSet(Set\_t set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Frees a set]

  Description [Releases the memory associated to the given set. If the
  set was frozen, reference counting is taken into account. See
  description about the structure Set_t for further information]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Set\_ReleaseSetOfSet(Set\_t set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Frees a set of sets ]

  Description [Assuming that an input set consists of elements each of
  which is also a set this function applies Set_ReleaseSet to the input
  set and every set in it.]

  SideEffects [Set_ReleaseSet]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Set\_IsEmpty (const Set\_t set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set Emptiness]

  Description        [Checks for Set Emptiness. Constant time]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Set\_IsMember(const Set\_t set, Set\_Element\_t el)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set memberships]

  Description        [Checks if the given element is a member of the
  set. It returns <tt>True</tt> if it is a member, <tt>False</tt>
  otherwise. Constant time]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Set\_GiveCardinality(const Set\_t set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set Cardinality]

  Description        [Computes the cardinality of the given set. Constant time]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_AddMember(Set\_t set, Set\_Element\_t el)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds a new element to the set]

  Description [Add in order (at the end) a new element. Constant time
  if not frozen, linear time if frozen. See description about the
  structure Set_t for further information]

  SideEffects        [If set is not frozen, set is changed internally]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_RemoveMember(Set\_t set, Set\_Element\_t el)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the given element from the set, if found]

  Description        [The new set is returned. Linear time. See
  description about the structure Set_t for further information]

  SideEffects [If set is not frozen, set is changed internally. If
  after removal set is empty, it is also released.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_AddMembersFromList(Set\_t set, const NodeList\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds all new elements found in list]

  Description [Add in order (at the end) all new elements. Linear
  time in the size of list if not frozen, linear time in size of
  set + size of list if frozen. See description about the structure
  Set_t for further information]

  SideEffects        [If set is not frozen, set is changed internally]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Set\_Contains(const Set\_t set1, const Set\_t set2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if set1 contains set2]

  Description        [Returns true iff set2 is a subset of set1. Linear in 
  the size of set2]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Set\_Equals(const Set\_t set1, const Set\_t set2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if set1 = set2]

  Description [Returns true iff set1 contains the same elements of
  set2. Linear in the size of set2]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Set\_Intersects(const Set\_t set1, const Set\_t set2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks set1 and set2 has at least one common element]

  Description [Returns true iff set1 contains at least one element from
  set2. Linear in the size of set1]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_Union(Set\_t set1, const Set\_t set2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set Union]

  Description [Computes the Union of two sets. If set1 is not frozen,
  set1 is changed by adding members of set2. If set1 is frozen, it is
  before copied into a new set. 

  If set1 is not frozen, complexity is linear in the cardinality od
  set2, otherwise it is linear in the cardinality(set1) +
  cardinality(set2)

  See description about the structure Set_t for further information]

  SideEffects        [If set is not frozen, set is changed internally.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_Intersection(Set\_t set1, const Set\_t set2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Set intersection]

  Description [Computes the Set intersection. Linear time on the
  cardinality of set1+set2. See description about the structure Set_t for
  further information]

  SideEffects [If set1 is not frozen, set1 is changed internally. If
  after intersection set1 is empty, it is also released and the empty
  set is returned.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_Difference(Set\_t set1, const Set\_t set2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Set Difference]

  Description [Computes the Set Difference. Linear time on the
  cardinality of set1. See description about the structure Set_t for
  further information]

  SideEffects [If set1 is not frozen, set1 is changed internally. If
  after difference set1 is empty, it is also released and the empty
  set is returned.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_GetRest(const Set\_t set, Set\_Iterator\_t from)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the rest of a set from a starting point]

  Description [Given a set and an iterator within that set, returns a
  new set containing all the elements that are found in to the input
  set from the iterator to then end of the set. Returned set must be
  disposed by the caller. 

  WARNING!! Deprecated method. This method is provided only for
  backward compatibility and should be no longer used in new code.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t Set\_Freeze(Set\_t set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Freezes a set]

  Description [Use when a set has to be memoized
  or stored in memory permanently. When frozen, a set content is
  frozen, meaning that no change can occur later on this set. If the
  set is tried to be changed later, a new copy will be created and
  changes will be applied to that copy. When a frozen set is copied, a
  reference counter is incremented and the same instance is returned
  in constant time. When a frozen set is destroyed, it is destroyed
  only when its ref counter reaches 0 (meaning it is the very last
  instance of that set). Set is also returned for a functional
  flavour. See description about the structure Set_t for
  further information]

  SideEffects        [set is changed internally if not already frozen]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_Iterator\_t Set\_GetFirstIter(Set\_t set1)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Provides an iterator to the "first" element of the set]

  Description [Returns an iterator to the "first" element of the set.
  Since sets are ordered, iterating through a set means to traverse
  the elements into the set in the same chronological ordering they
  have been previoulsy added to the set. If a set is changed, any
  previous stored iterator on that set might become invalid.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_Iterator\_t Set\_GetNextIter(Set\_Iterator\_t iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Given an itarator of a set, returns the iterator pointing
  to the next chronological element in that set.]

  Description        [Returns the next iterator.
  Since sets are ordered, iterating through a set means to traverse
  the elements into the set in the same chronological ordering they
  have been previoulsy added to the set. If a set is changed, any
  previous stored iterator on that set might become invalid.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Set\_IsEndIter(Set\_Iterator\_t iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns true if the set iterator is at the end of the
  iteration]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_Element\_t Set\_GetMember(const Set\_t set, Set\_Iterator\_t iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the element at given iterator]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr Set\_Set2List(const Set\_t set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a set, returns the corresponding list]

  Description [Given a set, returns a corresponding list. Returned
  list belongs to self and must be NOT freed nor changed by the caller.]

  SideEffects        []

  SeeAlso            [Set_MakeSingleton]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Set\_PrintSet(FILE * file, const Set\_t s, void (*printer)(FILE* file, Set\_Element\_t el, void* arg), void* printer\_arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints a set]

  Description [Prints a set to the specified file stream. Third
  parameter printer is a callback to be used when printing
  elements. If NULL, elements will be assumed to be node_ptr and
  print_node is called. printer_arg is an optional argument to be
  passed to the printer (can be NULL)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t set\_create(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal constructor]

  Description        [Internal constructor]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t set\_copy(const Set\_t self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal copy constructor]

  Description        [Internal copy constructor]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t set\_copy\_actual(const Set\_t self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal copy constructor]

  Description        [Internal copy constructor]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void set\_destroy(Set\_t self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Internal destructor]

  Description        [Internal destructor]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Set\_t set\_check\_frozen(Set\_t self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This methods checks family counter and returns either a 
  new instance of self]

  Description        [Used internally by functions that change the instance
  to handle frozen set]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void set\_check\_list(Set\_t self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Fix the internal list if used actually]

  Description [This method is used internally to allow late allocation
  of the list]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void set\_union\_to\_set\_aux(node\_ptr a, Set\_t* set)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Given a node (possibly a UNION node) returns the 
  corresponding set]

  Description        [Auxiliary function for constructor from union nodes]

  SideEffects        [Given set will be added of found expressions]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{sexp}
		
	\subsection{SexpInliner.c}
		
	\texttt{SexpInliner\_ptr SexpInliner\_create(SymbTable\_ptr st, const size\_t fixpoint\_limit)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sexp Inliner constructor]

  Description        [fixpoint_limit is a integer bound controlling the
                      maximum number of iteration to be carried out
                      when inlining an expression. Use 0 (zero) for
                      no limit.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SexpInliner\_ptr SexpInliner\_copy(const SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy costructor]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SexpInliner\_destroy(SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destructor]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SexpInliner\_clear\_equivalences(SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Clears the internal cache of forced equivalences]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SexpInliner\_clear\_invariants(SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Clears the internal cache of forced invariants]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SexpInliner\_clear\_blacklist(SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Clears the internal set of blacklisted names.]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr SexpInliner\_get\_symb\_table(const SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the symbol table that is connected to the
                      BoolEnc instance connected to self]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr SexpInliner\_get\_var2expr\_hash(const SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the internal var2expr hash]

  Description [Get the internal var2expr hash. Do not perform any
  side-effects on this hash]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{hash\_ptr SexpInliner\_get\_var2invar\_hash(const SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the internal var2invar hash]

  Description [Get the internal var2invar hash. Do not perform any
  side-effects on this hash]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SexpInliner\_force\_equivalence(SexpInliner\_ptr self, node\_ptr var, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Forces to learn that var (can be timed) and expr are
                      equivalent. The expression is assumed to be
                      already flattened, and defines expanded.]

  Description        [The equivalence is learnt even if given name is
                      blacklisted. The equivalence substitutes any
                      previously forced equivalence about the same
                      variable. Returns true if the equivalence was
                      accepted, or false otherwise.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SexpInliner\_force\_equivalences(SexpInliner\_ptr self, Set\_t equivs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Forces to learn all equivalences in given set]

  Description        [There is an implicit assumption about the format of
                      each element in the set. It must be either a
                      EQUAL, a EQDEF or a IFF node where left
                      operand is a variable. This method may be
                      useful to force equivalences previously
                      returned by a InlineRes instance.

                      Returns true if any equivalence was accepted,
                      false if all were rejected]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SexpInliner\_force\_invariant(SexpInliner\_ptr self, node\_ptr var, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Forces to learn that var and expr are
                      invariantly equivalent]

  Description        [var must be a flat variable name (not nexted not
                      timed). The expression is assumed to be
                      already flattened.
                      The invariant is learnt even if given name is
                      blacklisted. The invariant substitutes any
                      previously forced invariant about the same
                      variable.

                      Returns true if the invariant was successfully
                      forced, or false otherwise.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean SexpInliner\_force\_invariants(SexpInliner\_ptr self, Set\_t invars)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Forces to learn all invariants in given set]

  Description        [There is an implicit assumption about the format of
                      each element in the set. It must be either a
                      EQUAL, a EQDEF, or a IFF node where left
                      operand is a variable. This method may be
                      useful to force invariants previously
                      returned by a InlineRes instance.

                      Returns true if any invariant was accepted,
                      false if all were rejected]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SexpInliner\_blacklist\_name(SexpInliner\_ptr self, node\_ptr var)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds to the blacklist the given name]

  Description        [Any name occurring in the blacklist will be not
                      substituted. Use to avoid inlining a set of variables.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{InlineRes\_ptr SexpInliner\_inline(SexpInliner\_ptr self, Expr\_ptr expr, boolean* changed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Performs inlining of given expression]

  Description   [Applies inlining to the given expression, with fixpoint.

                 Returned InlineRes object contains the
                 result. Returned instance must be destroyed by the
                 caller. If given variable changed is not NULL, it
                 will be set to true if any inlining has been
                 applied, or will be set to false if no inlining
                 has been applied.

                 Before carrying out the actual inlining, this
                 method learn automatically equivalences out of the
                 given formula.

                 WARNING: The expression is assumed to be already
                 flattened, and normalized (all nodes created with
                 find_node)]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr SexpInliner\_inline\_no\_learning(SexpInliner\_ptr self, Expr\_ptr expr, boolean* changed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Performs inlining of given expression]

  Description [Applies inlining to the given expression, with
  fixpoint, and returns the result expression.


  If given variable changed is not NULL, it will be set to true if
  any inlining has been applied, or will be set to false if no
  inlining has been applied.

  Before carrying out the actual inlining, this method learn
  automatically equivalences out of the given formula.

  WARNING: The expression is assumed to be already flattened, and
  normalized (all nodes created with find_node)]

  SideEffects   [SexpInliner_inline]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void InlineRes\_destroy(InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Class destroyer]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr InlineRes\_get\_result(const InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Composes the whole result, making the conjuction of the
                 inlined expression, equivalences and invariants]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr InlineRes\_get\_result\_unique(const InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Composes the whole result, making the conjuction of the
                 inlined expression, equivalences and invariants]

  Description   [The equivalences and the invariants are sorted before being
  conjuncted to the inlined expression, to return a unique expression.]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr InlineRes\_get\_original\_expr(const InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the original expression which has been inlined]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr InlineRes\_get\_inlined\_expr(const InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the inlined expression, without equivalences and
                 invariants]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr InlineRes\_get\_equivalences\_expr(const InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the extracted and forced equivalences as an
                 expression]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t InlineRes\_get\_equivalences(const InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the extracted and forced equivalences as a set]

  Description   [Returned set belongs to self, do not free it]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr InlineRes\_get\_invariant\_expr(const InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the conjuction of all forced invariants]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t InlineRes\_get\_invariants(const InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Returns the extracted and forced invariants as a set]

  Description   [Returned set belongs to self, do not free it]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_inliner\_init(SexpInliner\_ptr self, SymbTable\_ptr st, const size\_t fixpoint\_limit)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Initializes either the boolean or scalar sexp fsm]

  Description [hierarchy is copied into an independent FlatHierarchy
  instance. If the new sexp must be based only on a set of variables, the
  hierarchy must be empty]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_inliner\_deinit(SexpInliner\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Class deinitializer]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_inliner\_copy(const SexpInliner\_ptr self, SexpInliner\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Copies members from self to copy]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr sexp\_inliner\_move\_time\_to\_leaves(const SexpInliner\_ptr self, node\_ptr expr, int time)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Brings all time-related nodes (ATTIME and NEXT) down to the
                 leaves, while expanding defines and formal parameters]

  Description   [internal self->hash_timed2leaves is used for memoization]

  SideEffects   [self->hash_timed2leaves is changed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr sexp\_inliner\_extract\_equals\_invars(const SexpInliner\_ptr self, node\_ptr expr, boolean is\_neg, Set\_t* equals, Set\_t* invars, Set\_t* vars, boolean* changed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Extract all equals (EQUAL and IFF) in the form v = t.]

  Description   [Unicity of v is not guaranteed. Returns new expr where all
  extracted equals have been substituted.

  This function collect all equalities which HAVE TO be satisfied to
  make the top-expression hold. For example, for (a=b ^ c=d) both
  equalities are returned but for (a=b | c=d) the returned set is
  empty.


  SideEffects   [The results of the function call is memoized in self]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static enum st\_retval sexp\_inliner\_fill\_good\_equals(char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [privately used by sexp_inliner_extract_candidate_equals]

  Description   [Callback to fill in the good_equals array]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int sexp\_inliner\_sort\_good\_equals(const void* obj1, const void* obj2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [privately used by sexp_inliner_extract_candidate_equals]

  Description   [Callback to sort the good_equals array]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_inliner\_free\_equalities\_array(array\_t* arr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [used privately for free the content of the array
                 returned by sexp_inliner_extract_candidate_equals]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sexp\_inliner\_print\_equality\_array(array\_t* arr, FILE* \_file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [used for debugging purposes]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static array\_t* sexp\_inliner\_extract\_candidate\_equals(const SexpInliner\_ptr self, const Set\_t equals, const Set\_t imp\_vars, const hash\_ptr var2invar, Set\_t* rem\_equals)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Removes duplicates]

  Description [splits equals into good_equals and rem_equals
  sets. Returned array must be freed by the caller]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static hash\_ptr sexp\_inliner\_remove\_loops(const SexpInliner\_ptr self, array\_t* good\_equals, hash\_ptr hash\_invars, Set\_t* good, Set\_t* rem)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Removes loops from good_equals]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static hash\_ptr sexp\_inliner\_remove\_loops(const SexpInliner\_ptr self, array\_t* good\_equals, hash\_ptr invar\_hash, Set\_t* good, Set\_t* rem)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Removes loops from good_equals]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr sexp\_try\_acquiring\_equality(const SexpInliner\_ptr self, node\_ptr equal, boolean is\_neg, Set\_t* set, Set\_t* vars, boolean* changed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [If given equal concerns a variable (like in
                      'expr = var') the equality is added to the given set
                      (after possible syntactic manipolation) and
                      the True expression is returned. Otherwise
                      the given equal expression is returned.]

  Description        [This is called during the traversal of the
                      expression when auto-extracting equalities.
                      WARNING! The equal expression is assumed to
                      be already flattened.]

  SideEffects        []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean sexp\_inliner\_expr\_is\_var(const SexpInliner\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis         [Returns true if given flattened expression is a
                    variable (potentially timed).]

  Description      [expr is assumed to have next and timed nodes moved
                    to the leaves.]

  SideEffects      []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr sexp\_inliner\_substitute(SexpInliner\_ptr self, node\_ptr expr, hash\_ptr var2expr, hash\_ptr var2invar, boolean* changed)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Traverses the structure of the expression, substituting
  (in top-level conjuctions) all found equivalences. Invariants are
  substituted within the whole expression. changed is set to true
  when applying the inlining, otherwise it keeps its values.]

  Description [The inlined expression is returned. var2invar (can be NULL) and
  is used to resolve invariants extracted from ASSIGNs.
  internal , self->hash_subst is used for memoization]

  SideEffects   [changed and self->hash_subst are modified]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean sexp\_inliner\_force\_equivalence(SexpInliner\_ptr self, node\_ptr var, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Here expr has next and attime moved to the leaves]

  Description   [If the expression's cone contains the variable, the
                 equivalence is not created. If the given
                 expression is syntactically non-deterministic (see
                 sexp_inliner_is_expr_deterministic about this
                 over-approximation) the equivalence is not
                 created. The equivalence is learnt independently
                 on the blacklist. This is called only when the
                 user forces an equivalence to exist, and not when
                 extracting equivalences automatically.

                 Returns true if the equivalences was successfully
                 created, or false otherwise.]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean sexp\_inliner\_force\_invariant(SexpInliner\_ptr self, node\_ptr var, Expr\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Here expr has next and attime moved to the leaves]

  Description   [If the expression's cone contains the variable,
                 the equivalence is not created.
                 If the given
                 expression is syntactically non-deterministic (see
                 sexp_inliner_is_expr_deterministic about this
                 over-approximation) the equivalence is not
                 created.

                 Returns true if the equivalences was successfully
                 created, or false otherwise.]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static InlineRes\_ptr inline\_res\_create(Expr\_ptr orig)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Private constructor]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void inline\_res\_deinit(InlineRes\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Class deinitializer]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int sexp\_inliner\_expr\_ptr\_compare(const void * c1, const void * c2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Private comparison]

  Description   []

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean sexp\_inliner\_is\_expr\_deterministic(const SexpInliner\_ptr self, node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Detects if the given expression is deterministic.]

  Description   [If TWODOTS or UNION node is found in the expression,
                 then the expression (with an over-approximation)
                 is considered as non-deterministic.  WARNING:
                 defines are not expanded, and cardinality is not
                 considered for sets (even singletons are
                 considered as sets, so the expression should be
                 simplified before calling this function).]

  SideEffects   [The results of the function call is memoized in self]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean sexp\_inliner\_is\_expr\_timed(node\_ptr expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Detects if the given expression contains ATTIME nodes.]

  Description   [Expression is assumed to have DEFINEs expanded]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr sexp\_inliner\_assign\_to\_setin(const SexpInliner\_ptr self, Expr\_ptr assign)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis      [Converts the given assign to an equivalent SETIN expression]

  Description   [WARNING: init(x) := e is converted to "x in e"]

  SideEffects   []

******************************************************************************/

	\end{verbatimtab}
	
	\section{simulate}
		
	\subsection{simulate.c}
		
	\texttt{node\_ptr Simulate\_MultipleSteps(BddFsm\_ptr fsm, bdd\_ptr constraint, boolean time\_shift, Simulation\_Mode mode, int n, int display\_all)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Multiple step simulation]

  Description        [Multiple step simulation: loops n times over the choice of
  a state according to the picking policy given at command line. It returns a
  list of at least n+1 referenced states (the first one is always the "current
  state" from which any simulation must start). The obtained list can contain
  a minor number of states if there are no future states at some point.]

  SideEffects        []

  SeeAlso            [Simulate_ChooseOneState]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr Simulate\_ChooseOneState(BddFsm\_ptr fsm, bdd\_ptr next\_set, Simulation\_Mode mode, int display\_all)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Chooses one state among future states]

  Description        [Chooses a state among future states depending on the
  given simulation policy (random, deterministic or interactive). In case of
        interactive simulation, the system stops and allows the user to pick
        a state from a list of possible items. If the number of future states
        is too high, the system requires some further constraints to limit that
        number and will asks for them until the number of states is lower than
        an internal threshold. Entered expressions are accumulated in one big
        constraint used only in the actual step of the simulation. It will be
        discarded after a state will be chosen.]

  SideEffects        [A referenced state (BDD) is returned. NULL if failed.]

  SeeAlso            [Simulate_MultipleStep]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Simulate\_ChooseOneStateInput(BddFsm\_ptr fsm, bdd\_ptr from\_state, bdd\_ptr next\_set, Simulation\_Mode mode, int display\_all, bdd\_ptr* input, bdd\_ptr* state)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Simulate\_CmdPickOneState(BddFsm\_ptr fsm, Simulation\_Mode mode, int display\_all, char * strConstr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Picks one state, to be used for BDD simulation]

  Description        [Returns the trace index on success, -1 otherwise]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr simulate\_get\_constraints\_from\_string(const char* constr\_str, BddEnc\_ptr enc, boolean allow\_nexts, boolean allow\_inputs)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts given constraint expression (as a string) to
                      a bdd]

  Description        [Input variables are allowed to occur in the passed
                      constraint iff allow_inputs is true.

                      Next operators are allowed to occur in the passed
                      constraint iff allow_nexts is true.

                      If an error occurs, NULL is returned and a
                      message is printed.

                      This function does not raises any
                      exception. Returned BDD must be freed by the
                      caller. In error messages it is assumed that
                      constr_str is read from the command line.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void simulate\_choose\_next(BddFsm\_ptr fsm, bdd\_ptr from\_state, bdd\_ptr next\_state\_set, Simulation\_Mode mode, int display\_all, bdd\_ptr* which\_input, bdd\_ptr* which\_state)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description [from_state can be NULL from the initial set of states.
  At the end which_input will contained the chosen input (if any, NULL
  otherwise) and which_state will contain the chosen state]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void simulate\_sigterm(int sig)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Signal handler]

  Description        [SIGINT signal handler inside the simulator.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr simulate\_accumulate\_constraints(BddEnc\_ptr enc, bdd\_ptr bdd, int max\_size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description       [There are 4 condition to be verified in order to accept
        new further constraints:

        1) entered expression must be a non-zero set;

  2) entered expression must be consistent with the accumulated
        constraints (i.e. the product (further /\ accumulated) must be
        non-zero;

  3) if (further /\ accumulated) is non-zero, it also must be
        non-zero the product (further /\ accumulated) /\ next_set of
        states

  4) cardinality of the set obtained from the last product must
     be <= shown_states

        ]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr simulate\_request\_constraints(BddEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [required]

  Description        [optional]

  SideEffects        [required]

  SeeAlso            [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{simulateCmd.c}
		
	\texttt{void Simulate\_Init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the simulate package.]

  Description        [Initializes the simulate package.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Simulate\_End(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Quits the simulate package]

  Description        [Quits the simulate package]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandPickState(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Picks a state from the set of initial states]

  CommandName        [pick_state]

  CommandSynopsis    [Picks a state from the set of initial states]

  CommandArguments   [\[-h\] \[-v\] \[-r | -i \[-a\]\] \[-c "constraints" | -s trace.state\]]

  CommandDescription [

  Chooses an element from the set of initial states, and makes it the
  <tt>current state</tt> (replacing the old one). The chosen state is
  stored as the first state of a new trace ready to be lengthened by
  <tt>steps</tt> states by the <tt>simulate</tt> command. The state can be
  chosen according to different policies which can be specified via command
  line options. By default the state is chosen in a deterministic way.
  <p>
  Command Options:<p>
  <dl>
    <dt> <tt>-v</tt>
       <dd> Verbosely prints out chosen state (all state variables, otherwise
       it prints out only the label <tt>t.1</tt> of the state chosen, where
       <tt>t</tt> is the number of the new trace, that is the number of
       traces so far generated plus one).
    <dt> <tt>-r</tt>
       <dd> Randomly picks a state from the set of initial states.
    <dt> <tt>-i</tt>
       <dd> Enables the user to interactively pick up an initial state. The
       user is requested to choose a state from a list of possible items
       (every item in the list doesn't show state variables unchanged with
       respect to a previous item). If the number of possible states is too
       high, then the user has to specify some further constraints as
       "simple expression".
    <dt> <tt>-a</tt>
       <dd> Displays all state variables (changed and unchanged with respect
       to a previous item) in an interactive picking. This option
       works only if the <tt>-i</tt> options has been specified.
    <dt> <tt>-c "constraints"</tt>
       <dd> Uses <tt>constraints</tt> to restrict the set of initial states
       in which the state has to be picked.
    <dt> <tt>-s trace.state</tt>
       <dd> Picks state from trace.state label. A new simulation trace will
       be created by copying prefix of the source trace up to specified state.
  </dl> ]

  SideEffects        [The state chosen is stored in the traces_hash table as
  the first state of a new trace]

  SeeAlso            [goto_state simulate]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandSimulate(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Performs a simulation from the current selected state]

  SideEffects        [Generated referenced states traces are stored to be
  analyzed by the user in a second time]

  SeeAlso            [pick_state goto_state]

  CommandName        [simulate]

  CommandSynopsis    [Performs a simulation from the current selected state]

  CommandArguments   [\[-h\] \[-p | -v\] \[-r | -i \[-a\]\]
  [\[-c "constraints"\] | \[-t "constraints"\] ] \[-k steps\]
  ]

  CommandDescription [
  Generates a sequence of at most <tt>steps</tt> states (representing a
  possible execution of the model), starting from the <em>current state</em>.
  The current state must be set via the <em>pick_state</em> or
  <em>goto_state</em> commands.<p>
  It is possible to run the simulation in three ways (according to different
  command line policies):
  deterministic (the default mode), random and interactive.<p>
  The resulting sequence is stored in a trace indexed with an integer number
  taking into account the total number of traces stored in the system. There is
  a different behavior in the way traces are built, according to how
  <em>current state</em> is set: <em>current state</em> is always put at
  the beginning of a new trace (so it will contain at most <it>steps + 1</it>
  states) except when it is the last state of an existent old trace.
  In this case the old trace is lengthened by at most <it>steps</it> states.
  <p>
  Command Options:<p>
  <dl>
    <dt> <tt>-p</tt>
       <dd> Prints current generated trace (only those variables whose value
       changed from the previous state).
    <dt> <tt>-v</tt>
       <dd> Verbosely prints current generated trace (changed and unchanged
       state variables).
    <dt> <tt>-r</tt>
       <dd> Picks a state from a set of possible future states in a random way.
    <dt> <tt>-i</tt>
       <dd> Enables the user to interactively choose every state of the trace,
       step by step. If the number of possible states is too high, then
       the user has to specify some constraints as simple expression.
       These constraints are used only for a single simulation step and
       are <em>forgotten</em> in the following ones. They are to be intended
       in an opposite way with respect to those constraints eventually entered
       with the pick_state command, or during an interactive simulation
       session (when the number of future states to be displayed is too high),
       that are <em>local</em> only to a single step of the simulation and
       are <em>forgotten</em> in the next one.
    <dt> <tt>-a</tt>
       <dd> Displays all the state variables (changed and unchanged) during
       every step of an interactive session. This option works only if the
       <tt>-i</tt> option has been specified.
    <dt> <tt>-c "constraints"</tt>
       <dd> Performs a simulation in which computation is restricted
       to states satisfying those <tt>constraints</tt>. The desired
       sequence of states could not exist if such constraints were too
       strong or it may happen that at some point of the simulation a
       future state satisfying those constraints doesn't exist: in
       that case a trace with a number of states less than
       <tt>steps</tt> trace is obtained. The expression cannot contain
       next operators, and is automatically shifted by one state in
       order to constraint only the next steps
    <dt> <tt>-t "constraints"</tt>
       <dd> Performs a simulation in which computation is restricted
       to states satisfying those <tt>constraints</tt>. The desired
       sequence of states could not exist if such constraints were too
       strong or it may happen that at some point of the simulation a
       future state satisfying those constraints doesn't exist: in
       that case a trace with a number of states less than
       <tt>steps</tt> trace is obtained.  The expression can contain
       next operators, and is NOT automatically shifted by one state
       as done with option -c
    <dt> <tt>-k steps</tt>
       <dd> Maximum length of the path according to the constraints.
       The length of a trace could contain less than <tt>steps</tt> states:
       this is the case in which simulation stops in an intermediate
       step because it may not exist any future state satisfying those
       constraints.
    </dl> ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandGotoState(int argc, char **argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Goes to a given state of a trace]

  CommandName        [goto_state]

  CommandSynopsis    [Goes to a given state of a trace]

  CommandArguments   [\[-h\] state]

  CommandDescription [Makes <tt>state</tt> the <em>current
  state</em>. This command is used to navigate alongs traces
  produced by NuSMV. During the navigation, there is a <em>current
  state</em>, and the <em>current trace</em> is the trace the
  <em>current state</em> belongs to.
    Command options:<p>
    <dl>
      <dt><tt>state: </tt>
      <dd> The state of a trace (trace.state) to be picked.
    </dl>
    ]

  SideEffects        [<em>state</em> became the current state.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandPrintCurrentState(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the current state]

  CommandName        [print_current_state]

  CommandSynopsis    [Prints out the current state]

  CommandArguments   [\[-h\] \[-v\]]

  CommandDescription [Prints the name of the <em>current state</em> if
  defined.<p>

  Command options:<p>
  <dl>
    <dt> <tt>-v</tt>
       <dd> Prints the value of all the state variables of the <em>current
       state</em>.
  </dl>
  ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void simulate\_extend\_print\_curr\_trace(BddEnc\_ptr enc, node\_ptr fragment, boolean printyesno, boolean only\_changes, NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Extends current simulation trace and prints it]

  Description  [Extends current simulation trace by creating a new
                trace for simulation fragment and concatenating it to
                existing one.]

                The trace is printed it if the variable printyesno is
                true (this is set by the user via the command simulate
                options -p or -v). It returns the index of the stored
                trace inside the trace-manager.]

  SideEffects  []

  SeeAlso      [Trace_concat]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{simulateTransSet.c}
		
	\texttt{SimulateTransSet\_ptr SimulateTransSet\_create(BddFsm\_ptr fsm, BddEnc\_ptr enc, bdd\_ptr from\_state, bdd\_ptr next\_states\_set, double next\_states\_count)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Class constructor]

  Description [from_state can be NULL when the set of initial states
  must be queried. next_states_count is checked to be in (1,INT_MAX) ]

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SimulateTransSet\_destroy(SimulateTransSet\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Class destructor]

  Description       []

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr SimulateTransSet\_get\_from\_state(const SimulateTransSet\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Getter for the state the transition set is originating from]

  Description       [Returned BDD is referenced. NULL can be returned if
  this transition set target states are the initial states set]

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SimulateTransSet\_get\_next\_state\_num(const SimulateTransSet\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Returns the cardinality of the target set of states]

  Description       []

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr SimulateTransSet\_get\_next\_state(const SimulateTransSet\_ptr self, int state\_index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Returns the Nth element of the target set of states]

  Description       [Returned BDD is referenced]

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SimulateTransSet\_get\_inputs\_num\_at\_state(const SimulateTransSet\_ptr self, int state\_index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Returns the cardinality of the inputs set going to
  a given state, represented by its index in the set of target states]

  Description       [Returned BDD is referenced. NULL can be returned
  if self represent the initial states set]

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr SimulateTransSet\_get\_input\_at\_state(const SimulateTransSet\_ptr self, int state\_index, int input\_index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          [Returns the Ith input from the set of inputs
  going to the Nth state in the set of target states]

  Description       []

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SimulateTransSet\_get\_state\_input\_at(const SimulateTransSet\_ptr self, int index, bdd\_ptr* state, bdd\_ptr* input)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          []

  Description [Index is the number corresponding to the index the user
  chose after having seen the result of the print method. state and
  input will contain referenced bdds representing the chose
  state-input pair, but input might be NULL for the initial state]

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SimulateTransSet\_get\_state\_input\_rand(const SimulateTransSet\_ptr self, bdd\_ptr* state, bdd\_ptr* input)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          []

  Description       []

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SimulateTransSet\_get\_state\_input\_det(const SimulateTransSet\_ptr self, bdd\_ptr* state, bdd\_ptr* input)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          []

  Description       []

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int SimulateTransSet\_print(const SimulateTransSet\_ptr self, boolean show\_changes\_only, FILE* output)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis          []

  Description       [Returned value is the maximum index that can be chosen by
  user in interactive mode]

  SideEffects       []

  SeeAlso           []

******************************************************************************/

	\end{verbatimtab}
	
	\section{trace}
		
	\section{eval}
		
	\subsection{BaseEvaluator.c}
		
	\texttt{BaseEvaluator\_ptr BaseEvaluator\_create(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseEvaluator class constructor]

  Description        [The BaseEvaluator class constructor]

  SideEffects        []

  SeeAlso            [BaseEvaluator_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BaseEvaluator\_destroy(BaseEvaluator\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseEvaluator class destructor]

  Description        [The BaseEvaluator class destructor]

  SideEffects        []

  SeeAlso            [BaseEvaluator_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BaseEvaluator\_set\_context(BaseEvaluator\_ptr self, const SymbTable\_ptr st, const hash\_ptr env)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes the evaluator with context information]

  Description [Initializes the evaluator with context
  information. This function must be called *before* invoking
  BaseEvaluator_evaluate in order to initialize the context of evaluation]

  SideEffects [The internal cache of the evaluator is cleared]

  SeeAlso     [BaseEvaluator_evaluate]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr BaseEvaluator\_evaluate(BaseEvaluator\_ptr self, const Expr\_ptr const\_expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Evaluates given constant expression]

  Description [Evaluates a constant expression within context given
  using BaseEvaluator_set_context. Returns a constant which is the
  result of the evaluation of the expression. A FAILURE node is
  returned if result could not be computed (e.g. no assignment for an
  identifier could be found in the environment)]

  SideEffects []

  SeeAlso     [BaseEvaluator_set_context]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void base\_evaluator\_init(BaseEvaluator\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseEvaluator class private initializer]

  Description        [The BaseEvaluator class private initializer]

  SideEffects        []

  SeeAlso            [BaseEvaluator_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void base\_evaluator\_deinit(BaseEvaluator\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseEvaluator class private deinitializer]

  Description        [The BaseEvaluator class private deinitializer]

  SideEffects        []

  SeeAlso            [BaseEvaluator_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr base\_evaluator\_resolve(const BaseEvaluator\_ptr self, const Expr\_ptr const\_expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Const expr virtual resolution method]

  Description        [This is intended to be overridden in order to support
  extra types]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr base\_evaluator\_eval\_recur(BaseEvaluator\_ptr self, const Expr\_ptr expr, boolean in\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function is a private service of BaseEvaluator_eval]

  Description [This function is a private service of BaseEvaluator_eval]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void base\_evaluator\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The BaseEvaluator class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Expr\_ptr base\_evaluator\_resolve\_expr (BaseEvaluator\_ptr self, const Expr\_ptr const\_expr)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr base\_evaluator\_make\_failure(const char* tmpl, node\_ptr symbol)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function is a private service of BaseEvaluator_eval]

  Description [This function is a private service of BaseEvaluator_eval]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\section{exec}
		
	\subsection{BDDCompleteTraceExecutor.c}
		
	\texttt{BDDCompleteTraceExecutor\_ptr BDDCompleteTraceExecutor\_create(const BddFsm\_ptr fsm, const BddEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BDDCompleteTraceExecutor class constructor]

  Description        [The BDDCompleteTraceExecutor class constructor]

  SideEffects        []

  SeeAlso            [BDDCompleteTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BDDCompleteTraceExecutor\_destroy(BDDCompleteTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BDDCompleteTraceExecutor class destructor]

  Description        [The BDDCompleteTraceExecutor class destructor]

  SideEffects        []

  SeeAlso            [BDDCompleteTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_complete\_trace\_executor\_init(BDDCompleteTraceExecutor\_ptr self, const BddFsm\_ptr fsm, const BddEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BDDCompleteTraceExecutor class private initializer]

  Description        [The BDDCompleteTraceExecutor class private initializer]

  SideEffects        []

  SeeAlso            [BDDCompleteTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_complete\_trace\_executor\_deinit(BDDCompleteTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BDDCompleteTraceExecutor class private deinitializer]

  Description        [The BDDCompleteTraceExecutor class private deinitializer]

  SideEffects        []

  SeeAlso            [BDDCompleteTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_complete\_trace\_executor\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The BDDCompleteTraceExecutor class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean bdd\_complete\_trace\_executor\_execute(const CompleteTraceExecutor\_ptr complete\_executor, const Trace\_ptr trace, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Executes a trace on the given fsm using BDDs]

  Description [The trace is executed using BDDs. Every transition of
  the trace is tested for compatibility with the model. Trace is
  assumed to be complete and non-empty (i.e. at least one state
  exists). The number of successfullys executed transitions is written
  in *n_steps if a non-NULL pointer is given. If the initial state of
  the trace is not compatible -1 is written.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{BDDPartialTraceExecutor.c}
		
	\texttt{BDDPartialTraceExecutor\_ptr BDDPartialTraceExecutor\_create(const BddFsm\_ptr fsm, const BddEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BDDPartialTraceExecutor class constructor]

  Description        [The BDDPartialTraceExecutor class constructor]

  SideEffects        []

  SeeAlso            [BDDPartialTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BDDPartialTraceExecutor\_destroy(BDDPartialTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BDDPartialTraceExecutor class destructor]

  Description        [The BDDPartialTraceExecutor class destructor]

  SideEffects        []

  SeeAlso            [BDDPartialTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_partial\_trace\_executor\_init(BDDPartialTraceExecutor\_ptr self, const BddFsm\_ptr fsm, const BddEnc\_ptr enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BDDPartialTraceExecutor class private initializer]

  Description        [The BDDPartialTraceExecutor class private initializer]

  SideEffects        []

  SeeAlso            [BDDPartialTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void bdd\_partial\_trace\_executor\_deinit(BDDPartialTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BDDPartialTraceExecutor class private deinitializer]

  Description        [The BDDPartialTraceExecutor class private deinitializer]

  SideEffects        []

  SeeAlso            [BDDPartialTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_partial\_trace\_executor\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The BDDPartialTraceExecutor class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr bdd\_partial\_trace\_executor\_execute (const PartialTraceExecutor\_ptr partial\_executor, const Trace\_ptr trace, const NodeList\_ptr language, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Executes a trace on the fsm given at construction time
  using BDDs]

  Description [The trace is executed using BDDs, that is a proof that
  the fsm is compatible with the trace is built (if such proof
  exists). Incomplete traces are filled-in with compatible values for
  state and input variables.

  Given trace can be either complete or incomplete.

  The number of performed steps (transitions) is returned in *n_steps,
  if a non-NULL pointer is given. If the initial state is not
  compatible -1 is written.]

  SideEffects [None]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr bdd\_partial\_trace\_executor\_generate(const BDDPartialTraceExecutor\_ptr self, const BddStates goal\_states, node\_ptr reachable, int length, const NodeList\_ptr language, const char* trace\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************


  Synopsis    [Generates a complete trace]

  Description [This function is a private service of
  bdd_partial_trace_executor_execute]

  SideEffects [None]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{BaseTraceExecutor.c}
		
	\texttt{int BaseTraceExecutor\_get\_verbosity (BaseTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Getter for the verbosity field]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BaseTraceExecutor\_set\_verbosity (BaseTraceExecutor\_ptr self, int verbosity)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Setter for the verbosity field]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FILE* BaseTraceExecutor\_get\_output\_stream (BaseTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Getter for the output_stream field]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BaseTraceExecutor\_set\_output\_stream (BaseTraceExecutor\_ptr self, FILE* output\_stream)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Setter for the output_stream field]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FILE* BaseTraceExecutor\_get\_error\_stream (BaseTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Getter for the error_stream field]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BaseTraceExecutor\_set\_error\_stream (BaseTraceExecutor\_ptr self, FILE* error\_stream)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Setter for the error_stream field]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL void BaseTraceExecutor\_destroy (BaseTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Virtual destructor for BaseTraceExecutor class]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean trace\_executor\_check\_defines(const BaseTraceExecutor\_ptr self, const Trace\_ptr trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Private service for defines checking]

  Description [Returns true iff values registered in the trace for
  defines actually match evaluated values. If either a value for a
  define is not present in the trace or could not be evaluated (due to
  missing dependencies) it is silently ignored.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_executor\_init(BaseTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseTraceExecutor class private initializer]

  Description        [The BaseTraceExecutor class private initializer]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_executor\_deinit(BaseTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The BaseTraceExecutor class private deinitializer]

  Description        [The BaseTraceExecutor class private deinitializer]

  SideEffects        []

  SeeAlso            [BaseTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_executor\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The BaseTraceExecutor class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{CompleteTraceExecutor.c}
		
	\texttt{boolean CompleteTraceExecutor\_execute (const CompleteTraceExecutor\_ptr self, const Trace\_ptr trace, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Executes a complete trace]

  Description [Tries to execute a complete on FSM provided at
  construction time and returns true iff the trace is compatible with
  the fsm given at construction time. The number of performed steps is
  stored in *n_steps if a non-NULL pointer is given. This is -1 is if
  the Trace has no feasible initial state.]

  SideEffects [none]

  SeeAlso     [PartialTraceExecutor_execute]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{CompleteTraceExecutor\_ptr CompleteTraceExecutor\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CompleteTraceExecutor class constructor]

  Description        [The CompleteTraceExecutor class constructor]

  SideEffects        []

  SeeAlso            [CompleteTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void CompleteTraceExecutor\_destroy(CompleteTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CompleteTraceExecutor class destructor]

  Description        [The CompleteTraceExecutor class destructor]

  SideEffects        []

  SeeAlso            [CompleteTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void complete\_trace\_executor\_init(CompleteTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CompleteTraceExecutor class private initializer]

  Description        [The CompleteTraceExecutor class private initializer]

  SideEffects        []

  SeeAlso            [CompleteTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void complete\_trace\_executor\_deinit(CompleteTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The CompleteTraceExecutor class private deinitializer]

  Description        [The CompleteTraceExecutor class private deinitializer]

  SideEffects        []

  SeeAlso            [CompleteTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean complete\_trace\_executor\_check\_loopbacks (const CompleteTraceExecutor\_ptr self, const Trace\_ptr trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Private service for loopback checking]

  Description [Returns true iff all loopback information for
  trace applies to the trace itself]

  SideEffects [none]

  SeeAlso     [partial_trace_executor_check_loopbacks]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void complete\_trace\_executor\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The CompleteTraceExecutor class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean complete\_trace\_executor\_execute(const CompleteTraceExecutor\_ptr self, const Trace\_ptr trace, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Abstract execution method for complete trace executors]

  Description [This is a pure virtual functions. Every derived class
  must overwrite this function. Raises an assertion if invoked]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{PartialTraceExecutor.c}
		
	\texttt{Trace\_ptr PartialTraceExecutor\_execute (const PartialTraceExecutor\_ptr self, const Trace\_ptr trace, const NodeList\_ptr language, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Executes a partial trace]

  Description [Tries to execute a partial trace on FSM provided at
  construction time. If execution is succesfully completed, a valid
  complete trace is built on language and returned. A NULL Trace is
  retured otherwise.

  The number of performed steps is stored in *n_steps, if n_steps is
  non-NULL. This is -1 if given trace has no feasible initial state.]

  SideEffects [A complete Trace on language is created upon successful
  completion]

  SeeAlso     [CompleteTraceExecutor_execute]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void partial\_trace\_executor\_init(PartialTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PartialTraceExecutor class private initializer]

  Description        [The PartialTraceExecutor class private initializer]

  SideEffects        []

  SeeAlso            [PartialTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void partial\_trace\_executor\_deinit(PartialTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The PartialTraceExecutor class private deinitializer]

  Description        [The PartialTraceExecutor class private deinitializer]

  SideEffects        []

  SeeAlso            [PartialTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean partial\_trace\_executor\_check\_loopbacks (const PartialTraceExecutor\_ptr self, const Trace\_ptr partial\_trace, const Trace\_ptr complete\_trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Private service for loopback checking]

  Description [Returns true iff all loopback information for
  partial_trace applies to the complete trace as well]

  SideEffects [none]

  SeeAlso     [complete_trace_executor_check_loopbacks]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean partial\_trace\_executor\_is\_complete\_state (const PartialTraceExecutor\_ptr self, const Trace\_ptr trace, const TraceIter step)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true iff the given step is a complete assignment
  to state vars in the given trace]

  Description [Returns true iff the given step is a complete assignment
  to state vars in the given trace]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void partial\_trace\_executor\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The PartialTraceExecutor class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr partial\_trace\_executor\_execute(const PartialTraceExecutor\_ptr self, const Trace\_ptr trace, NodeList\_ptr language, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Abstract execution method for partial trace executors]

  Description [This is a pure virtual functions. Every derived class
  must ovewrwrite this function. Raises an assertion if invoked]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SATCompleteTraceExecutor.c}
		
	\texttt{SATCompleteTraceExecutor\_ptr SATCompleteTraceExecutor\_create(const BeFsm\_ptr fsm, const BeEnc\_ptr enc, const BddEnc\_ptr bdd\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The SATCompleteTraceExecutor class constructor]

  Description        [The SATCompleteTraceExecutor class constructor]

  SideEffects        []

  SeeAlso            [SATCompleteTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SATCompleteTraceExecutor\_destroy(SATCompleteTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The SATCompleteTraceExecutor class destructor]

  Description        [The SATCompleteTraceExecutor class destructor]

  SideEffects        []

  SeeAlso            [SATCompleteTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_complete\_trace\_executor\_init(SATCompleteTraceExecutor\_ptr self, const BeFsm\_ptr fsm, const BeEnc\_ptr enc, const BddEnc\_ptr bdd\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The SATCompleteTraceExecutor class private initializer]

  Description        [The SATCompleteTraceExecutor class private initializer]

  SideEffects        []

  SeeAlso            [SATCompleteTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_complete\_trace\_executor\_deinit(SATCompleteTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The SATCompleteTraceExecutor class private deinitializer]

  Description        [The SATCompleteTraceExecutor class private deinitializer]

  SideEffects        []

  SeeAlso            [SATCompleteTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sat\_complete\_trace\_executor\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The SATCompleteTraceExecutor class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean sat\_complete\_trace\_executor\_execute(const CompleteTraceExecutor\_ptr complete\_executor, const Trace\_ptr trace, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Executes a trace on the given fsm using SAT solver]

  Description [The trace is executed using SAT solver, that is a proof
  that the fsm is compatible with the trace is built (if such proof
  exists). Trace is assumed to be complete in order to perform
  execution. If a non complete trace is given, an error is raised.

  The number of performed steps (transitions) is returned. If the
  initial state is not compatible -1 is returned.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline be\_ptr sat\_complete\_trace\_executor\_get\_initial\_state(BeFsm\_ptr be\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the initial state formula]

  Description        [Private service of sat_complete_trace_executor_execute]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline be\_ptr sat\_complete\_trace\_executor\_get\_transition\_relation (BeFsm\_ptr be\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the transition relation formula]

  Description        [Private service of sat_complete_trace_executor_execute]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void bmc\_add\_be\_into\_solver\_positively(SatSolver\_ptr solver, SatSolverGroup group, be\_ptr prob, BeEnc\_ptr be\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Converts Be into CNF, and adds it into a group of a
  solver, sets polarity to 1, and then destroys the CNF.]

  Description [Private service of sat_complete_trace_executor_execute.]

  SideEffects [Outputs into nusmv_stdout the total time of conversion,
  adding, setting polarity and destroying BE.]

  SeeAlso       []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{SATPartialTraceExecutor.c}
		
	\texttt{SATPartialTraceExecutor\_ptr SATPartialTraceExecutor\_create(const BeFsm\_ptr fsm, const BeEnc\_ptr enc, const BddEnc\_ptr bdd\_enc, boolean use\_restart)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The SATPartialTraceExecutor class constructor]

  Description        [The SATPartialTraceExecutor class constructor]

  SideEffects        []

  SeeAlso            [SATPartialTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void SATPartialTraceExecutor\_destroy(SATPartialTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The SATPartialTraceExecutor class destructor]

  Description        [The SATPartialTraceExecutor class destructor]

  SideEffects        []

  SeeAlso            [SATPartialTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_partial\_trace\_executor\_init(SATPartialTraceExecutor\_ptr self, const BeFsm\_ptr fsm, const BeEnc\_ptr enc, const BddEnc\_ptr bdd\_enc, boolean use\_restart)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The SATPartialTraceExecutor class private initializer]

  Description        [The SATPartialTraceExecutor class private initializer]

  SideEffects        []

  SeeAlso            [SATPartialTraceExecutor_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void sat\_partial\_trace\_executor\_deinit(SATPartialTraceExecutor\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The SATPartialTraceExecutor class private deinitializer]

  Description        [The SATPartialTraceExecutor class private deinitializer]

  SideEffects        []

  SeeAlso            [SATPartialTraceExecutor_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr sat\_partial\_trace\_executor\_execute(const PartialTraceExecutor\_ptr partial\_executor, const Trace\_ptr trace, const NodeList\_ptr language, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Partial trace execution method]

  Description [Performs partial trace re-execution. Algorithm is
  selected depending on the value of restart flag given at
  construction time]

  SideEffects [a complete trace is built and returned in case of success]

  SeeAlso     [sat_partial_trace_executor_execute_restart,
  sat_partial_trace_executor_execute_no_restart]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void sat\_partial\_trace\_executor\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The SATPartialTraceExecutor class virtual finalizer]

  Description [Called by the class destructor]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr sat\_partial\_trace\_executor\_execute\_no\_restart (const SATPartialTraceExecutor\_ptr self, const Trace\_ptr trace, const NodeList\_ptr language, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Executes a trace on the given fsm using SAT solver]

  Description [Executes a trace on the fsm given at construction time
  using SAT solver, that is a proof that the fsm is compatible with
  the trace is built (if such proof exists). Incomplete traces are
  filled-in with compatible values for state and input variables.

  Given trace can be either complete or incomplete.

  The number of performed steps (transitions) is returned in *n_steps,
  if it is a non-NULL pointer. If the initial state is not compatible
  -1 is written.]

  SideEffects [a complete trace is built and returned is case of success]

  SeeAlso     [sat_partial_trace_executor_restart]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Trace\_ptr sat\_partial\_trace\_executor\_execute\_restart (const SATPartialTraceExecutor\_ptr self, const Trace\_ptr trace, const NodeList\_ptr language, int* n\_steps)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Executes a trace on the given fsm using SAT solver]

  Description [The trace is executed using SAT, that is a proof that
  the fsm is compatible with the trace is built. Uncomplete traces are
  filled-in with compatible values for state and input
  variables. Restart from complete states is performed.

  If trace is compatible, a new complete trace is registered in the
  TraceManager and its index is written into trace_index;

  The number of performed steps (transitions) is returned. If the
  initial state is not compatible -1 is returned.]

  SideEffects [None]

  SeeAlso     [sat_partial_trace_executor_no_restart]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline be\_ptr sat\_partial\_trace\_executor\_get\_initial\_state(BeFsm\_ptr be\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the initial state formula]

  Description        [Private service of sat_complete_trace_executor_execute]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline be\_ptr sat\_partial\_trace\_executor\_get\_transition\_relation (BeFsm\_ptr be\_fsm)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the transition relation formula]

  Description        [Private service of sat_partial_trace_executor_execute]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void bmc\_add\_be\_into\_solver\_positively(SatSolver\_ptr solver, SatSolverGroup group, be\_ptr prob, BeEnc\_ptr be\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Converts Be into CNF, and adds it into a group of a
  solver, sets polarity to 1, and then destroys the CNF.]

  Description [Private service of sat_partial_trace_executor_execute.]

  SideEffects [Outputs into nusmv_stdout the total time of conversion,
  adding, setting polarity and destroying BE.]

  SeeAlso       []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{traceExec.c}
		
	\texttt{int Trace\_execute\_trace(const Trace\_ptr trace, const CompleteTraceExecutor\_ptr executor)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Complete trace re-execution]

  Description [Complete trace re-execution.  In order to be run, the
  trace must be complete w.r.t. master fsm language. Returns 0 if a
  trace is executed successfully, and 1 otherwise.]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Trace\_execute\_partial\_trace(const Trace\_ptr trace, const PartialTraceExecutor\_ptr executor, const NodeList\_ptr language)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Partial trace re-execution and fill-in]

  Description        [Partial trace re-execution and fill-in.

                      Tries to complete the given trace using the
                      given incomplete trace executor.  If successful,
                      a complete trace is registered into the Trace
                      Manager.

                      0 is returned if trace could be succesfully completed.
                      1 is returned otherwise]

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{loaders}
		
	\subsection{TraceLoader.c}
		
	\texttt{Trace\_ptr TraceLoader\_load\_trace(TraceLoader\_ptr self, const SymbTable\_ptr st, const NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Action associated with the Class TraceLoader.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* TraceLoader\_get\_desc(const TraceLoader\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a short description of the loader.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr trace\_loader\_load(TraceLoader\_ptr self, const SymbTable\_ptr st, const NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Action associated with the Class action.]

  Description [It is a pure virtual function and TraceLoader is an abstract
  base class. Every derived class must ovewrwrite this function. It returns 1
  if operation is successful, 0 otherwise.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_loader\_init(TraceLoader\_ptr self, char* desc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function initializes the loader class.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_loader\_deinit(TraceLoader\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function de-initializes the loader class.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_loader\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finalize method of loader class.]

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TraceXmlLoader.c}
		
	\texttt{TraceXmlLoader\_ptr TraceXmlLoader\_create(const char* xml\_filename, boolean halt\_on\_undefined\_symbols, boolean halt\_on\_wrong\_section)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Constructor]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_xml\_loader\_init(TraceXmlLoader\_ptr self, const char* xml\_filename, boolean halt\_on\_undefined\_symbols, boolean halt\_on\_wrong\_section)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_xml\_loader\_deinit(TraceXmlLoader\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deallocates internal structures]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr trace\_xml\_loader\_load(TraceLoader\_ptr loader, const SymbTable\_ptr st, const NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Read the trace from the XML file]

  Description [Returns a valid trace]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_loader\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Virtual destructor]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_loader\_prepare(TraceXmlLoader\_ptr self, const SymbTable\_ptr st, const NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_loader\_reset(TraceXmlLoader\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Cleans up after reading of xml source]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_loader\_store\_loopbacks(TraceXmlLoader\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Store loopback information and freezes loaded trace]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_loader\_tag\_begin(TraceXmlLoader\_ptr self, const char* name, const char** atts)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis         [Function that gets called when parser encounter start of
                    some tag.]

  Description      []

  SideEffects      []

  SeeAlso          []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_loader\_tag\_end(TraceXmlLoader\_ptr self, const char *name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis        [Function that gets called when end of any tag is
                   encountered by the parser.]

  Description     []

  SideEffects     []

  SeeAlso         []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_loader\_char\_handler(TraceXmlLoader\_ptr self, const char *txt, int txtlen)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Character Handler used by parser.]

Description        []

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline node\_ptr trace\_xml\_loader\_flatten\_symbol(node\_ptr symbol)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service of trace_xml_loader_fill_trace]

  Description        [Private service of trace_xml_loader_fill_trace]

  SideEffects        []

  SeeAlso            [trace_xml_loader_fill_trace]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_report\_invalid\_assignment(TraceXmlLoader\_ptr self, node\_ptr symbol, int reason)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function reports an error/warning message when LHS of
               an assignment is found to be in invalid section]

  Description [Here assignment is invalid if LHS is undefined symbol
               or a symbol which is inconsistent with a given section,
               e.g. input var cannot be in STATE section.

               'all_wrong_symbols' is a hash to remember already
               reported symbols and report them only once. 'isError'
               is a flag to report an error; warning is reported
               otherwise

               The returned value is isError argument. ]

  SideEffects []

  SeeAlso     [trace_xml_loader_fill_trace]

******************************************************************************/

	\end{verbatimtab}
	
	\section{plugins}
		
	\subsection{TraceCompact.c}
		
	\texttt{TraceCompact\_ptr TraceCompact\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates an Compact Plugin and initializes it.]

  Description [Compact plugin constructor. ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_compact\_init(TraceCompact\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes trace compact object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_compact\_deinit(TraceCompact\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deinitializes Explain object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int trace\_compact\_action(const TracePlugin\_ptr plugin)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Action method associated with TraceCompact class.]

  Description [ The action associated with TraceCompact is to print the trace
  in the specified file in compact format.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_compact\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Trace Compact finalize method.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TraceExplainer.c}
		
	\texttt{TraceExplainer\_ptr TraceExplainer\_create(boolean changes\_only)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates an Explainer Plugin and initializes it.]

  Description [Explainer plugin constructor. As arguments it takes the boolean
  variable /"changes_only/". If <tt>changes_only</tt> is 1, than only state
  variables which assume a different value from the previous printed one are
  printed out.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_explainer\_init(TraceExplainer\_ptr self, boolean changes\_only)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes trace explain object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_explainer\_deinit(TraceExplainer\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deinitializes Explain object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int trace\_explainer\_action(const TracePlugin\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Action method associated with TraceExplainer class.]

  Description [ The action associated with TraceExplainer is to print the trace
  on the TraceOpt_output_stream(self->opt). If <tt>changes_only</tt> is 1, than only state variables
  which assume a different value from the previous printed one are printed
  out.]

  SideEffects [<tt>print_hash</tt> is modified.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_explainer\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Trace Explainer finalize method.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TracePlugin.c}
		
	\texttt{int TracePlugin\_action(const TracePlugin\_ptr self, const Trace\_ptr trace, const TraceOpt\_ptr opt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Action associated with the Class TracePlugin.]

  Description [Executes the different action method, corresponding to which
  derived class instance belongs to, on the trace.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TracePlugin\_print\_symbol(const TracePlugin\_ptr self, node\_ptr symb)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TracePlugin\_print\_list(const TracePlugin\_ptr self, node\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TracePlugin\_print\_assignment(const TracePlugin\_ptr self, node\_ptr symb, node\_ptr val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    []

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* TracePlugin\_get\_desc(const TracePlugin\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a short description of the plugin.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int trace\_plugin\_action(const TracePlugin\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Action associated with the Class action.]

  Description [It is a pure virtual function and TracePlugin is an abstract
  base class. Every derived class must ovewrwrite this function. It returns 1
  if operation is successful, 0 otherwise.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_plugin\_init(TracePlugin\_ptr self, char* desc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function initializes the plugin class.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_plugin\_deinit(TracePlugin\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This function de-initializes the plugin class.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_plugin\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Finalize method of plugin class.]

  Description [Pure virtual function. This must be refined by derived classes.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean trace\_plugin\_is\_visible\_symbol(TracePlugin\_ptr self, node\_ptr symb)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Check that node is printable]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TraceTable.c}
		
	\texttt{TraceTable\_ptr TraceTable\_create(TraceTableStyle style)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates an Table Plugin and initializes it.]

  Description [Table plugin constructor. As arguments it takes variable style
  which decides the style of printing the trace. The possible values of the
  style variable may be: TRACE_TABLE_TYPE_ROW and TRACE_TABLE_TYPE_COLUMN.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_table\_init(TraceTable\_ptr self, TraceTableStyle style)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes trace table object.]

  Description [As arguments it takes variable /"style /" to print the trace.
  The possible values for the style may be : TRACE_TABLE_TYPE_ROW and
  TRACE_TABLE_TYPE_COLUMN.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_table\_deinit(TraceTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deinitializes Explain object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int trace\_table\_action(const TracePlugin\_ptr plugin)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Action method associated with TraceTable class.]

  Description [ The action associated with TraceTable is to print the trace
  in the specified file in table format. There are two ways a trace can be
  printed: i). where states are listed row-wise. ii) Where states are listed
  column-wise. This depends on the style variable assoicated with the plugin.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int trace\_table\_print\_column\_style(const TraceTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Print Trace in Table format with each symbols on a seperate
  column.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int trace\_table\_print\_row\_style(const TraceTable\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Print Trace in Table format with each symbol on a seperate
  row.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_table\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Trace Table finalize method.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TraceXmlDumper.c}
		
	\texttt{int trace\_xml\_dumper\_action(TracePlugin\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Action method associated with TraceXmlDumper class.]

  Description [ Given trace is written into the file pointed by
  given additional parameter ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TraceXmlDumper\_ptr TraceXmlDumper\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a XML Plugin for dumping and initializes it.]

  Description [XML plugin constructor. Using this plugin, a trace can
               be dumped to file in XML format]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_xml\_dumper\_init(TraceXmlDumper\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Class initializer]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void trace\_xml\_dumper\_deinit(TraceXmlDumper\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deinitializes the TraceXmlDumper Plugin object.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_xml\_dumper\_finalize(Object\_ptr object, void* dummy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Plugin finalize method.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Trace.c}
		
	\texttt{Trace\_ptr Trace\_create (const SymbTable\_ptr st, const char* desc, const TraceType type, const NodeList\_ptr symbols, boolean is\_volatile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Trace class constructor]

  Description [Allocates and initializes a trace.  In NuSMV, a trace
               is an engine-independent description of a computation
               path for some FSM.  The newly created trace is
               associated with a language, that is a set of symbols
               (variables and defines) that can occur in the trace. In
               addition, a description and a type can be given to a
               trace.

               If the trace is not volatile, all input parameters are
               internally duplicated in an independent copy.  The
               caller is responsible for freeing them. Same for
               volatile traces, made exception for the symbol table,
               since only a reference will be retained. In this case,
               the caller is responsible for freeing them, and take
               care of the symbol table, which must NOT be freed until
               the created trace instance is destroyed.

               Remarks:

               * First step is already allocated for the returned
                 trace.  Use Trace_first_iter to obtain a valid
                 iterator pointing to the initial step. Use
                 Trace_add_step to append further steps.]

  SideEffects []

  SeeAlso     [Trace_first_iter, Trace_append_step, Trace_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Trace\_copy (const Trace\_ptr self, const TraceIter until\_here, boolean is\_volatile)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Trace class copy constructor]

  Description [Returns an independent copy of \"self\" trace. If a
               non-NULL \"until_here\" iterator is passed copying
               process halts when \"until_here\" iterator has been
               reached.  To obtain a full copy, pass TRACE_END_ITER as
               the \"until_here\" paramter. Loopback information is
               propagated to the copy only if a full copy is required.

               If the trace is not volatile, all trace structures are
               internally duplicated in an independent copy. Same for
               volatile traces, made exception for the symbol table,
               since only a reference of the original trace's symbol
               table will be retained. In this case, the caller must
               take care of the original trace symbol table, which
               must NOT be freed until the created trace instance is
               destroyed. In detail:

               - If the original trace is volatile, then it's copy is
                 valid unless the symbol table given at creation time
                 is destroyed. In all other cases, the returned trace
                 is valid.

               - If the original trace is not volatile, then the
                 returned copy is valid as long as the original trace
                 is valid.

               Notice that a volatile copy "C" of a volatile copy "B"
               of a non-volatile trace "A" needs "A" to exist, and so
               on.


               Remarks:

               * The full copy of a frozen trace is a frozen
               trace. Partial copies are always thawed.]

  SideEffects []

  SeeAlso     [Trace_thaw, Trace_freeze, Trace_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr Trace\_concat (Trace\_ptr self, Trace\_ptr* other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Trace concatenation]

  Description [*Destructively* concatenates \"other\" to
               \"self\". That is, \"self\" is appended all available
               data about variables and defines from
               \"*other\". Frozen vars and state vars of the
               conjunction state for both \"self\" and \"other\"
               traces are synctactically checked for
               consistency. Their values are merged in the resulting
               trace.

               Warning: an internal error is raised if an
               inconsistency is detected.

               Returned valued is \"self\".]

  SideEffects [\"self\" is extended, \"*other\" is destroyed and its
               pointer is set to NULL.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Trace\_destroy(Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Trace class destructor]

  Description [Frees all the resources used by \"self\" trace instance]

  SideEffects []

  SeeAlso     [Trace_create, Trace_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{inline TraceIter Trace\_first\_iter (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a trace iterator pointing to the first step of the trace]

  Description [A step is a container for incoming input and next
               state(i.e. it has the form <i, S>)

               The returned step can be used as parameter to all
               Trace_step_xxx functions.

               Remarks:

                 * the first step holds *no* input information.]

  SideEffects []

  SeeAlso     [Trace_last_iter]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{inline TraceIter Trace\_ith\_iter (const Trace\_ptr self, unsigned i)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a trace iterator pointing to the i-th step of the trace]

  Description [Returns a trace iterator pointing to the i-th step of
               the trace.  Counting starts at 1. Thus, here is the
               sequence of first k steps for a trace.

               S1 i2 S2 i3 S3 ... ik Sk

               Remarks:

                 * the first step holds *no* input information.]

  SideEffects []

  SeeAlso     [Trace_first_iter, Trace_last_iter]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{inline TraceIter Trace\_last\_iter (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a trace iterator pointing to the last step of the trace]

  Description [A step is a container for incoming input and next
               state(i.e. it has the form <i, S>)

               The returned step can be used as parameter to all
               Trace_step_xxx functions]

  SideEffects []

  SeeAlso     [Trace_first_iter]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{inline TraceIter TraceIter\_get\_next (const TraceIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a trace iterator pointing to the next step of the
               trace]

  Description [Returns a trace iterator pointing to the next step of
               the trace. TRACE_END_ITER is returned if no such
               iterator exists]

  SideEffects []

  SeeAlso     [TraceIter_get_prev]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{inline TraceIter TraceIter\_get\_prev (const TraceIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a trace iterator pointing to the previous
               step of the trace]

  Description [Returns a trace iterator pointing to the previous step
               of the trace. TRACE_END_ITER is returned if no such
               iterator exists]

  SideEffects []

  SeeAlso     [TraceIter_get_next]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{inline boolean TraceIter\_is\_end(const TraceIter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Iterator-at-end-of-trace predicate]

  Description []

  SideEffects []

  SeeAlso     []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{TraceIter Trace\_append\_step(Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Extends a trace by adding a new step to it]

  Description [A step is a container for incoming input and next
               state(i.e. it has the form <i, S>)

               The returned step can be used as parameter to all
               Trace_step_xxx functions]

  SideEffects []

  SeeAlso     [Trace_create, Trace_step_put_value, Trace_step_get_value,
               Trace_step_get_iter, Trace_step_get_next_value]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_step\_is\_loopback ARGS((Trace\_ptr self, TraceIter step))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tests whether state is \"step\" is a loopback state w.r.t the
               last state in \"self\".]

  Description [This function behaves accordingly to two different modes a trace
               can be: frozen or thawed(default).

               If the trace is frozen, permanent loopback information
               is used to determine if \"step\" has a loopback state.
               No further loopback computation is made.

               If the trace is thawed, dynamic loopback calculation
               takes place, using a variant of Rabin-Karp pattern
               matching algorithm]

  SideEffects []

  SeeAlso     [Trace_create, Trace_step_put_value, Trace_step_get_value,
               Trace_step_get_iter, Trace_step_get_next_value]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_is\_volatile (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Determine whether the \"self\" trace is volatile]

  Description [A volatile trace does not own a symbol table instance,
               so it is valid as long as the symbol table does not
               change and is available. A non-volatile trace instead
               owns a copy of the symbol table given at construction
               time and is completely independand among system changes
               over time]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_is\_frozen (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Determine whether the \"self\" trace is frozen]

  Description [A frozen trace holds explicit information about
              loopbacks and can not be appended a step, or added a
              variable value.

              Warning: after freezing no automatic looback calculation
              will be performed: it is up to the owner of the trace to
              manually add loopback information using
              Trace_step_force_loopback.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_is\_thawed (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Determine whether the \"self\" trace is thawed]

  Description [A thawed trace holds no explicit information about
              loopbacks and can be appended a step and

              Warning: after thawing the trace will not persistently
              retain any loopback information. In particular it is
              *illegal* to force a loopback on a thawed trace.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Trace\_freeze (Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Freezes a trace]

  Description [A frozen trace holds explicit information about
              loopbacks. Its length and assignments are immutable,
              that is it cannot be appended more steps, nor can it
              accept more values that those already stored in it.

              Still it is possible to register/unregister the trace
              and to change its type or description.]

              Warning: After freezing no automatic looback calculation
              will be performed: it is up to the owner of the trace to
              manually add loopback information using
              Trace_step_force_loopback.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Trace\_thaw (Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Thaws a trace]

  Description [A thawed traces holds no explicit information about
              loopbacks and can be appended a step and added values in
              the customary trace building process.

              Warning: after thawing the trace will not persistently
              retain any loopback information. In particular it is
              *illegal* to force a loopback on a thawed trace.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_equals(const Trace\_ptr self, const Trace\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Equality predicate between traces]

  Description [Two traces are equals iff:

              1. They're the same object or NULL.

              or

              2. They have exactly the same language, length,
                 assignments for all variables in all times and
                 the same loopbacks.

                 (Defines are not taken into account for equality.)

              They need not be both frozen of thawed, neither being
              both registered or unregistered. (Of course two traces
              *cannot* have the same ID).]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Trace\_step\_force\_loopback (const Trace\_ptr self, TraceIter step)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Forces a loopback on a frozen trace]

  Description [Use this function to store explicit loopback information
               in a frozen trace. The trace will retain loopback data
               until being thawed again.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_symbol\_in\_language (Trace\_ptr self, node\_ptr symb)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Tests whether a symbol is \"self\"'s language]

  Description [Returns true iff symb is part of the language defined
               for \"self\" defined at creation time.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{SymbTable\_ptr Trace\_get\_symb\_table(Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Exposes Trace internal symbol table]

  Description [Returns the trace symbol table. The symbol table is
               owned by the trace and should *not* be modified in any
               way.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr Trace\_get\_symbols (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Exposes the list of symbols in trace language]

  Description [Returned list belongs to \"self\". Do not change or dispose it.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr Trace\_get\_s\_vars (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Exposes the list of state vars in trace language]

  Description [Returned list belongs to \"self\". Do not change or dispose it.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr Trace\_get\_sf\_vars (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Exposes the list of state-frozen vars in trace language]

  Description [Returned list belongs to \"self\". Do not change or dispose it.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr Trace\_get\_i\_vars (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Exposes the list of input vars in trace language]

  Description [Returned list belongs to \"self\". Do not change or dispose it.]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_is\_complete (Trace\_ptr self, NodeList\_ptr vars, boolean report)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis     [Checks if a Trace is complete on the given set of vars]

  Description  [Checks if a Trace is complete on the given set of vars]

                A Trace is complete iff in every node, all vars are
                given a value

                Remarks:

                * Only input and state section are taken into account.
                Input vars are not taken into account in the first
                step. Defines are not taken into account at all.

                * If result is false and parameter 'report' is true
                then a message will be output in nusmv_stderr with
                some explanation of why the trace is not complete]

  SideEffects   [None]

  SeeAlso       []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* TraceType\_to\_string(const TraceType trace\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a string corresponding to a TraceType.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{EXTERN boolean Trace\_step\_put\_value (Trace\_ptr self, TraceIter step, node\_ptr symb, node\_ptr value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Stores an assignment into a trace step]

  Description [A step is a container for incoming input and next
               state(i.e. it has the form <i, S>)

               \"step\" must be a valid step for the trace.  If symb
               belongs to the language associated to the trace at
               creation time, the normalized value of \"value\" is
               stored into the step. Assignment is checked for type
               correctness.

               Returns true iff the value was succesfully assigned to symb
               in given step of self.

               Remarks:

               * Assignments to symbols not in trace language are
               silently ignored.]

  SideEffects []

  SeeAlso     [Trace_append_step, Trace_step_get_value]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{EXTERN node\_ptr Trace\_step\_get\_value (Trace\_ptr self, TraceIter step, node\_ptr symb)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Retrieves an assignment from a trace step]

  Description [A step is a container for incoming input and next
               state(i.e. it has the form <i, S>)

               \"step\" must be a valid step for the trace.  \"symb\"
               must belong to the language associated to the trace at
               creation time. The value stored into the step is
               returned or Nil if no such value exists.

               Remarks: An internal error is raised if \"symb\" is not
               in trace lanaguage.]

  SideEffects []

  SeeAlso     [Trace_create, Trace_step_put_value, Trace_step_get_value,
               Trace_step_get_iter, Trace_step_get_next_value]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{EXTERN TraceStepIter Trace\_step\_iter (const Trace\_ptr self, const TraceIter step, const TraceIteratorType iter\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Step iterator factory constructor]

  Description [A step is a container for incoming input and next
               state(i.e. it has the form <i, S>)

               \"step\" must be a valid step for the trace. An
               iterator over the assignments in \"step\" is returned.
               This iterator can be used with Trace_step_iter_fetch.

               Hint: do not use this function. Use TRACE_STEP_FOREACH
               macro instead (it is way easier and more readable).]

  SideEffects []

  SeeAlso     [TRACE_STEP_FOREACH]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{EXTERN TraceSymbolsIter Trace\_symbols\_iter (const Trace\_ptr self, TraceIteratorType iter\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Symbols iterator factory constructor]

  Description [An iterator over the symbols in \"self\" is returned.
               This iterator can be used with Trace_symbols_iter_fetch.

               Hint: do not use this function. Use TRACE_SYMBOLS_FOREACH
               macro instead (it is way easier and more readable).]

  SideEffects []

  SeeAlso     [TRACE_SYMBOLS_FOREACH]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{EXTERN boolean Trace\_step\_iter\_fetch(TraceStepIter* step\_iter, node\_ptr* symb, node\_ptr* value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Step iterator next function]

  Description [A step iterator is a stateful iterator which yields
               an single assignment at each call of this function.

               \"step_iter\" must be a valid step iterator for the
               trace. If a valid assignment was found, True is
               returned.  Otherwise False is returned. This indicates
               end of iteration.

               Hint: do not use this function. Use TRACE_SYMBOLS_FOREACH
               macro instead (it is way easier and more readable).]

  SideEffects []

  SeeAlso     [Trace_step_get_iter]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{extern boolean Trace\_symbols\_iter\_fetch(TraceSymbolsIter* symbols\_iter, node\_ptr* symb)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Symbols iterator next function]

  Description [A symbols iterator is a stateful iterator which yields
               a symbols in the trace language at each call of this function.

               \"symbols_iter\" must be a valid symbols iterator for
               the trace. If a symbols is found, True is returned.
               Otherwise False is returned. This indicates end of
               iteration.

               Hint: do not use this function. Use TRACE_SYMBOLS_FOREACH
               macro instead (it is way easier and more readable).]

  SideEffects []

  SeeAlso     [Trace_symbols_get_iter]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Trace\_get\_id(Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the id of given trace.]

  Description [Returns the ID of given trace. A valid id is a
               non-negative number.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Trace\_register(Trace\_ptr self, int id)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the id of given trace.]

  Description [Sets the ID of the given trace. A valid ID is a
               non-negative number.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Trace\_unregister(Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Unregisters a trace]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_is\_registered(const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Checks whether trace is registered with the trace manager.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Trace\_get\_desc (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the description of given trace.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Trace\_set\_desc (Trace\_ptr self, const char* desc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the description of given trace.]

  Description [The string in \"desc\" is duplicated inside the
               trace. The caller can dispose the actual parameter.

               Remarks: NIL(char) is accepted as a non-descriptive
               description.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TraceType Trace\_get\_type (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the type of the trace.]

  Description [For a list of see definition of TraceType enum]

  SideEffects []

  SeeAlso     [TraceType]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Trace\_set\_type(const Trace\_ptr self, TraceType trace\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets the type of the trace.]

  Description [For a list of see definition of TraceType enum]

  SideEffects []

  SeeAlso     [TraceType]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned Trace\_get\_length (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Gets the length of the trace.]

  Description [Length for a trace is defined as the number of the
               transitions in it. Thus, a trace consisting only of an
               initial state is a 0-length trace. A trace with two
               states is a 1-length trace and so forth.]

  SideEffects []

  SeeAlso     [TraceType]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Trace\_is\_empty (const Trace\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Checks whether the trace is empty or not]

  Description [A trace is empty if the length is 0 and there are no
               assignments in the initial states]

  SideEffects []

  SeeAlso     [TraceType]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TraceLabel.c}
		
	\texttt{TraceLabel TraceLabel\_create(int trace\_id, int state\_id)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [TraceLabel Constructor]

  Description [returns a label for the specified trace and state index.]

  SideEffects []

  SeeAlso     [TraceLabel_create_from_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TraceLabel TraceLabel\_create\_from\_string(const char* str)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [TraceLabel Constructor]

  Description [creates the label from the specified string. In case of any
  error, it returns TRACE_LABEL_INVALID as result.

  The string 'str' should follow this format: ^\s*(\d+)\s*\.\s*(-?\d+)$ in which
  the first group matches the trace number and the second matches the state
  number. ]

  SideEffects []

  SeeAlso     [TraceLabel_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceLabel\_get\_trace(TraceLabel self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the trace index associated with the TraceLabel.]

  Description []

  SideEffects []

  SeeAlso     [TraceLabel_get_state]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceLabel\_get\_state(TraceLabel self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the state index associated with the TraceLabel.]

  Description []

  SideEffects []

  SeeAlso     [TraceLabel_get_trace]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TraceManager.c}
		
	\texttt{TraceManager\_ptr TraceManager\_create(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes the TraceManager.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_destroy(TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys the TraceManager with all the registered traces and
  plugins]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_get\_size(const TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the size of the TraceManager.]

  Description [This function returns the number of traces registered with
  traceManager]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_get\_plugin\_size(const TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the total number of plugins registered with
  TraceManager.]

  Description [This function returns the total number of plugins
  registered with traceManager]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_get\_internal\_plugin\_size(const TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns the number of internal plugins registered with
  TraceManager.]

  Description [This function returns the number of internal plugins
  registered with traceManager]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Trace\_ptr TraceManager\_get\_trace\_at\_index(const TraceManager\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the trace stored at given index]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TracePlugin\_ptr TraceManager\_get\_plugin\_at\_index(const TraceManager\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the plugin stored at given index]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_register\_trace(TraceManager\_ptr self, Trace\_ptr trace)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Registers a trace with TraceManager.]

  Description [It registers a trace with the TraceManager and returns
  the corresponding index. The given trace can not be previously
  registered with any Trace Manager.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_register\_plugin(TraceManager\_ptr self, TracePlugin\_ptr plugin)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Registers a plugin with TraceManager.]

  Description [It registers a plugin with the TraceManager and returns the
  corresponding index.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BaseEvaluator\_ptr TraceManager\_get\_evaluator(TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Retrieves currently registered evaluator]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_register\_evaluator(TraceManager\_ptr self, BaseEvaluator\_ptr eval)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Registers an evaluator]

  Description [Registers an evaluator. If some evaluator was already
  registered it is destroyed]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_unregister\_evaluator(TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Unregisters current evaluator]

  Description [Unregisters currently registered evaluator. If some
  evaluator was already registered it is destroyed. If no evaluator
  was registered, no action is performed]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_register\_complete\_trace\_executor(TraceManager\_ptr self, const char* executor\_name, const char* executor\_desc, const CompleteTraceExecutor\_ptr executor)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Registers a complete trace executor plugin with TraceManager.]

  Description [It registers a complete trace executor with the
  TraceManager and returns the corresponding index]

  SideEffects [A previously registered executor (if any existing) is destroyed]

  SeeAlso     [TraceManager_register_partial_trace_executor]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t* TraceManager\_get\_complete\_trace\_executor\_ids (const TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns an array of registered complete trace executor
  IDs. IDs are alphabetically sorted using lexicographical ordering]

  Description [Returned array must be destroyed by the caller]

  SideEffects []

  SeeAlso     [TraceManager_register_complete_trace_executor]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{CompleteTraceExecutor\_ptr TraceManager\_get\_default\_complete\_trace\_executor (const TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns default registered complete trace executor]

  Description [Returns default registered complete trace executor, if
  any. If no executor has yet been registered NULL is returned.]

  SideEffects [none]

  SeeAlso     [TraceManager_register_complete_trace_executor]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PartialTraceExecutor\_ptr TraceManager\_get\_default\_partial\_trace\_executor (const TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns default registered partial trace executor]

  Description [Returns default registered partial trace executor, if
  any. If no executor has yet been registered NULL is returned.]

  SideEffects [none]

  SeeAlso     [TraceManager_register_partial_trace_executor]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_register\_partial\_trace\_executor(TraceManager\_ptr self, const char* executor\_name, const char* executor\_desc, const PartialTraceExecutor\_ptr executor)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Registers a partial trace executor plugin with TraceManager.]

  Description [It registers a partial trace executor with the
  TraceManager and returns the corresponding index.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{array\_t* TraceManager\_get\_partial\_trace\_executor\_ids (const TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns an array of registered partial trace executor
  IDs. IDs are alphabetically sorted using lexicographical ordering]

  Description [Returned array must be destroyed by the caller]

  SideEffects []

  SeeAlso     [TraceManager_register_complete_trace_executor]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_register\_layer(TraceManager\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Registers a new layer name to be used later by the
  explainers when printing symbols. Only the symbols into registered
  layers will be shown.]

  Description [Use this method to control which symbols will be shown
  when a trace is shown. Only symbols occurring inside registered
  layers will be presented by plugins. Warning: before renaming or
  deleting a previoulsy registered layer, the layer should be
  unregistered. If not unregistered, the behaviour is unpredictable.]

  SideEffects []

  SeeAlso     [unregister_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_unregister\_layer(TraceManager\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Unregisters a previoulsy registered layer]

  Description [The given layer must be registered before calling this method,
  otherwise an internal error occurs]

  SideEffects []

  SeeAlso     [register_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TraceManager\_is\_layer\_registered(const TraceManager\_ptr self, const char* layer\_name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if the given layer names was previously
  registered]

  Description []

  SideEffects []

  SeeAlso     [unregister_layer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const array\_t* TraceManager\_get\_registered\_layers(const TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns an array of names (strings) of the registered layers]

  Description [Returned array belongs to self, do not change or delete it]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_execute\_plugin(const TraceManager\_ptr self, const TraceOpt\_ptr opt, int plugin\_index, int trace\_index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Executes the given trace plugin on given trace]

  Description [\"opt\" is either a valid TraceOpt instance or NULL. Defaults
               are provided by the trace manager in the latter case.

               plugin_index is either a non-negative integer, to which
               must correspond a registered plugin, or a negative
               integer. Default plugin is used in the latter case.

               trace_index is either a non_negative integerm to which
               must correspond a valid registered trace, or a negative
               integer. Last registered trace is used in the latter case.]

  SideEffects [none]

  SeeAlso     [TRACE_MANAGER_DEFAULT_PLUGIN, TRACE_MANAGER_LAST_TRACE]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_set\_current\_trace\_number(TraceManager\_ptr self, int trace\_id)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets trace_id as ths current trace of the TraceManager. ]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_get\_current\_trace\_number(TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the trace_id of the current trace of the TraceManager.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_set\_default\_plugin(TraceManager\_ptr self, int plugin\_id)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets plugin_id as ths default_plugin of the TraceManager. ]

  Description [ Default plugin is the plugin to be used to print a trace by
  default.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_get\_default\_plugin(TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the default plugin of the TraceManager.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TraceManager\_is\_plugin\_internal(const TraceManager\_ptr self, int index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true if the plugin whose index is provided is
  internal to NuSMV. It returns false if the given plugin has been
  externally registered.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TraceIter TraceManager\_get\_iterator\_from\_label(TraceManager\_ptr self, TraceLabel label)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a trace iterator pointing to the particular trace step
               indicated by the given label.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TraceManager\_get\_abs\_index\_from\_label(TraceManager\_ptr self, TraceLabel label)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the absolute state index pointed by the label.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TraceManager\_is\_label\_valid(TraceManager\_ptr self, TraceLabel label)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Checks if the label is valid label in a registered trace.]

  Description [This function can be safely used to determine whether a
  label denotes a valid <trace, state> pair. This is guaranteed to
  raise no errors (exceptions, assertions) and should be used before
  any other label-related function to avoid any subsequent failure.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceManager\_init\_plugins(TraceManager\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Registers default plugins.]

  Description [Statically registers available plugins]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* TraceManager\_get\_complete\_trace\_executor\_desc(const TraceManager\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Retrieves description for a registered complete trace executor]

  Description [Retrieves description for a registered complete trace
  executor. The executor must have been previously registered within
  the trace manager using TraceManager_register_complete_trace_executor.

  Trying to retrieve description for a non-registered executor results
  in an assertion failure.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{CompleteTraceExecutor\_ptr TraceManager\_get\_complete\_trace\_executor(const TraceManager\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Retrieves a registered complete trace executor instance
  with given name]

  Description [Returns a valid complete trace executor instance if any
  suitable such object has been previously registered with given name,
  using TraceManager_register_complete_trace_executor. If no such
  object is found, NULL is returned]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* TraceManager\_get\_partial\_trace\_executor\_desc(const TraceManager\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Retrieves description for partial trace executor]

  Description [Retrieves description for partial trace executor
  registered with given name, or NULL if no such executor exists]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{PartialTraceExecutor\_ptr TraceManager\_get\_partial\_trace\_executor(const TraceManager\_ptr self, const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Retrieves partial trace registered with given name]

  Description [Retrieves description for a registered partial trace
  executor. The executor must have been previously registered within
  the trace manager using TraceManager_register_complete_trace_executor.

  Trying to retrieve description for a non-registered executor results
  in an assertion failure.]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TraceManager\_is\_visible\_symbol(TraceManager\_ptr self, node\_ptr symbol)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Checks whether a symbol is visible]

  Description [Returns true iff the symbol is visible according to the
  following criteria:

  1. symbol name does not contain the prefix defined in system
  variable traces_hiding_prefix.

  2. if system variable traces_regexp is not empty, (1)
  holds and symbol name matches the regexp described in
  traces_regexp]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TraceOpt.c}
		
	\texttt{TraceOpt\_ptr TraceOpt\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt class constructor]

  Description        [The TraceOpt class constructor]

  SideEffects        []

  SeeAlso            [TraceOpt_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TraceOpt\_ptr TraceOpt\_create\_from\_env(OptsHandler\_ptr env)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt class constructor]

  Description        [The TraceOpt class constructor]

  SideEffects        []

  SeeAlso            [TraceOpt_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_update\_from\_env(TraceOpt\_ptr self, OptsHandler\_ptr env)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Updates trace options struct with current values in env]

  Description        [Updates trace options struct with current values in env]

  SideEffects        []

  SeeAlso            [TraceOpt_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_destroy(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt class destructor]

  Description        [The TraceOpt class destructor]

  SideEffects        []

  SeeAlso            [TraceOpt_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TraceOpt\_obfuscate(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt obfuscate field getter]

  Description        [The TraceOpt obfuscate field getter]

  SideEffects        []

  SeeAlso            [TraceOpt_set_obfuscate]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_set\_obfuscate(TraceOpt\_ptr self, boolean obfuscate)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt obfuscate field setter]

  Description        [The TraceOpt obfuscate field setter]

  SideEffects        []

  SeeAlso            [TraceOpt_obfuscate]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned TraceOpt\_from\_here(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt from_here field getter]

  Description        [The TraceOpt from_here field getter]

  SideEffects        []

  SeeAlso            [TraceOpt_set_from_here]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_set\_from\_here(TraceOpt\_ptr self, unsigned index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt from_here field setter]

  Description        [The TraceOpt from_here field setter]

  SideEffects        []

  SeeAlso            [TraceOpt_from_here]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned TraceOpt\_to\_here(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt to_here field getter]

  Description        [The TraceOpt to_here field getter]

  SideEffects        []

  SeeAlso            [TraceOpt_set_to_here]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_set\_to\_here(TraceOpt\_ptr self, unsigned index)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt to_here field setter]

  Description        [The TraceOpt to_here field setter]

  SideEffects        []

  SeeAlso            [TraceOpt_to_here]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FILE* TraceOpt\_output\_stream(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt output_stream field getter]

  Description        [The TraceOpt output_stream field getter]

  SideEffects        []

  SeeAlso            [TraceOpt_set_output_stream]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_set\_output\_stream(TraceOpt\_ptr self, FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt output_stream field setter]

  Description        [The TraceOpt output_stream field setter]

  SideEffects        []

  SeeAlso            [TraceOpt_output_stream]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TraceOpt\_show\_defines(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt show_defines field getter]

  Description        [The TraceOpt show_defines field getter]

  SideEffects        []

  SeeAlso            [TraceOpt_set_show_defines]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_set\_show\_defines(TraceOpt\_ptr self, boolean show\_defines)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt show_defines field setter]

  Description        [The TraceOpt show_defines field setter]

  SideEffects        []

  SeeAlso            [TraceOpt_show_defines]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TraceOpt\_show\_defines\_with\_next(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt show_defines_with_next field getter]

  Description        [The TraceOpt show_defines_with_next field getter]

  SideEffects        []

  SeeAlso            [TraceOpt_set_show_defines_with_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_set\_show\_defines\_with\_next(TraceOpt\_ptr self, boolean show\_defines\_with\_next)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt show_defines_with_next field setter]

  Description        [The TraceOpt show_defines_with_next field setter]

  SideEffects        []

  SeeAlso            [TraceOpt_show_defines_with_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* TraceOpt\_hiding\_prefix(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt hiding_prefix field getter]

  Description        [The TraceOpt hiding_prefix field getter]

  SideEffects        []

  SeeAlso            [TraceOpt_set_hiding_prefix]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TraceOpt\_set\_hiding\_prefix(TraceOpt\_ptr self, const char* hiding\_prefix)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt hiding_prefix field setter]

  Description        [The TraceOpt hiding_prefix field setter]

  SideEffects        []

  SeeAlso            [TraceOpt_hiding_prefix]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{regex\_t* TraceOpt\_regexp(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt regexp field getter]

  Description        [The TraceOpt regexp field getter]

  SideEffects        []

  SeeAlso            [TraceOpt_regexp]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_opt\_init(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt class private initializer]

  Description        [The TraceOpt class private initializer]

  SideEffects        []

  SeeAlso            [TraceOpt_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void trace\_opt\_deinit(TraceOpt\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The TraceOpt class private deinitializer]

  Description        [The TraceOpt class private deinitializer]

  SideEffects        []

  SeeAlso            [TraceOpt_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TraceXml.c}
		
	\texttt{TraceXmlTag TraceXmlTag\_from\_string(const char* tag)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [String to XML Tag converter.]

Description        [ Protected function that converts an string to
                     TraceXMLTag ]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* TraceXmlTag\_to\_string(TraceXmlTag tag)}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [XML Tag converter to string converter.]

Description        [ Protected function that converts a TraceXMLTag to
                     a string ]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Trace\_private.c}
		
	\subsection{pkg\_trace.c}
		
	\texttt{void TracePkg\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes the Trace Package.]

  Description [TraceManager get initialized. ]

  SideEffects []

  SeeAlso     [TracePkg_quit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void TracePkg\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Quits the Trace package.]

  Description []

  SideEffects []

  SeeAlso     [TracePkg_init]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TraceManager\_ptr TracePkg\_get\_global\_trace\_manager()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Accessor for the global trace manager]

  Description [Can be called only after initialization of the trace package]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean TracePkg\_set\_default\_trace\_plugin(int dp)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Called when the user selects a trace plugin to be used as
               default]

  Description [Returns true upon success, false otherwise]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int TracePkg\_get\_default\_trace\_plugin()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the trace plugin currently selected as default]

  Description [Returns the trace plugin currently selected as default]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr TracePkg\_get\_filtered\_symbols (const NodeList\_ptr symbols)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the filtered list of symbols]

  Description [Returned list is the result of filtering the input
  list, using standard filtering strategies that apply to symbols in
  traces.

  The returned list must be freed by the caller]

  SideEffects []

  SeeAlso     [TraceManager_is_visible_symbol]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{traceCmd.c}
		
	\texttt{int CommandShowTraces(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Shows the traces generated in a NuSMV session]

  SeeAlso            [pick_state goto_state simulate]

  CommandName        [show_traces]

  CommandSynopsis    [Shows the traces generated in a NuSMV session]

  CommandArguments   [\[ \[-h\] \[-v\] \[-m | -o output-file\] \[-A\]
  -t | \[-d\] -a | trace_number\[.from_state\[:\[to_state\]\]\] \]]

  CommandDescription [ Shows the traces currently stored in system memory, if
  any. By default it shows the last generated trace, if any. A trace number
  can be specified optionally followed by a slice denoting the steps top be
  shown. Negative numbers can be used to denote steps in a right-to-left fashion.
  (i.e. -1 denotes last step, -2 is the previous and so forth.)

  <p> Command Options:<p>
  <dl>
    <dt> <tt>-v</tt>
       <dd> Verbosely prints traces content (all state variables, otherwise
       it prints out only those variables that have changed their value from
       previous state).
    <dt> <tt>-t</tt>
       <dd> Prints only the total number of currently stored traces.
    <dt> <tt>-a</tt>
       <dd> Prints all the currently stored traces.
    <dt> <tt>-A</tt>
       <dd> Prints traces in an anonimized form.
    <dt> <tt>-d</tt>
       <dd> Disables DEFINEs printout in traces
    <dt> <tt>-p trace plugin</tt>
       <dd> Uses the specified trace plugin to explain the trace.
    <dt> <tt>-m</tt>
       <dd> Pipes the output through the program specified
       by the <tt>PAGER</tt> shell variable if defined, else through the
       <tt>UNIX</tt> command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command to <tt>output-file</tt>
    <dt> <tt>trace_number</tt>
       <dd> The (ordinal) identifier number of the trace to be printed.
    <dt> <tt>from_state</tt>
      <dd> Denotes left end of the trace slice to be printed.
    <dt> <tt>to_state</tt>
     <dd> Denotes right end of the trace slice to be printed.
  </dl> ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageShowTraces(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [UsageShowTraces]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandShowPlugins(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Lists out all the available plugins inside the system.]

  SeeAlso            []

  CommandName        [show_plugins]

  CommandSynopsis    [Lists out all the available plugins inside the system. In
  addition, it prints \[D\] in front of the default plugin.]

  CommandArguments   [\[ \[-h\] \[-n plugin_index| -a\]]

  CommandDescription [
  Sets the default plugin to print traces.
  <p> Command Options:<p>
  <dl>
    <dt> <tt>-h</tt>
       <dd> Prints the usage of the command.
    <dt> <tt>-n plugin_index</tt>
       <dd> Prints the description message of the plugin at specified index
       only.
    <dt> <tt>-a</tt>
       <dd> Prints all the available plugins with their description.
  </dl> ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageShowPlugins(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [UsageShowPlugins]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandReadTrace(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [read_trace]

  SeeAlso            [show_traces]

  CommandName        [read_trace]

  CommandSynopsis    [Reads the trace from the specified file into the memory]

  CommandArguments   [ \[-h\] | \[-i filename\] | \[-u\] \[-s\] filename]

  CommandDescription [
  Reads a trace from a specified XML file into the memory.
  <p>
  Command Options:<p>
  <dl>
    <dt> <tt>-h</tt>
       <dd> Prints the usage of the command.
    <dt> <tt>-i filename</tt>
       <dd> Specifies the name of the xml trace file to read (deprecated).
    <dt> <tt>-u</tt>
       <dd> Turns 'undefined symbol' error in a warning.
    <dt> <tt>-s</tt>
       <dd> Turns 'wrong section' error in a warning.
    <dt> <tt>filename</tt>
       <dd> Specifies the name of the xml trace file to read
    </dl>
    ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageReadTrace(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [UsageReadTrace]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandExecuteTraces(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [CommandExecuteTraces]

  SeeAlso            [CommandExecutePartialTraces]

  CommandName        [execute_traces]

  CommandSynopsis    [Executes complete traces on the model FSM]

  CommandArguments   [\[-h\] \[-v\] \[-m | -o output-file\]
                      -e engine \[-a | trace_number\]]

  CommandDescription [Executes traces stored in the Trace Manager.  If
                      no trace is specified, last registered trace is
                      executed. Traces must be complete in order to
                      perform execution.

  <p> Command Options:<p>
  <dl>
    <dt> <tt>-v</tt>
       <dd> Verbosely prints traces execution steps
    <dt> <tt>-a</tt>
       <dd> Prints all the currently stored traces.
    <dt> <tt>-m</tt>
       <dd> Pipes the output through the program specified
       by the <tt>PAGER</tt> shell variable if defined, else through the
       <tt>UNIX</tt> command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command to <tt>output-file</tt>
    <dt> <tt>-e executor</tt>
       <dd> Selects an executor for trace re-execution.
    <dt> <tt>trace_number</tt>
       <dd> The (ordinal) identifier number of the trace to be printed.
  </dl> ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageExecuteTraces ()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [UsageExecuteTraces]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int CommandExecutePartialTraces(int argc, char** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [CommandExecutePartialTraces]

  SeeAlso            [CommandExecuteTraces]

  CommandName        [execute_partial_traces]

  CommandSynopsis    [Executes partial traces on the model FSM]

  CommandArguments   [\[-h\] \[-v\] \[-r\] \[-m | -o output-file\]
                      -e engine \[-a | trace_number\]]

  CommandDescription [Executes traces stored in the Trace Manager.  If
                      no trace is specified, last registered trace is
                      executed. Traces are not required to be
                      complete.  Upon succesful termination, a new
                      complete trace is registered in the Trace
                      Manager.

  <p> Command Options:<p>
  <dl>
    <dt> <tt>-v</tt>
       <dd> Verbosely prints traces execution steps.
    <dt> <tt>-a</tt>
       <dd> Executes all the currently stored traces.
    <dt> <tt>-r</tt>
       <dd> Performs restart on complete states (deprecated).
    <dt> <tt>-m</tt>
       <dd> Pipes the output through the program specified
       by the <tt>PAGER</tt> shell variable if defined, else through the
       <tt>UNIX</tt> command "more".
    <dt> <tt>-o output-file</tt>
       <dd> Writes the output generated by the command to <tt>output-file</tt>
    <dt> <tt>-e engine</tt>
       <dd> Selects an engine for trace re-execution. It must be one of 'bdd',
       'sat'.
    <dt> <tt>trace_number</tt>
       <dd> The (ordinal) identifier number of the trace to be printed.
  </dl> ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int UsageExecutePartialTraces ARGS((void))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [UsageExecutePartialTrace]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int trace\_cmd\_parse\_slice(const char* s, int* trace, int* from, int* to)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service of top level trace execution functions]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{traceEval.c}
		
	\texttt{void trace\_step\_evaluate\_defines(Trace\_ptr trace, const TraceIter step)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Evaluates defines for a trace]

  Description [Evaluates define for a trace, based on assignments to
               state, frozen and input variables.

               If a previous value exists for a define, The mismatch
               is reported to the caller by appending a failure node
               describing the error to the "failures" list. If
               "failures" is NULL failures are silently discarded.  If
               no previous value exists for a given define, assigns
               the define to the calculated value according to vars
               assignments. The "failures" list must be either NULL
               or a valid, empty list.

               0 is returned if no mismatching were detected, 1
               otherwise ]

  SideEffects [The trace is filled with defines, failures list is
               populated as necessary.]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr trace\_make\_failure(const char* tmpl, node\_ptr symbol)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service of trace_evaluate_expr_recur]

  Description        [Private service of trace_evaluate_expr_recur]

  SideEffects        []

  SeeAlso            [Private service of trace_evaluate_expr_recur]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static hash\_ptr trace\_eval\_make\_environment(Trace\_ptr trace, TraceIter step)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Private service of trace_step_evaluate_defines and
  trace_step_check_defines]

  Description [This function builds a local environment for constant
  expressions evaluation]

  SideEffects [none]

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{traceTest.c}
		
	\subsection{traceUtils.c}
		
	\texttt{bdd\_ptr TraceUtils\_fetch\_as\_bdd(Trace\_ptr trace, TraceIter step, TraceIteratorType iter\_type, BddEnc\_ptr bdd\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Extracts assignments in (trace, step) to a set of symbols]

  Description [Builds a bdd representing the assignments from a given
               step in trace. The symbols to be assigned are picked
               according to \"iter_type\". Refer to documentation of
               the TraceIteratorType for possible sets.

               Remarks: returned bdd is referenced]

  SideEffects []

  SeeAlso     []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{be\_ptr TraceUtils\_fetch\_as\_be(Trace\_ptr trace, TraceIter step, TraceIteratorType iter\_type, BeEnc\_ptr be\_enc, BddEnc\_ptr bdd\_enc)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Extracts assignments in (trace, step) to a set of symbols]

  Description [Builds a be representing the assignments from a given
               step in trace. The symbols to be assigned are picked
               according to \"iter_type\". Refer to documentation of
               the TraceIteratorType for possible sets.]

  SideEffects []

  SeeAlso     []

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr TraceUtils\_fetch\_as\_sexp(Trace\_ptr trace, TraceIter step, TraceIteratorType iter\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Extracts assignments in (trace, step) to a set of symbols]

  Description [Builds a sexp representing the assignments from a given
               step in trace. The symbols to be assigned are picked
               according to \"iter_type\". Refer to documentation of
               the TraceIteratorType for possible sets.

               Remarks: returned expression is find-node'd]

  SideEffects []

  SeeAlso     [TraceUtils_fetch_as_big_and]

*****************************************************************************/

	\end{verbatimtab}
	
	\texttt{Expr\_ptr TraceUtils\_fetch\_as\_big\_and(Trace\_ptr trace, TraceIter step, TraceIteratorType iter\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Extracts assignments in (trace, step) to a set of symbols]

  Description [Do the same thing as TraceUtils_fetch_as_sexp, but do not
               simplify or reorder the pointers of expressions created.]

  SideEffects []

  SeeAlso     [TraceUtils_fetch_as_sexp]

*****************************************************************************/

	\end{verbatimtab}
	
	\section{trans}
		
	\section{bdd}
		
	\subsection{BddTrans.c}
		
	\texttt{BddTrans\_ptr BddTrans\_create(DdManager* dd\_manager, const ClusterList\_ptr clusters\_bdd, bdd\_ptr state\_vars\_cube, bdd\_ptr input\_vars\_cube, bdd\_ptr next\_state\_vars\_cube, const TransType trans\_type, const ClusterOptions\_ptr cl\_options)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the transition relation from a provided
  cluster list.]

  Description        [None of given arguments will become owned by self. 
  You should destroy cl_options by yourself.
  This is a specialized version of constructor to build BddTrans 
  based on ClusterList]

  SideEffects        []

  SeeAlso            [BddTrans_generic_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{BddTrans\_ptr BddTrans\_generic\_create( void* transition, void* (*trans\_copy)(void* transition), void (*trans\_destroy)(void* transition), bdd\_ptr (*trans\_compute\_image)(void* transition, bdd\_ptr bdd, TransImageKind kind), bdd\_ptr (*trans\_compute\_k\_image)(void* transition, bdd\_ptr bdd, int k, TransImageKind kind), bdd\_ptr (*trans\_get\_monolithic\_bdd)(void* transition), void (*trans\_synchronous\_product)(void* transition1, void* const transition2), void (*trans\_print\_short\_info)(void* transition, FILE* file) )}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the transition relation]

  Description        [This is a generic version of BddTrans constructor.
  It takes a generic data structure 'transition' and functions to manipulate
  with it. Ownership of 'transition' is passed to self and 
  will be destroyed during BddTrans destruction by 'destroy' function.

  All the parameters are used just to set up struct BddTrans_TAG.
  See it for the description of, and constraints on, the parameters.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddTrans\_apply\_synchronous\_product(BddTrans\_ptr self, const BddTrans\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performs the synchronous product between two trans]

  Description [The result goes into self and contained forward and backward
  cluster lists would be rescheduled. Other will remain unchanged. ]

  SideEffects [self will change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_monolithic\_bdd(BddTrans\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a monolithic BDD representing the whole
  transition relation.]

  Description [Warning: computation of such BDD may be very 
  time- and memory-consuming.
  
  Invoker has to free the returned BDD.]

  SideEffects [self will change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_forward\_image\_state(const BddTrans\_ptr self, bdd\_ptr s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the forward image by existentially quantifying
  over state variables only.]

  Description        [Returned bdd is referenced]

  SideEffects        [self keeps the ownership of the returned instance.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_forward\_image\_state\_input(const BddTrans\_ptr self, bdd\_ptr s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the forward image by existentially quantifying
  over both state and input variables.]

  Description        [Returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_backward\_image\_state(const BddTrans\_ptr self, bdd\_ptr s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the backward image by existentially quantifying
  over state variables only.]

  Description        [Returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_backward\_image\_state\_input(const BddTrans\_ptr self, bdd\_ptr s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the backward image by existentially quantifying
  over both state and input variables.]

  Description        [Returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_k\_forward\_image\_state(const BddTrans\_ptr self, bdd\_ptr s, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the k forward image by existentially quantifying
  over state variables only.]

  Description        [Returned bdd is referenced]

  SideEffects        [self keeps the ownership of the returned instance.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_k\_forward\_image\_state\_input(const BddTrans\_ptr self, bdd\_ptr s, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the k forward image by existentially quantifying
  over both state and input variables.]

  Description        [Returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_k\_backward\_image\_state(const BddTrans\_ptr self, bdd\_ptr s, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the k backward image by existentially quantifying
  over state variables only.]

  Description        [Returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr BddTrans\_get\_k\_backward\_image\_state\_input(const BddTrans\_ptr self, bdd\_ptr s, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the k backward image by existentially 
  quantifying over both state and input variables.]

  Description        [Returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void BddTrans\_print\_short\_info(const BddTrans\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints short info associated to a Trans]

  Description        [Prints info about the size of each cluster in
  forward/backward transition relations]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Object\_ptr bdd\_trans\_copy(const Object\_ptr object)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy constructor]

  Description        [Return a copy of the self.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static boolean bdd\_trans\_debug\_partitioned(const ClusterBasedTrans\_ptr self, const ClusterList\_ptr basic\_clusters, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Checks the equality between given Monolithic and 
  Partitioned transition relations.]

  Description        [ It checks the equality in terms of transition relation
  and quantification schedule. ]
 

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void* bdd\_trans\_clusterlist\_copy(void* transition)}
	\begin{verbatimtab}
		
/**Function********************************************************************
  Synopsis     [Implementation of 'copy' parameter of
  BddTrans_generic_create having 'transition' of type ClusterBasedTrans_ptr]

  Description [See struct BddTrans_TAG for specification of this function]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_trans\_clusterlist\_destroy(void* transition)}
	\begin{verbatimtab}
		
/**Function********************************************************************
  Synopsis     [Implementation of 'destroy' parameter of
  BddTrans_generic_create having 'transition' of type ClusterBasedTrans_ptr]

  Description [See struct BddTrans_TAG for specification of this function]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr bdd\_trans\_clusterlist\_compute\_image(void* transition, bdd\_ptr bdd, TransImageKind kind)}
	\begin{verbatimtab}
		
/**Function********************************************************************
  Synopsis     [Implementation of 'compute_image' parameter of
  BddTrans_generic_create having 'transition' of type ClusterBasedTrans_ptr]

  Description [See struct BddTrans_TAG for specification of this function]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr bdd\_trans\_clusterlist\_compute\_k\_image(void* transition, bdd\_ptr bdd, int k, TransImageKind kind)}
	\begin{verbatimtab}
		
/**Function********************************************************************
  Synopsis     [Implementation of 'compute_k_image' parameter of
  BddTrans_generic_create having 'transition' of type ClusterBasedTrans_ptr]

  Description [See struct BddTrans_TAG for specification of this function]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr bdd\_trans\_clusterlist\_get\_monolithic\_bdd(void* transition)}
	\begin{verbatimtab}
		
/**Function********************************************************************
  Synopsis     [Implementation of 'get_monolithic_bdd' parameter of
  BddTrans_generic_create having 'transition' of type ClusterBasedTrans_ptr]

  Description [See struct BddTrans_TAG for specification of this function]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_trans\_clusterlist\_synchronous\_product(void* transition1, void* const transition2)}
	\begin{verbatimtab}
		
/**Function********************************************************************
  Synopsis     [Implementation of 'synchronous_product' parameter of
  BddTrans_generic_create having 'transition' of type ClusterBasedTrans_ptr]

  Description [See struct BddTrans_TAG for specification of this function]
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void bdd\_trans\_clusterlist\_print\_short\_info(void* transition, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************
  Synopsis     [Implementation of 'print_short_info' parameter of
  BddTrans_generic_create having 'transition' of type ClusterBasedTrans_ptr]

  Description [See struct BddTrans_TAG for specification of this function]
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Cluster.c}
		
	\texttt{Cluster\_ptr Cluster\_create(DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The "Cluster" class constructor.]

  Description        [Allocates and initializes a cluster.]

  SideEffects        []

  SeeAlso            [Object_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Cluster\_is\_equal(const Cluster\_ptr self, const Cluster\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if two clusters are equal]

  Description [Notice that the check is performed only using the
  \"curr_cluster\" field of the Cluster class.]

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr Cluster\_get\_trans(const Cluster\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrives the clusterized transition relation of the self
  .]

  Description        [Returned bdd will be referenced]

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Cluster\_set\_trans(Cluster\_ptr self, DdManager* dd, bdd\_ptr current)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the transition relation inside the cluster]

  Description        [The given bdd will be referenced. Previously stored bdd 
  will be released]

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr Cluster\_get\_quantification\_state\_input(const Cluster\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a pointer to the list of variables (both state 
  and input vars) to be quantified.]

  Description        [Returns a pointer to the list of variables to be
  quantified respect to the transition relation inside the cluster. Returned
  bdd is referenced.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Cluster\_set\_quantification\_state\_input(Cluster\_ptr self, DdManager* dd, bdd\_ptr new)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of variables (both state and input vars) to
  be quantified inside the cluster.]

  Description        [Given value will be referenced]

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr Cluster\_get\_quantification\_state(const Cluster\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a pointer to the list of variables (state vars
  only) to be quantified]

  Description        [Returned value is referenced]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Cluster\_set\_quantification\_state(Cluster\_ptr self, DdManager* dd, bdd\_ptr new)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the list of variables (state vars only) to be
  quantified inside the cluster]

  Description        [Given value will be referenced]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ClusterIwls95\_ptr ClusterIwls95\_create(DdManager* dd, const ClusterOptions\_ptr cl\_options, const double v\_c, const double w\_c, const double x\_c, const double y\_c, const double z\_c, const double min\_c, const double max\_c)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ "ClusterIwls95" Class constructor.]
  
  Description        [Allocates and initializes a cluster for IWLS95 alg.
  Please note that returned object can be casted to a cluster class instance.
  Use Cluster_destroy to destroy returned instance. The parameters passed to
  the constructor correspond to cluster options and 7 different factors (v_c,
  w_c, x_c, y_c, z_c, min_c and max_c) as explained in IWLS95 paper.]

  SideEffects        []

  SeeAlso            [Cluster_destroy Cluster_create]
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{double ClusterIwls95\_get\_benefit(const ClusterIwls95\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the value of the "benifit" variable. ]

  Description        []

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_init(Cluster\_ptr self, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the cluster with default values.]

  Description        []

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_deinit(Cluster\_ptr self, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deinitializes the cluster. ]

  Description        [Releases the contained bdds.]

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_finalize(Object\_ptr object, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Finalize a cluster.]

  Description        []

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Object\_ptr cluster\_copy(const Object\_ptr object)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Copies the given cluster.]

  Description        [It is the callback function that the copy constructor
  virtually calls.]

  SideEffects        []

  SeeAlso            [cluster_copy_aux]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_copy\_aux(const Cluster\_ptr self, Cluster\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [It helps to copy the given cluster.]

  Description        []

  SideEffects        []

  SeeAlso            [cluster_copy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_iwls95\_init(ClusterIwls95\_ptr self, DdManager* dd, const ClusterOptions\_ptr cl\_options, const double v\_c, const double w\_c, const double x\_c, const double y\_c, const double z\_c, const double min\_c, const double max\_c)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Initializes Iwls95 cluster. ]

  Description        [The parameters passed to this private function correspond
  to cluster options and different factors (v_c, w_c, x_c, y_c, z_c, min_c and
  max_c) as explained in IWLS95 paper.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_iwls95\_deinit(ClusterIwls95\_ptr self, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Deinitialized Iwls95 cluster. ]

  Description        []

  SideEffects        []

  SeeAlso     []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_iwls95\_finalize(Object\_ptr object, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Finalize iwls95 cluster. ]

  Description        [ The virtual destructor calls this method to destroy the
  instance self.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Object\_ptr cluster\_iwls95\_copy(const Object\_ptr object)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Copies iwls95 cluster.]

  Description        [ Callback function that copy constructor virtually calls
  to copy an instance of iwls95 cluster.]

  SideEffects        []

  SeeAlso            [cluster_iwls95_copy_aux]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_iwls95\_copy\_aux(const ClusterIwls95\_ptr self, ClusterIwls95\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ It helps to copy iwls95 cluster.]

  Description        []

  SideEffects        []

  SeeAlso            [cluster_iwls95_copy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ClusterList.c}
		
	\texttt{ClusterList\_ptr ClusterList\_create(DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Class ClusterList Constructor. ]

  Description        [ The reference to DdManager passed here is internally
  stored but self does not become owner of it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterList\_destroy(ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ ClusterList Class dectructor.]

  Description        [ Destroys the cluster list and all cluster instances
  inside it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ClusterList\_ptr ClusterList\_copy(const ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a copy of the "self".]

  Description        [Duplicates self and each cluster inside it.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterList\_reverse(ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Reverses the list of clusters. ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int ClusterList\_remove\_cluster(ClusterList\_ptr self, Cluster\_ptr cluster)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deletes every occurrence of the given cluster from the
  self.]

  Description        [Returns the number of removed occurrences. Clusters found
  won't be destroyed, simply their references will be removed from the list]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ClusterList\_ptr ClusterList\_apply\_monolithic(const ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ It returns a monolithic transition cluster corresponding
  to the cluster list of the "self".]

  Description        ["self" remains unchanged. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ClusterList\_ptr ClusterList\_apply\_threshold(const ClusterList\_ptr self, const ClusterOptions\_ptr cl\_options)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [It returns a threshold based cluster list corresponding
  to the cluster list of the "self".]

  Description        ["self" remains unchanged.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int ClusterList\_length(const ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Returns the number of the clusters stored in "self".]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterList\_prepend\_cluster(ClusterList\_ptr self, Cluster\_ptr cluster)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prepends given cluster to the list]

  Description        [List becomes the owner of the given cluster]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterList\_append\_cluster(ClusterList\_ptr self, Cluster\_ptr cluster)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Appends given cluster to the list]

  Description        [List becomes the owner of the given cluster, if the user
  is going to call standard destructor]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ClusterListIterator\_ptr ClusterList\_begin(const ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Returns an Iterator to iterate the self.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Cluster\_ptr ClusterList\_get\_cluster(const ClusterList\_ptr self, const ClusterListIterator\_ptr iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Returns the cluster kept at the position given by the
  iterator]

  Description        [self keeps the ownership of the returned cluster]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterList\_set\_cluster(ClusterList\_ptr self, const ClusterListIterator\_ptr iter, Cluster\_ptr cluster)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Sets the cluster of the "self" at the position given by
  iterator "iter" to cluster "cluster".]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterList\_build\_schedule(ClusterList\_ptr self, bdd\_ptr state\_vars\_cube, bdd\_ptr input\_vars\_cube)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [It builds the quantification schedule of the variables
  inside the clusters of the "self".]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr ClusterList\_get\_image\_state(const ClusterList\_ptr self, bdd\_ptr s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Computes the image of the given bdd "s" using the
  clusters of the "self" while quantifying state vars only.]

  Description        [Returned bdd is referenced]]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr ClusterList\_get\_image\_state\_input(const ClusterList\_ptr self, bdd\_ptr s)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the image of the given bdd "s" using the
  clusters of the "self" while quantifying both state and input vars.]

  Description        [Returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr ClusterList\_get\_k\_image\_state(const ClusterList\_ptr self, bdd\_ptr s, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Computes the k image of the given bdd "s" using the
  clusters of the "self" while quantifying state vars only.]

  Description        [Returned bdd is referenced]]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr ClusterList\_get\_k\_image\_state\_input(const ClusterList\_ptr self, bdd\_ptr s, int k)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the k image of the given bdd "s" using the
  clusters of the "self" while quantifying both state and input vars.]

  Description        [Returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr ClusterList\_get\_monolithic\_bdd(const ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the monolithic bdd corresponding to the "self".]

  Description        [The returned bdd is referenced]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{bdd\_ptr ClusterList\_get\_clusters\_cube(const ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Computes the cube of the set of support of all the clusters]

  Description [Given a list of clusters, it computes their set of support.
  Returned bdd is referenced.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ClusterList\_ptr ClusterList\_apply\_iwls95\_partition(const ClusterList\_ptr self, bdd\_ptr state\_vars\_cube, bdd\_ptr input\_vars\_cube, bdd\_ptr next\_state\_vars\_cube, const ClusterOptions\_ptr cl\_options)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Orders the clusters according to the IWLS95 algo. to
  perform image computation.]

  Description        [This function builds the
  data structures to perform image computation. <br>
  This process consists of the following steps:<br>
  <ol>
  <li> Ordering of the clusters given as input accordingly with the
       heuristic described in IWLS95.</li>
  <li> Clustering of the result of previous step accordingly the
       threshold value stored in the option \"image_cluster_size\".</li>
  <li> Ordering of the result of previous step accordingly with the
       heuristic described in IWLS95.</li>
  </ol>]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterList\_apply\_synchronous\_product(ClusterList\_ptr self, const ClusterList\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Performs the synchronous product between two cluster lists]

  Description [All clusters into other are simply appended to "self".
  The result goes into "self", no changes on other. The scheduling
  is done with the variables from both cluster lists.
  Precondition: both lists should have scheduling done.]

  SideEffects [self will change]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterList\_print\_short\_info(const ClusterList\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints size of each cluster of the "self"]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ClusterListIterator\_ptr ClusterListIterator\_next(const ClusterListIterator\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Use to iterate a list]

  Description        [Advances the iterator by one.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ClusterListIterator\_is\_end(const ClusterListIterator\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Use to check if iterator is at the end of list]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ClusterList\_check\_equality(const ClusterList\_ptr self, const ClusterList\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if two clusters list are logically equivalent]

  Description        [It compares BDDs not Clusters.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ClusterList\_check\_schedule(const ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check the schedule for self. Call after you applied the
  schedule]

  Description        [Let Ci and Ti be the ith cube and relation in the list.
  The schedule is correct iff<br>
  <ol>
  <li> For all Tj: j > i, S(Tj) and S(Ci) do not intersect, i.e., the
  variables which are quantified in Ci should not appear in the
  Tj for j>i.</li>
  </ol><br>

  where S(T) is the set of support of the BDD T.
  Returns true if the schedule is correct, false otherwise.
  This function is implemented for checking the correctness of the
  clustering algorithm only.<br>
  This function returns true if schedule is correct, false otherwise.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr cluster\_list\_get\_image(const ClusterList\_ptr self, bdd\_ptr s, bdd\_ptr (*cluster\_getter)(const Cluster\_ptr cluster))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Computes the image from a given set of states
  "s".]

  Description        [ The parameters passed to this function includes pointer
  to "self", set of states "s", and a function pointer that retrives from any
  cluster in "self" a cube of variables for existential quantification. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr cluster\_list\_get\_k\_image(const ClusterList\_ptr self, bdd\_ptr s, int k, bdd\_ptr (*cluster\_getter)(const Cluster\_ptr cluster))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Use to compute the k image from a given set of states
  "s".]

  Description        [ The parameters passed to this function includes pointer
  to "self", set of states "s", value "k", and a function pointer that retrives
  from any cluster in "self" a cube of variables for existential quantification. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ClusterList\_ptr cluster\_list\_iwls95\_order(const ClusterList\_ptr self, bdd\_ptr state\_vars\_cube, bdd\_ptr input\_vars\_cube, bdd\_ptr next\_state\_vars\_cube, const ClusterOptions\_ptr cl\_options)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [It orders a copy of the "self" according to the IWLS95
  algorithm and returns the copy.]

  Description        ["self" remains unchanged.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ClusterList\_ptr cluster\_list\_apply\_iwls95\_info(const ClusterList\_ptr self, bdd\_ptr state\_vars\_cube, bdd\_ptr input\_vars\_cube, bdd\_ptr next\_state\_vars\_cube, const ClusterOptions\_ptr cl\_options)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ It applies iwls95 info passed as parameters to a copy of
  the "self" and returns it.]

  Description        ["self" remains unchanged. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static bdd\_ptr cluster\_list\_get\_supp\_Q\_Ci(const ClusterList\_ptr self, const Cluster\_ptr Ci)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the set Supp_Q_Ci.]

  Description        [Computes the set of present an primary input variables
  that belong to the set of support of cluster Ci, and do not belong to the
  set of support of each cluster Cj, for j != i and Cj belonging to the set
  of the not yet ordered clusters. The set Supp_Q_Ci is formally defined as:
  Supp_Q_Ci = {v \in (PS U PI) /\ v \not\in S(T_Cj), Cj != Ci, Cj \in Q}]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void clusterlist\_build\_schedule\_recur(ClusterList\_ptr self, const ClusterListIterator\_ptr iter, const bdd\_ptr s\_cube, const bdd\_ptr si\_cube, bdd\_ptr* acc\_s, bdd\_ptr* acc\_si)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Helps to compute the quantification schedule]

  Description        [ Auxiliary recursive private function that computes the
  quantification schedule. The <tt>acc_s</tt> and <tt>acc_si</tt> must be freed
  by the caller.]

  SideEffects        [<tt>acc_s</tt> and <tt>acc_si</tt> are modified
  and must be freed by the caller.]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void cluster\_list\_destroy\_weak(ClusterList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [private function to weakly destroy the "self" ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ClusterList\_ptr cluster\_list\_copy(const ClusterList\_ptr self, const boolean weak\_copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Dups a given list of clusters, copying clusters
  depending on the value in weak_copy]

  Description        [If weak_copy is true (internal use only) copied list must
  be destroyed by calling the weak private destructor
  cluster_list_destroy_weak]

  SideEffects        []

  SeeAlso            [cluster_list_destroy_weak]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ClusterList\_ptr cluster\_list\_apply\_threshold(const ClusterList\_ptr self, const int threshold, const boolean append)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Forms the clusters of relations based on BDD
  size heuristic]

  Description        [The clusters are formed by taking the product in order.
  Once the BDD size of the current cluster reaches a threshold, a new cluster
  is created. It takes the value of "threshold" as parameter and returns the
  cluster of relation based on BDD size heuristic.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static ClusterList\_ptr cluster\_list\_apply\_threshold\_affinity(const ClusterList\_ptr self, const int threshold, const boolean append)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [OPTIMIZED affinity clustering]

  Description        [This function aggregate clusters conjoining
  clusters that have highest affinity measure until they exceeds the
  specified threshold. <br>

  <b>Remark:</b> The number of clusters in self whose BDD size is
  below the threshold has a drammatic impact on the performance of
  this function. Indeed, the size of the heap used to order pair of
  clusters w.r.t. their affinity measure is proportional to the
  combination of N elements of class 2: C(N,K) = N!*(K!*(N-K)!).]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int clusterlist\_affinity\_move\_clusters(const ClusterList\_ptr self, ClusterList\_ptr new\_list, const int threshold, const boolean append, node\_ptr* list\_ref, heap \_heap)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy over threshold clusters in result list or in support
  list & heap.]

  Description        [It doesn't modify the input list. ]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static double compute\_bdd\_affinity(DdManager* dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compute the Affinity of two BDD clusters.]

  Description        [Compute the Affinity between two BDD clusters as
  suggested by Moon, Hachtel, Somenzi in BBT paper. Affinity is the ratio
  between the number of shared variables and the number of the union of
  all variables (intersection/union)]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static double compute\_bdd\_affinity(DdManager* dd, bdd\_ptr a, bdd\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Compute the Affinity of two BDD clusters.]

  Description        [Compute the Affinity between two BDDs. This is
  an alternative definition to the one suggested by by Moon, Hachtel,
  Somenzi in BBT paper.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static af\_support\_list\_entry* support\_list\_entry\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Allocates an af_support_list_entry]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static af\_support\_pair* af\_support\_pair\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Allocates a pair]

  Description        [Allocates a pair]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr support\_list\_heap\_add(node\_ptr list, heap \_heap, DdManager* dd, Cluster\_ptr cluster, boolean owns\_cluster)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Add a new entry in support list and new pairs in heap.]

  Description        [Pairs with a dead cluster are skipped]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void support\_list\_del(af\_support\_list\_entry* asle, DdManager* dd)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Delete a cluster in support list.]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ClusterOptions.c}
		
	\texttt{ClusterOptions\_ptr ClusterOptions\_create(OptsHandler\_ptr opt)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ "ClusterOptions" class constructor.]

  Description        [  Creates a ClusterOptions instance. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterOptions\_destroy(ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ ClusterOption class destructor.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int ClusterOptions\_get\_threshold(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Returns the threshold field. ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ClusterOptions\_is\_affinity(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Checks whether Affinity is enabled. ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ClusterOptions\_clusters\_appended(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Returns true if clusters must be appended, false if 
  clusters must be prepended ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ClusterOptions\_is\_iwls95\_preorder(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Checks whether preordering is enabled. ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int ClusterOptions\_get\_cluster\_size(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Returns the cluster_size field. ]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int ClusterOptions\_get\_w1(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Retrieves the parameter w1. ]

  Description        [ According to the IWLS95 paper parameter w1 represents the
  weight attached to the R^1_c( =v_c/w_c) factor.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int ClusterOptions\_get\_w2(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the parameter w2. ]

  Description        [According to the IWLS95 paper parameter w2 represents the
    weight attached to the R^2_c( =w_c/x_c) factor.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int ClusterOptions\_get\_w3(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the parameter w3. ]

  Description        [According to the IWLS95 paper parameter w3 represents the
    weight attached to the R^3_c( =y_c/z_c) factor.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int ClusterOptions\_get\_w4(const ClusterOptions\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves the parameter w4. ]

  Description        [According to the IWLS95 paper parameter w4 represents the
    weight attached to the R^4_c( =min_c/max_c) factor.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void ClusterOptions\_print(const ClusterOptions\_ptr self, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ Prints all the cluster options inside the specified file.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\section{generic}
		
	\subsection{GenericTrans.c}
		
	\texttt{GenericTrans\_ptr GenericTrans\_create(const TransType trans\_type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Builds the transition relation]

  Description        [None of given arguments will become owned by self. 
  You should destroy cl_options by yourself.]

  SideEffects        []

  SeeAlso            [Object_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TransType GenericTrans\_get\_type(const GenericTrans\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrives the type of trans structure.]

  Description        [Returns the type of the transition relation structure passed as 
  the arguments. ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{TransType TransType\_from\_string(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ string to TransType]

  Description        [Converts the given transition type from string "name" to
  TransType object. The possible values of name can be "Monolithic",
  "Threshold", or "Iwls95CP".]

  SideEffects        [None.]

  SeeAlso            [ TransType_to_string ]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* TransType\_to\_string(const TransType self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [ TransType to string ]

  Description        [ It takes TransType of self and returns a string
  specifying the type of the transition relation. Returned string is statically
  allocated and must not be freed. ]

  SideEffects        []

  SeeAlso            [TransType_from_string]

******************************************************************************/

	\end{verbatimtab}
	
	\section{utils}
		
	\subsection{NodeGraph.c}
		
	\texttt{NodeGraph\_ptr NodeGraph\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NodeGraph class constructor]

  Description        [The NodeGraph class constructor]

  SideEffects        []

  SeeAlso            [NodeGraph_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeGraph\_destroy(NodeGraph\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NodeGraph class destructor]

  Description        [The NodeGraph class destructor]

  SideEffects        []

  SeeAlso            [NodeGraph_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeGraph\_add\_children(NodeGraph\_ptr self, node\_ptr var, const Set\_t children)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeGraph\_remove\_nodes(NodeGraph\_ptr self, const Set\_t nodes)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeGraph\_clear\_removed\_nodes(NodeGraph\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean NodeGraph\_is\_empty(const NodeGraph\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the graph is empty, taking into account
                      of all removed vertices]

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t NodeGraph\_get\_leaves(const NodeGraph\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the nodes which have the given number of
                      children, but those nodes that have been
                      removed. Set must be freed by the caller]

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Set\_t NodeGraph\_get\_parents(const NodeGraph\_ptr self, node\_ptr child)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns all the parents of a given node]

  Description [Returns a set of all parents of a give node (add with 
  NodeGraph_add_children and with child being among children).
  If a parent node has been marked as removed it is not returned.
  
  The returned set has to be returned by caller.]

  SideEffects []

  SeeAlso     []
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeGraph\_print(const NodeGraph\_ptr self, FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints out the graph]

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static assoc\_retval node\_graph\_assoc\_free\_set(char* key, char* data, char* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void node\_graph\_init(NodeGraph\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NodeGraph class private initializer]

  Description        [The NodeGraph class private initializer]

  SideEffects        []

  SeeAlso            [NodeGraph_create]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void node\_graph\_deinit(NodeGraph\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The NodeGraph class private deinitializer]

  Description        [The NodeGraph class private deinitializer]

  SideEffects        []

  SeeAlso            [NodeGraph_destroy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{NodeList.c}
		
	\texttt{NodeList\_ptr NodeList\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a new list]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr NodeList\_create\_from\_list(node\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Constructor that creates a new NodeList that is a wrapper
  of the given list.]

  Description [self becomes a user of the given list, meaning that
  when self will be destroyed, it will not free the given list. It is a caller
  responsability of freeing the passed list when possible.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_destroy(NodeList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class destroyer]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr NodeList\_copy(const NodeList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copies self and returns a new independent instance]

  Description        [Linear time]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_append(NodeList\_ptr self, node\_ptr elem)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Appends a new node at the end of the list]

  Description        [Constant time]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_prepend(NodeList\_ptr self, node\_ptr elem)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prepends a new node at the beginning of the list]

  Description        [Constant time]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_insert\_before(NodeList\_ptr self, ListIter\_ptr iter, node\_ptr elem)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Inserts the given element before the node pointed by the
  given iterator]

  Description        [Constant time]

  SideEffects        []

  SeeAlso            [insert_after]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_insert\_after(NodeList\_ptr self, ListIter\_ptr iter, node\_ptr elem)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Inserts the given element after the node pointed by the
  given iterator]

  Description [Constant time. iter must be a valid iterator, and
  cannot point at the end of the list]

  SideEffects ]

  SeeAlso            [insert_before]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr NodeList\_remove\_elem\_at(NodeList\_ptr self, ListIter\_ptr iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the element pointed by the given iterator]

  Description        [The removed element is returned. The given iterator
                      won't be usable anymore. Constant time.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int NodeList\_remove\_elems(NodeList\_ptr self, const NodeList\_ptr other, NodeListPred disposer, void* disposer\_arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the elements that are found in other list]

  Description        [Linear time on the size of self. No iteration is done
  if other is empty.  If not NULL, disposer is called on the removed
  element, passing disposer_arg. If the disposer returns true, the
  removal continues, otherwise it aborts and returns with the list as
  it is at that time. Returns the number of removed elements]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int NodeList\_foreach(NodeList\_ptr self, NODE\_LIST\_FOREACH\_FUN\_P foo, void* user\_data)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Walks through the list, calling given funtion
  for each element]

  Description        [Returns the number of visited nodes, which can be less
  than the total number of elements since foo can decide to interrupt
  the walking]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int NodeList\_get\_length(const NodeList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of elements in the list]

  Description        [Constant time]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_reverse(NodeList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reverses the list]

  Description        [Linear time]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_concat(NodeList\_ptr self, const NodeList\_ptr src)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Append all the elements in src to self]

  Description        [Cost is linear in the size of src]

  SideEffects        [Content of self will change is src is not empty]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_concat\_unique(NodeList\_ptr self, const NodeList\_ptr src)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Append all the elements in src to self, but only if
  each element does not occur in self already]

  Description        [Cost is linear in the size of src]

  SideEffects        [Content of self may change is src is not empty]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean NodeList\_belongs\_to(const NodeList\_ptr self, node\_ptr elem)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if given element belongs to self

  Description [Constant time (cost may depend on the internal hash
  status)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ListIter\_ptr NodeList\_search(const NodeList\_ptr self, NodeListPred pred, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Searches for an element in a list such that
  'pred'(element, 'arg') returns true.]

  Description        [Linear time search is used to
  find an element 'elem' such that function pred(elem, arg) returns
  true.
  An iterator pointing to the found element is returned.
  If the element is not found then ListIter_is_end will be true on the
  returned iterator.

  If pred is NULL then a search for an element equal to arg will be
  done (as if pred was a pointer-equality predicate). If pred is
  NULL and the searched element does not occur in the list, the
  function returns in constant time.]

  SideEffects        []

  SeeAlso            [ListIter_is_end, NodeList_belongs_to]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int NodeList\_count\_elem(const NodeList\_ptr self, node\_ptr elem)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the number of occurrences of the given element]

  Description        [Constant time (cost may depend on the internal hash
  status)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ListIter\_ptr NodeList\_get\_first\_iter(const NodeList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the iterator pointing to the first element]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr NodeList\_get\_elem\_at(const NodeList\_ptr self, const ListIter\_ptr iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the element at the position pointed by iter]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ListIter\_ptr ListIter\_get\_next(const ListIter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the following iterator]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean ListIter\_is\_end(const ListIter\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if the iteration is given up]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{ListIter\_ptr ListIter\_get\_end()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the end iterator]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr NodeList\_map(const NodeList\_ptr self, NPFN foo)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new list that contains all elements of
  self, after applying function foo to each element]

  Description [Elements are not copied. Returned list must be
  freed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{NodeList\_ptr NodeList\_filter(const NodeList\_ptr self, BPFN foo)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a new list that contains all elements of
  self for which function foo returned true. ]

  Description [Elements are not copied. Returned list must be
  freed by the caller]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void NodeList\_print\_nodes(const NodeList\_ptr self, FILE* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the nodes in the list, separated by spaces]

  Description        [The list must be a list of actual node_ptr]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void node\_list\_init(NodeList\_ptr self, node\_ptr list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private initializer]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void node\_list\_deinit(NodeList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private deinitializer]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline Link* node\_list\_alloc\_link(const NodeList\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Retrieves a Link instance in the pool]

  Description        [Retrieves a Link instance in the pool.
                      If the pool is empty, allocates LINK_CHUNK_SIZE
                      new Link instances (by using only 1 ALLOC)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void node\_list\_free\_link(const NodeList\_ptr self, Link* link)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Puts the given Link instance in the pool]

  Description        [Puts the given Link instance in the pool]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static inline void node\_list\_update\_count(const NodeList\_ptr self, const node\_ptr elem, const boolean deleting)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Keeps count of the number of duplicate elements
                      in the list]

  Description        [Keeps count of the number of duplicate elements
                      in the list]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Olist.c}
		
	\texttt{Olist\_ptr Olist\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates an instance of a One-directional List ]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_destroy (Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys a list instance]

  Description [The memory used by the list will be freed. 
  Note: memory occupied by the elements is not freed! It is the user
  responsibility.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Olist\_ptr Olist\_copy(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of a given list]

  Description        [Note: input list does not change]

  SideEffects        []

  SeeAlso            [Olist_copy_reversed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Olist\_ptr Olist\_copy\_reversed(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of a given list with the order of elements 
  reversed]

  Description        [Note: input list does not change]

  SideEffects        []

  SeeAlso            [Olist_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Olist\_ptr Olist\_copy\_without\_element(Olist\_ptr self, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of a given list 
  with all its elements except the provided one.]

  Description        [Note: input list does not change]

  SideEffects        []

  SeeAlso            [Olist_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_reverse(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reverse the order of elements in the list]

  Description        [Note: all existing iterators pointing to the 
  elements of the list may become invalid.]

  SideEffects        []

  SeeAlso            [Olist_copy_reversed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_move(Olist\_ptr self, Olist\_ptr to\_list, Oiter iter\_to)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Moves the content from one list to another]

  Description [The content is moved from "self" to "to_list" before
  given iterator. If "to_list" is not empty the moved content is
  added at the end (appended).

  Note: all existing iterators pointing to the elements of the list
  may become invalid.]

  SideEffects        []

  SeeAlso            [Olist_copy_reversed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_move\_all(Olist\_ptr self, Olist\_ptr to\_list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Moves the content from one list to another]

  Description [This function is similar to Olist_move
  with iter_to set up to point past the last element.
  Note: all existing iterators pointing to the elements of the list
  may become invalid.]

  SideEffects        []

  SeeAlso            [Olist_move]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_clean(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Removes all the elements of the list, i.e.  makes the
  list empty]

  Description [ After this function call, Olist_is_empty(self)
  always returns true.

  Note: all existing iterators pointing to the elements of the list
  becomes invalid.]

  SideEffects        []

  SeeAlso            [Olist_copy_reversed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_prepend(Olist\_ptr self, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds at the beginning of a list a new element]

  Description        []

  SideEffects        []

  SeeAlso            [Olist_append]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_append(Olist\_ptr self, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Adds at the end of a list a new element]

  Description []

  SideEffects []

  SeeAlso     [Olist_prepend]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Olist\_delete\_first(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes a first element of a list]

  Description [The removed element is returned.
  Precondition: the list must not be empty.

  NOTE: all iterators already pointing to the element next to the
  first one will become invalid.  Any operations on them are
  prohibited.  
  ADVICE: do not use several iterators over the same list
  if deletion operation is possible.]

  SideEffects []

  SeeAlso     [Olist_append, Olist_prepend]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Olist\_get\_size(const Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the size of a list]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Olist\_is\_empty(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true iff the list is empty]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Olist\_contains(const Olist\_ptr self, const void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true iff the list contains the given element]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Olist\_remove(Olist\_ptr self, const void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Tries to remove all the occurrencies of the specified
                      element from the list, returns true if an element was
                      removed, false otherwise]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Oiter Olist\_first(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns an iterator pointing to a first element of a
  list]

  Description [If the list is empty the iterator will point past
  the last element of a list (i.e. past the list). This means
  function Oiter_is_end will return true in this case.  NOTE: there
  is no need to free the iterator after using it.  NOTE: it is
  allowed to assign one iterator to another one.  NOTE: deletion
  the elements of the list may make the iterator invalid (see
  corresponding delete functions).  ]

  SideEffects        []

  SeeAlso            [Oiter_last, Oiter_is_end, Oiter_next, Oiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Oiter Olist\_last(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Returns an iterator pointing to a last element of a
  list]

  Description [If the list is empty the iterator will point past
  the last element of a list (i.e. past the list). This means
  function Oiter_is_end will return true in this case.  NOTE: there
  is no need to free the iterator after using it.  NOTE: it is
  allowed to assign one iterator to another one.  NOTE: deletion
  the elements of the list may make the iterator invalid (see
  corresponding delete functions).  ]

  SideEffects        []

  SeeAlso            [Oiter_first, Oiter_is_end, Oiter_next, Oiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Olist\_iter\_is\_first(Olist\_ptr self, Oiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if iter corresponds to the first iter.]

  Description        [Returns true if iter corresponds to the first iter.]

  SideEffects        []

  SeeAlso            [Oiter_is_end, Oiter_next, Oiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Olist\_iter\_is\_last(Olist\_ptr self, Oiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true if iter corresponds to the first iter.]

  Description        [Returns true if iter corresponds to the first iter.]

  SideEffects        []

  SeeAlso            [Oiter_is_end, Oiter_next, Oiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Oiter\_is\_end(Oiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true iff an iterator points past the last element
  of a list.]

  Description        [The iterator must have been created with function
  Olist_first or Olist_next]

  SideEffects        []

  SeeAlso            [Olist_first, Oiter_next, Oiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Oiter\_make\_end(Oiter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Sets the given iterator to the end, so that Oiter_is_end
  returns true for it.]

  Description [This can useful in functions which need to produce
  an iterator.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Oiter Oiter\_next(Oiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an iterator pointing to the next element 
  of a list w.r.t. the element pointed by a provided iterator.]

  Description        [Precondition: this function can be applied only
  if Oiter_is_end(iter) returns false]

  SideEffects        []

  SeeAlso            [Olist_first, Oiter_is_end, Oiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Oiter\_element(Oiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a value of a list element pointed by 
  a provided iterator]

  Description        [Precondition: this function can be applied only
  if Oiter_is_end(iter) returns false]

  SideEffects        []

  SeeAlso            [Olist_first, Oiter_is_end, Oiter_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Oiter\_set\_element(Oiter iter, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets a new value to the list element pointed by 
  a provided iterator]

  Description        [Precondition: this function can be applied only
  if Oiter_is_end(iter) returns false]

  SideEffects        []

  SeeAlso            [Olist_first, Oiter_is_end, Oiter_next, Oiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Oiter Olist\_insert\_after(Olist\_ptr self, Oiter iter, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Insert a new element into the list "self" directly after
  an element pointed by "iter"]

  Description [Precondition: iter must point to elements of list "self"
  and NOT past the last element of the list.
  If iter is not an iterator of list self there will be 
  problems with memory which are usually very difficult to debug.

  NOTE: after the function call iterators pointing to the element
  after iter will now point to the newly inserted element. All other
  existing iterators (including iter) will point to the same element
  as before. 

  Returns an iterator pointing to the newly inserted element.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Oiter Olist\_insert\_before(Olist\_ptr self, Oiter iter, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Insert a new element into the list "self" directly before
  an element pointed by "iter"]

  Description [Precondition: iter must point to elements of list "self"
  or past the last element of the list.

  If the iterator points past the last element of a list then
  this function is equivalent to calling Olist_append(self, element).

  NOTE: All existing iterators equal to "iter" (and iter itself) 
  after insertion will point to the newly created element.
  All other iterators remain intact.

  Returns an iterator pointing to the newly inserted element.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Oiter Olist\_delete(Olist\_ptr self, Oiter iter, void** element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes an element pointed by an iterator from a list]

  Description [
  
  Precondition: iter must point to elements of list "self" and
  NOT the past the last element of the list.

  The element being removed is returned in argument *element (only if
  element != NULL).
  
  Returns an iterator pointing to the element after removed one.
  
  NOTE: all iterators already pointing to the next element will become invalid. 
  Any operations on them are prohibited.
  ADVICE: do not use several iterators over the same list if deletion 
  operation is possible.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_sort(Olist\_ptr self, int (*cmp)(void* el1, void* el2))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sorts the list in place]

  Description        [mergesort is used to sort the list. 
  worst case complexisty O(N log2(N)).

  cmp is comparison function returning value v, v < 0, v == 0 or v > 0]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Olist\_print\_node(Olist\_ptr self, FILE* output)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Prints the elements of the list using 
  print_node and putting string ", " between elements]

  Description        [
  Precondition: all elements of the list have to be node_ptr.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void olist\_testing\_function()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [This is a test function]

  Description [Prototype of this function is not defined anywhere.
  Thus to use it define the prototype where you want and then invoke
  this function.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void olist\_init(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the memory for a list instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void olist\_deinit(Olist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deinitializes the memory from a list]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Pair.c}
		
	\texttt{Pair\_ptr Pair\_create(void* first, void* second)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Pair class constructor]

  Description        [The Pair class constructor]

  SideEffects        []

  SeeAlso            [Pair_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Pair\_init(Pair\_ptr self, void* first, void* second)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Pair class initializer]

  Description        [The Pair class initializer.  Use this function if
                      declaring a Pair in the stack ]

  SideEffects        []

  SeeAlso            [Pair_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Pair\_destroy(Pair\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Pair class destructor]

  Description        [The Pair class destructor]

  SideEffects        []

  SeeAlso            [Pair_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Pair\_freeze(Pair\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Mark the Pair instance as read-only]

  Description        [Mark the Pair instance as read-only.
                      This is usefull when debugging, and using a Pair
                      instance as key of an hash table, for example]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Pair\_is\_freezed(const Pair\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the Pair is freezed]

  Description        [Check if the Pair is freezed (i.e. it is
                      read-only)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Pair\_get\_first(const Pair\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the first value of the Pair instance]

  Description        [Get the first value of the Pair instance]]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Pair\_get\_second(const Pair\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the second value of the Pair instance]

  Description        [Get the second value of the Pair instance]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Pair\_set\_first(Pair\_ptr self, void* first)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the first value for the Pair instance.]

  Description        [Sets the first value for the Pair instance.
                      The Pair must not be frozen]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Pair\_set\_second(Pair\_ptr self, void* second)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the second value for the Pair instance]

  Description        [Sets the second value for the Pair instance.
                      The Pair must not be frozen]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Pair\_set\_values(Pair\_ptr self, void* first, void* second)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets both the values for the Pair instance]

  Description        [Sets both the values for the Pair instance.
                      The Pair must not be frozen]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Pair\_compare(const Pair\_ptr a, const Pair\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pair comparison function]

  Description        [Pair comparison function.
                      Returns if the two Pair instances are the
                      equal.  No distinction between frozen / unfrozen
                      instances is made.
                      Can be casted to ST_PFICPCP.

                      Casts to char* are added to prevent "warning: pointer of
                      type ‚Äòvoid *‚Äô used in subtraction".]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Pair\_hash(const Pair\_ptr self, int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pair hash function]

  Description        [Pair hash function.
                      No distinction between frozen / unfrozen
                      instances is made.
                      Can be casted to ST_PFICPI]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void pair\_init(Pair\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Pair class private initializer]

  Description        [The Pair class private initializer]

  SideEffects        []

  SeeAlso            [Pair_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void pair\_deinit(Pair\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Pair class private deinitializer]

  Description        [The Pair class private deinitializer]

  SideEffects        []

  SeeAlso            [Pair_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Slist.c}
		
	\texttt{Slist\_ptr Slist\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates an instance of a Simple List ]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Slist\_destroy (Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys a list instance]

  Description [The memory used by the list will be freed.
  Note: memory occupied by the elements is not freed! It is the user
  responsibility.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr Slist\_copy(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of a given list]

  Description        [Note: input list does not change]

  SideEffects        []

  SeeAlso            [Slist_copy_reversed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Slist\_ptr Slist\_copy\_reversed(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of a given list with the order of elements
  reversed]

  Description        [Note: input list does not change]

  SideEffects        []

  SeeAlso            [Slist_copy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Slist\_reverse(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Reverse the order of elements in the list]

  Description        [Note: all existing iterators pointing to the
  elements of the list may become invalid.
  Do not use them after this function call.]

  SideEffects        []

  SeeAlso            [Slist_copy_reversed]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Slist\_push(Slist\_ptr self, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Adds at the beginning of a list a new element]

  Description        []

  SideEffects        []

  SeeAlso            [Slist_append]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{unsigned int Slist\_get\_size(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the size of a list]

  Description        []

  SideEffects        []

  SeeAlso            [Slist_append]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Slist\_pop(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes an element at the beginning of a list]

  Description [The removed element is returned.
  Existing iterators pointing to the first element become invalid
  after this function call and cannot be used any further.]

  SideEffects        []

  SeeAlso            [Slist_append]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Slist\_top(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the element at the beginning of a list]

  Description        []

  SideEffects        []

  SeeAlso            [Slist_append]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Slist\_is\_empty(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true iff the list is empty]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Slist\_equals(const Slist\_ptr self, const Slist\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true iff the two lists are equal
                      (contains the same elements in the same order)]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Siter Slist\_first(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an iterator pointing to a first element of a list]

  Description        [If the list is empty the iterator will point past
  the last element of a list (i.e. past the list). This means function
  Siter_is_end will return true in this case.
  NOTE: there is no need to free the iterator after using it.
  NOTE: it is allowed to assign one iterator to another one.
  ]

  SideEffects        []

  SeeAlso            [Siter_is_end, Siter_next, Siter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Siter\_is\_end(Siter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true iff an iterator points past the last element
  of a list.]

  Description        [The iterator must have been created with function
  Slist_first or Slist_next]

  SideEffects        []

  SeeAlso            [Slist_first, Siter_next, Siter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Siter\_make\_end(Siter* iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Sets the given iterator to the end, so that Siter_is_end
  returns true for it.]

  Description [This can useful in functions which need to produce
  an iterator.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Siter Siter\_next(Siter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an iterator pointing to the next element
  of a list w.r.t. the element pointed by a provided iterator.]

  Description [ Precondition: this function can be applied only if
  Siter_is_end(iter) returns false.  ]

  SideEffects        []

  SeeAlso            [Slist_first, Siter_is_end, Siter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Siter\_element(Siter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns a value of a list element pointed by
  a provided iterator]

  Description        [Precondition: this function can be applied only
  if Siter_is_end(iter) returns false]

  SideEffects        []

  SeeAlso            [Slist_first, Siter_is_end, Siter_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Siter Slist\_find(Slist\_ptr self, const void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns an iterator pointing to the first element
  equal to the given one]

  Description        [
  If there is no such element then on the returned iterator
  Siter_is_end(iter) will be true.]


  SideEffects        []

  SeeAlso            [Slist_first, Siter_is_end, Siter_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Slist\_contains(Slist\_ptr self, const void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks whether the specified element is in the list or not]

  Description        []

  SideEffects        []

  SeeAlso            [Slist_first, Siter_is_end, Siter_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Slist\_remove(Slist\_ptr self, const void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes all the occurrencies of specified element if
                      present in the list. Returns true if the element was
                      removed, false otherwise]

  Description        []

  SideEffects        []

  SeeAlso            [Slist_first, Siter_is_end, Siter_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Slist\_destroy\_and\_free\_elements(Slist\_ptr self, Slist\_free\_function f)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destroys the list and every element contained using the 
                      specified function]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Slist\_clear(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pops all the elements of this list]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Slist\_append(Slist\_ptr self, const Slist\_ptr other)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Appends two lists modifying self]

  Description        []

  SideEffects        [self is extended]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Slist\_sort(Slist\_ptr self, int (*cmp)(void* el1, void* el2))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sorts the list in place]

  Description        [mergesort is used to sort the list. 
  worst case complexisty O(N log2(N)).

  cmp is comparison function returning value v, v < 0, v == 0 or v > 0]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void slist\_init(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the memory for a list instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void slist\_deinit(Slist\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deinitializes the memory from a list]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Sset.c}
		
	\texttt{Sset\_ptr Sset\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates an instance of a Sorted Set ]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Sset\_destroy (Sset\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys a set instance]

  Description [The memory used by the set will be freed. 
  Note: memory occupied by the elements is not freed! It is the user
  responsibility.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Sset\_ptr Sset\_copy (const Sset\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a copy of the given set instance]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Sset\_ptr Sset\_copy\_func (const Sset\_ptr self, void* (*func)(void*))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a copy of the given set instance, copying each
               element by calling given function.]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Sset\_insert(Sset\_ptr self, signed long long int key, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Insert an element "element" under 
  the key "key" into the set]

  Description [
  Returns true if a new node was created and false if a node with the given
  key has already existed (in which case nothing is changed).
  Note: all the existing iterators remain valid.
  ]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ssiter Sset\_find(Sset\_ptr self, signed long long int key)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Looks up for an element with a given key]

  Description [Returns an iterator pointing to the found element.
  If there is no such element Ssiter_is_valid() returns false
  on the returned iterator.

  The operation takes O(log2 N) time (N is the size of the set).]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ssiter Sset\_find\_le(Sset\_ptr self, signed long long int key)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis         [Looks up for the closest element whose key is less than
                    or equal a given key.]

  Description      [Returns an iterator pointing to the found element.
                    If there is no such element Ssiter_is_valid()
                    returns false on the returned iterator.

                    The operation takes O(log2 N) time (N is the
                    size of the set).]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ssiter Sset\_find\_ge(Sset\_ptr self, signed long long int key)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis         [Looks up for the closest element whose key is greater than
                    or equal a given key.]

  Description      [Returns an iterator pointing to the found element.
                    If there is no such element Ssiter_is_valid()
                    returns false on the returned iterator.

                    The operation takes O(log2 N) time (N is the
                    size of the set).]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ssiter Sset\_find\_insert(Sset\_ptr self, signed long long int key, boolean* is\_found)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Looks up for an element with a given key and if does not 
  exist it is created]

  Description [Returns an iterator pointing to the found (created) element.
  If is_found != NULL, *is_found is set to true if the element 
  was found and false if it was created.

  The operation takes O(log2 N) time (N is the size of the set).]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Sset\_delete(Sset\_ptr self, signed long long int key, boolean* is\_found)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes an element with key "key" from the set.]

  Description [The returned value is the element stored in the deleted node.
  If parameter "is_found" is no NULL, "*is_found" is set to
  true if such an element with the provided key was found, and false otherwise.
  Note: if an element with the key does no exist in the set the 
  returned value is NULL.

  The operation takes O(log2 N) time (N is the size of the set).]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Sset\_delete\_iter(Sset\_ptr self, Ssiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes an element pointed by the iterator.]

  Description [
  Precondition: the iterator should be returned one by
  Ssiter_first, Ssiter_last, Ssiter_next, Ssiter_prev. 
  Precondition: an element pointed by iterator has to belong to this set.
  Precondition: Ssiter_is_valid(iter) has to be return true.

  WARNING: After this function call the iterator will have undefined value
  and no operation is allowed with it except assignment of a new value.
  
  The operation takes O(log2 N) time (N is the size of the set).]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{size\_t Sset\_get\_size(Sset\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns the number of elements in a set]

  Description [Constant time operation]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Sset\_is\_empty(Sset\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true iff the set is empty]

  Description [Constant time operation]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ssiter Sset\_first(Sset\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns an iterator pointing to a first element of a set,
  i.e. element with the smallest key.]

  Description [If the set is empty Ssiter_is_valid() will be false
  on the returned iterator.
  NOTE: there is no need to free the iterator after using it.
  NOTE: it is allowed to assign one iterator to another one.
  NOTE: The operation may take up to O(log2 N) time (N is the size of the set). 
  ]

  SideEffects []

  SeeAlso     [Ssiter_is_end, Ssiter_next, Ssiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ssiter Sset\_last(Sset\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns an iterator pointing to the last element of a set,
  i.e. element with the greatest key.]

  Description [If the set is empty Ssiter_is_valid() will be false
  on the returned iterator.
  NOTE: there is no need to free the iterator after using it.
  NOTE: it is allowed to assign one iterator to another one.
  NOTE: The operation may take up to O(log2 N) time (N is the size of the set). 
  ]

  SideEffects []

  SeeAlso     [Ssiter_is_end, Ssiter_next, Ssiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ssiter Ssiter\_next(Ssiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns an iterator pointing to the next element 
  of a set w.r.t. the element pointed by a provided iterator, i.e.
  element with a greater key.]

  Description [ Precondition: this function can be applied only if
  Ssiter_is_valid(iter) returns true.  ]

  SideEffects []

  SeeAlso     [Sset_first, Ssiter_is_end, Ssiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Ssiter Ssiter\_prev(Ssiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns an iterator pointing to the previous element 
  of a set w.r.t. the element pointed by a provided iterator, i.e.
  element with a smaller key.]

  Description [ Precondition: this function can be applied only if
  Ssiter_is_valid(iter) returns true.]

  SideEffects []

  SeeAlso     [Sset_first, Ssiter_is_valid, Ssiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Ssiter\_is\_valid(Ssiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns true iff an iterator points a valid node
  of a set, i.e. not past the last element or before the first element
  of a set.]

  Description [The iterator must have been created with function
  Sset_first, Sset_last, Sset_next or Sset_prev.
  NOTE: the function is constant time.
  WARNING: if the function returns false no other function
  should be invoked on the given iterator!]

  SideEffects []

  SeeAlso     [Sset_first, Ssiter_next, Ssiter_element]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Ssiter\_element(Ssiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a value stored in an element pointed by 
  a provided iterator]

  Description [Precondition: this function can be applied only
  if Ssiter_is_valid(iter) returns true]

  SideEffects []

  SeeAlso     [Sset_first, Sset_next, Ssiter_is_valid, Ssiter_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{signed long long int Ssiter\_key(Ssiter iter)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Returns a key stored in an element pointed by 
  a provided iterator (and which was used to order the elements)]

  Description [Precondition: this function can be applied only
  if Ssiter_is_valid(iter) returns true]

  SideEffects []

  SeeAlso     [Sset_first, Sset_next, Ssiter_is_valid, Ssiter_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ssiter\_set\_element(Ssiter iter, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Sets up a value stored in an element pointed by 
  a provided iterator]

  Description [Precondition: this function can be applied only
  if Ssiter_is_valid(iter) returns true]

  SideEffects []

  SeeAlso     [Sset_first, Sset_next, Ssiter_is_valid, Ssiter_next]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Ssiter\_test()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [The function tests the class implementation]

  Description [The function is no in the interface but can be invoked 
  by Developers in order to test the implementation of the class.

  This function should be used only by developers to test the changed in the class.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void s\_set\_init(Sset\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Initializes the memory for a set instance]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void s\_set\_deinit(Sset\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Deinitializes the memory from a set]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Ssnode\_ptr s\_set\_copy(Ssnode\_ptr node, void* (*func)(void*))}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates a copy of a given tree]

  Description [Precondition: the tree should no be empty.
  Warning: the parent of returned node equals the parent of the input node.

  Optional func parameter is a function takinf voi* and returning void*, for 
  copying the elements]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Ssnode\_ptr s\_set\_new\_node(signed long long int key, Ssnode\_ptr parent)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Function allocates a new Ssnode and sets its 
  fields to the provided values.]

  Description ["left", "right", "element" and "balance" is set to 0.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static size\_t s\_set\_free\_nodes(Ssnode\_ptr node)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Function de-allocates a Ssnode and all its children]

  Description [The elements themselves are not freed.  The returned
  value is the number of freed elements (returned only if DEBUG is
  enabled).]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Ssnode\_ptr s\_set\_find(Sset\_ptr self, signed long long int key)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Looks for an element with a given key]

  Description [The found element is returned. If no such element
  exists NULL is returned]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Ssnode\_ptr s\_set\_find\_closest\_le(Sset\_ptr self, signed long long int key)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Looks for an element closest (less or equal than) a given key]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Ssnode\_ptr s\_set\_find\_closest\_ge(Sset\_ptr self, signed long long int key)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [Looks for an element closest (greater or equal than) a given key]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Ssnode\_ptr s\_set\_find\_insert(Sset\_ptr self, signed long long int key, boolean* is\_found)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Looks for an element with a given key. If such element
  does not exists it is created.]

  Description [
  is_found is set to true if the element exists in the tree and false otherwise.
  Precondition: is_found should not be NULL;
  Note: all the existing iterators remain valid.
  Returns a node with the given key.

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void s\_set\_delete\_node(Sset\_ptr self, Ssnode\_ptr to\_be\_deleted)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Removes a given node from the set.]

  Description [
  Precondition: the node has to belong to the provided set.
  The operation takes O(log2 N) time (N is the size of the set).]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{Stack.c}
		
	\texttt{Stack\_ptr Stack\_create()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates an instance of a Stack ]

  Description []

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Stack\_ptr Stack\_create\_with\_param(int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Creates an instance of a Stack ]

  Description [Allow the user to define the initial size]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Stack\_destroy(Stack\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [Destroys a stack instance]

  Description [The memory used by the Stack will be freed.
  Note: memory occupied by the elements is not freed! It is the user
  responsibility.]

  SideEffects []

  SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{Stack\_ptr Stack\_copy(Stack\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Creates a copy of a given stack]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Stack\_push(Stack\_ptr self, void* element)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Pushes an element at the top of the stack]

  Description        []

  SideEffects        []

  SeeAlso            [Stack_pop]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{size\_t Stack\_get\_size(Stack\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the size of the stack]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Stack\_pop(Stack\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Removes the element at the top of the stack]

  Description        [The removed element is returned.]

  SideEffects        []

  SeeAlso            [Stack_push]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Stack\_top(Stack\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the element at the top of the stack]

  Description        []

  SideEffects        []

  SeeAlso            [Stack_pop]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Stack\_is\_empty(Stack\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns true iff the stack is empty]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void stack\_init(Stack\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the memory for a Stack instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void stack\_init\_with\_param(Stack\_ptr self, int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the memory for a Stack instance]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void stack\_deinit(Stack\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deinitializes the memory from a Stack]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{TimerBench.c}
		
	\subsection{Triple.c}
		
	\texttt{Triple\_ptr Triple\_create(void* first, void* second, void* third)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Triple class constructor]

  Description        [The Triple class constructor]

  SideEffects        []

  SeeAlso            [Triple_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Triple\_init(Triple\_ptr self, void* first, void* second, void* third)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Triple class initializer]

  Description        [The Triple class initializer.  Use this function if
                      declaring a Triple in the stack ]

  SideEffects        []

  SeeAlso            [Triple_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Triple\_destroy(Triple\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Triple class destructor]

  Description        [The Triple class destructor]

  SideEffects        []

  SeeAlso            [Triple_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Triple\_freeze(Triple\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Mark the Triple instance as read-only]

  Description        [Mark the Triple instance as read-only.
                      This is usefull when debugging, and using a Triple
                      instance as key of an hash table, for example]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Triple\_is\_freezed(const Triple\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Check if the Triple is freezed]

  Description        [Check if the Triple is freezed (i.e. it is
                      read-only)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Triple\_get\_first(const Triple\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the first value of the Triple instance]

  Description        [Get the first value of the Triple instance]]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Triple\_get\_second(const Triple\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the second value of the Triple instance]

  Description        [Get the second value of the Triple instance]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* Triple\_get\_third(const Triple\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Get the third value of the Triple instance]

  Description        [Get the third value of the Triple instance]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Triple\_set\_first(Triple\_ptr self, void* first)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the first value for the Triple instance.]

  Description        [Sets the first value for the Triple instance.
                      The Triple must not be frozen]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Triple\_set\_second(Triple\_ptr self, void* second)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the second value for the Triple instance]

  Description        [Sets the second value for the Triple instance.
                      The Triple must not be frozen]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Triple\_set\_third(Triple\_ptr self, void* third)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets the third value for the Triple instance]

  Description        [Sets the third value for the Triple instance.
                      The Triple must not be frozen]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Triple\_set\_values(Triple\_ptr self, void* first, void* second, void* third)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Sets both the values for the Triple instance]

  Description        [Sets both the values for the Triple instance.
                      The Triple must not be frozen]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Triple\_compare(const Triple\_ptr a, const Triple\_ptr b)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Triple comparison function]

  Description        [Triple comparison function.
                      Returns if the two Triple instances are the
                      equal.  No distinction between frozen / unfrozen
                      instances is made.
                      Can be casted to ST_PFICPCP

                      Casts to char* are added to prevent "warning: pointer of
                      type ‚Äòvoid *‚Äô used in subtraction".]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Triple\_hash(const Triple\_ptr self, int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Triple hash function]

  Description        [Triple hash function.
                      No distinction between frozen / unfrozen
                      instances is made.
                      Can be casted to ST_PFICPI]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void triple\_init(Triple\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Triple class private initializer]

  Description        [The Triple class private initializer]

  SideEffects        []

  SeeAlso            [Triple_create]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void triple\_deinit(Triple\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The Triple class private deinitializer]

  Description        [The Triple class private deinitializer]

  SideEffects        []

  SeeAlso            [Triple_destroy]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{WordNumber.c}
		
	\texttt{typedef struct WordNumber\_TAG}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [WordNumber struct.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void WordNumber\_init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [initialiser of the class]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void WordNumber\_quit(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [deinitialiser of the class]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int WordNumber\_max\_width()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The functions returns the maximal width a Word constant
  can have. This is implemenatation-dependent limit]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_from\_string(char* str, int base)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Constructs a Word number WordNumber_ptr from the string
  representation]

  Description        [The string and base should be proper for standard
  "strtoull" function.  The base can be 2, 8 or 16.  In the case of
  any problem NULL is returned.

  Note: base 10 is not allowed, because it does not provide enough info
  about the width of the Word number.

  NOTE: Memory sharing is used, i.e. given a string with the same
  value of WordNumber this constructor will return the same pointer
  (this is important for node_ptr hashing)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_from\_sized\_string(char* str, int base, int width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Constructs a Word number WordNumber_ptr from the string
  representation]

  Description        [The string and base should be proper for standard
  "strtoull" function. The base can be 2, 8, 10 or 16. The number
  should be in the range supposed by the width. The provided width of
  the constant should be enough to hold the obtained number. In the
  case of any problem NULL is returned.

  NOTE: Memory sharing is used, i.e. given a string with the same
  value of WordNumber this constructor will return the same pointer
  (this is important for node_ptr hashing)]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_from\_parsed\_string(char* str, char** errorString)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Constructs a Word number WordNumber_ptr from the string
  representation obtained during parsing]

  Description        [The string is the string obtained during parsing. The
  string should correspond to the NuSMV lexer token "word constants",
  i.e. "0" character followed by the base, optional signed specifier,
  optional width (decimal number), "_" character and the value
  (binary, octal, decimal or hexadecimal number).  The base and the
  digits should correspond each other.

  The limit for width is implementation dependant.
  In the case of any problem NULL is returned, and if errorString is not NULL,
  it is set to a text string explaining the cause of the error.
  The returned error-string belongs to this function (it may change during next
  function invocation).

  NOTE: this constructor is NOT memory shared, i.e. given the same
  string twice different pointers may be returned. (Actually the
  returned pointers may be the same but different from
  pointers returned by memory shared constructors.)  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_from\_integer(WordNumberValue value, int width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a WordNumber]

  Description        [value and width should be correct, i.e. in a proper
  range. See WordNumber_from_signed_integer if original value is signed.

  NOTE: Memory sharing is used, i.e. given the same parameter this
  constructor will return the same pointer (this is important for
  node_ptr hashing)]

  SideEffects        []

  SeeAlso            [WordNumber_from_signed_integer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_from\_signed\_integer(WordNumberValue value, int width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a WordNumber]

  Description [ This constructor is the same as
  WordNumber_from_integer except than value is interpreted as signed
  value casted to WordNumberValue.

  The difference is that signed negative value casted to WordNumberValue
  will have 1s at positions greater than width. These bits are ignored
  but in WordNumber_from_integer they cause assertion violation.

  For originally positive values both constructors behave the same.
  ]

  SideEffects        []

  SeeAlso            [WordNumber_from_integer]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_normalize(const WordNumber\_ptr number)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a memory shared WordNumber]

  Description [If a word number was created with a constructor
  WordNumber_from_parsed_string then such a WordNumber is NOT memory
  shared.
  This function takes such WordNumber and returns its memory shared
  analog, i.e. with the same width and value but without string
  information.
  If WordNumber was created with memory-shared constructor (for
  example, WordNumber_from_integer), there is no need to use this
  function since the returned value will be the same as input]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumberValue WordNumber\_get\_unsigned\_value(WordNumber\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns the value of a WordNumber, as unsigned word]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumberValue WordNumber\_get\_signed\_value(WordNumber\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis [returns the value of a WordNumber, interpreted as a signed
  word]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_get\_sign(WordNumber\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns the status (true or false) of the sign bit]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int WordNumber\_get\_width(WordNumber\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns the width of a WordNumber]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_get\_bit(WordNumber\_ptr self, int n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns the status (true or false) of a particular bit]

  Description        [the bit number should be in the range \[0, width-1\].]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* WordNumber\_get\_parsed\_string(WordNumber\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a string which was given
  to WordNumber_from_parsed_string constructor. If the number was created
  by any other constructor, NULL is returned.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumberValue WordNumber\_max\_unsigned\_value(int width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a maximal value of unsigned word of given width]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumberValue WordNumber\_max\_signed\_value(int width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a maximal value of signed word of given width.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumberValue WordNumber\_min\_signed\_value(int width)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a minimal value of signed word of given width.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int WordNumber\_print(FILE* output\_stream, WordNumber\_ptr self, boolean isSigned)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [prints a Word constant to a stream in a generic format.]

  Description        [Generic format means that the number is printed
  in the base specified by the system variable "output_word_format"
  with one exception -- if the number was created with
  WordNumber_from_parsed_string, then that string provided during
  construction will be printed.
  If base is 10 then isSigned is taken into account, i.e. if it is true then
  the number is ouput as signed word, and as unsigned word otherwise.]

  SideEffects        []

  SeeAlso            [WordNumber_based_print]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int WordNumber\_based\_print(FILE* output\_stream, WordNumber\_ptr self, int base, boolean isSigned)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [prints a Word constant in a provided base.]

  Description        [returns negative value in a case of error.
  Only 2, 8, 10, 16 bits bases are allowed.
  If base is 10 then isSigned is taken into account, i.e. if it is true then
  the number is ouput as signed word, and as unsigned word otherwise.]

  SideEffects        []

  SeeAlso            [WordNumber_print]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* WordNumber\_to\_string (WordNumber\_ptr self, boolean isSigned)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [prints a Word constant to a char string.]

  Description        [It is the same as WordNumber_print
  but outputs to a string instead of a stream, i.e.:
    the number is printed in the base specified by the system variable
    "output_word_format".
  In case of any problem, NULL is returned.

  If base is 10 then isSigned is taken into account, i.e. if it is true then
  the number is ouput as signed word, and as unsigned word otherwise.

  Note: The returned string belongs to the funcion. Do not modify this
  string.
  Note: The next invocation of this function or WordNumber_to_based_string
  makes the previously returned string unusable]

  SideEffects        []

  SeeAlso            [WordNumber_print, WordNumber_to_based_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* WordNumber\_to\_based\_string(WordNumber\_ptr self, int base, boolean isSigned)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [prints a Word constant in a provided base to a string.]

  Description        [This function is the same as WordNumber_based_print,
  except this function outputs to a string, not a stream.
  Only 2, 8, 10, 16 bits bases are allowed.
  If base is 10 then isSigned is taken into account, i.e. if it is true then
  the number is ouput as signed word, and as unsigned word otherwise.
  In case of any problem, NULL is returned.

  Note: The returned string belongs to the funcion. Do not modify this
  string.
  Note: The next invocation of this function or WordNumber_to_string
  makes the previously returned string unusable]

  SideEffects        []

  SeeAlso            [WordNumber_based_print, WordNumber_to_string]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_unary\_minus(WordNumber\_ptr v)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform the negation operation]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_plus(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform summation operation]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_minus(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform subtraction operation on Words]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_times(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform multiplidation operation on Words]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_unsigned\_divide(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform unsigned division operation on Words]

  Description        [the width of operands should be equal. The
  right operand should not be 0.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_signed\_divide(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform signed division operation on Words]

  Description        [the width of operands should be equal. The
  right operand should not be 0]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_unsigned\_mod(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform remainder unsigned operation on Words]

  Description        [the width of operands should be equal. The right
  operand should not be 0.
  Note: numbers are considered as unsigned.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_signed\_mod(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform remainder signed operation on Words]

  Description        [the width of operands should be equal. The right
  operand should not be 0]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_is\_zero(WordNumber\_ptr v)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks wether the word is the constant word of
  all bit set to zero]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_equal(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if operands are equal]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_not\_equal(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if operands are NOT equal]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_unsigned\_less(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if left operand is less than
  the right one (numbers are considered as unsigned)]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_unsigned\_less\_or\_equal(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if left operand is less than, or equal to,
  the right one (numbers are considered as unsigned)]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_unsigned\_greater(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if left operand is greater than
  the right one (numbers are considered as unsigned)]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_unsigned\_greater\_or\_equal(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if left operand is greate than, or eqaul to,
  the right one (numbers are considered as unsigned)]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_signed\_less(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if left operand is signed less than
  the right one (numbers are considered as signed)]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_signed\_less\_or\_equal(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if left operand is signed less than,
  or equal to, the right one (numbers are considered as signed)]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_signed\_greater(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if left operand is signed greater than
  the right one (numbers are considered as signed)]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean WordNumber\_signed\_greater\_or\_equal(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns TRUE if left operand is signed greate than,
  or eqaul to, the right one (numbers are considered as signed)]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_not(WordNumber\_ptr v)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns bitwise NOT of a Word number]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_and(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns bitwise AND of two Word numbers]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_or(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns bitwise OR of two Word numbers]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_xor(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns bitwise XOR of two Word numbers]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_xnor(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns bitwise XNOR(or IFF) of two Word numbers]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_implies(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns bitwise IMPLIES of two Word numbers]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_iff(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns bitwise IFF(or XNOR) of two Word numbers]

  Description        [the width of operands should be equal]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_concatenate(WordNumber\_ptr v1, WordNumber\_ptr v2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a concatenation of two Word numbers]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_bit\_select(WordNumber\_ptr v, int highBit, int lowBit)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [returns a Word number consisting of the
  bits [highBit .. lowBit] from a given Word number]

  Description        [highBit should be less than the Word width and greater or
  equal to lowBit. lowBit should be greater or equal to 0.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_unsigned\_right\_shift(WordNumber\_ptr v, int numberOfBits)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform right shift on a Word numbers]

  Description        [the number of shifted bits should be in the range
  \[0, width\]. The word is padded with zeros.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_signed\_right\_shift(WordNumber\_ptr v, int numberOfBits)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform right shift on a Word numbers]

  Description        [the number of shifted bits should be in the range
  \[0, width\]. The word is padded with zeros.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_left\_shift(WordNumber\_ptr v, int numberOfBits)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform left shift on a Word numbers]

  Description        [the number of shifted bits should be in the range
  \[0, width\]. The word is padded with zeros.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_right\_rotate(WordNumber\_ptr v, int numberOfBits)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform right rotate on a Word numbers]

  Description        [the number of rotated bits should be in the range
  \[0, width\].]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_left\_rotate(WordNumber\_ptr v, int numberOfBits)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [perform left rotate on a Word numbers]

  Description        [the number of rotated bits should be in the range
  \[0, width\].]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_signed\_extend(WordNumber\_ptr v, int numberOfTimes)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [performs sign extend, i.e. concatenates 'numberOfTimes'
  number of times the highest bit of v with v.]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{WordNumber\_ptr WordNumber\_unsigned\_extend(WordNumber\_ptr v, int numberOfTimes)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [performs unsign extend]

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static WordNumber\_ptr word\_number\_create(WordNumberValue value, int width, char* parsedString)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [The constructor of WordNumber_ptr. Also adds the created
  number to the memory manager]

  Description        [In case of any errors, returns NULL.
  This function can be invoked only by constructor-converter functions.
  The function creates a copy of the parameter parsedString.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void word\_number\_destroy(WordNumber\_ptr word)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destructor of a WordNumber_ptr]

  Description        [Destructor can be invoked only by the class
  deinitializer, when all the WordNumber_ptr numbers are destroyed.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static WordNumberValue word\_number\_to\_signed\_c\_value(const WordNumber\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{array.c}
		
	\texttt{void array\_sort(array, compare) array\_t *array; int (*compare)();}
	\begin{verbatimtab}
		
/**Function********************************************************************

Synopsis           [Sorts the array content according to the given 
comparison function]

Description [IMPORTANT!  compare has argument int (void* pa, void* pb)
pa and pb must be dereferenced to access the corresponding values into
the array ]

SideEffects        []

SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{assoc.c}
		
	\texttt{void assoc\_foreach(hash\_ptr hash, ST\_PFSR fn, char *arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis    [Iterates over the elements of the hash.]

   Description [For each (key, value) record in `hash', assoc_foreach
   call func with the arguments
   <pre>
   (*func)(key, value, arg)
   </pre>
   If func returns ASSOC_CONTINUE, st_foreach continues processing
   entries.  If func returns ASSOC_STOP, st_foreach stops processing and
   returns immediately. If func returns ASSOC_DELETE, then the entry is
   deleted from the symbol table and st_foreach continues.  In the case
   of ASSOC_DELETE, it is func's responsibility to free the key and value,
   if necessary.<p>]

   SideEffects [None]

   SeeAlso     []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static int assoc\_string\_key\_hash\_fun(node\_ptr key, int size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [One-at-a-Time Hash function]

   Description        [Used to hash string keys.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{avl.c}
		
	\subsection{error.c}
		
	\texttt{JMPBUF * util\_newlongjmp(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Save stack context for non-local goto]

   Description        [Saves the stack environment in the global
   array <code>jmp_buf_arr</code> for later use by <code>util_longjmp</code>.]

   SideEffects        []

   SeeAlso            [util_longjmp util_cancellongjmp]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void util\_longjmp(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Restore the environment saved in <code>jmp_buf</code>.]

   Description        [Restores the environment saved by the last call of
   <code>SETJMP(*(util_newlongjmp()), 1)</code>. After
   <code>util_longjmp()</code> is completed, program execution
   continues as if the corresponding call of <code>SETJMP()</code>
   had just returned a value different from <code>0</code> (zero).]

   SideEffects        []

   SeeAlso            [util_newlongjmp util_cancellongjmp]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void util\_cancellongjmp(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Pop one of the environments saved in <code>jmp_buf</code>.]

   Description        [Removes the last envirnoment saved in
   <code>jmp_buf</code> by a <code>SETJMP(*(util_newlongjmp()), 1)</code> call.]

   SideEffects        []

   SeeAlso            [util_newlongjmp util_longjmp]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void util\_resetlongjmp(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Reset environment saved in <code>jmp_buf</code>.]

   Description        [Resets the environment saved by the calls to
   <code>SETJMP(*(util_newlongjmp()), 1)<code>. After
   this call, all the longjump points previously stored are
   cancelled.]

   SideEffects        []

   SeeAlso            [util_newlongjmp]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void start\_parsing\_err()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [General routine to start error reporting.]

   Description        [This is a general routine to be called by error
   reporting routines as first call. The file name and corresponding
   line number of the token that has generated the error (which is
   retrieved by <code>get_the_node()</code> are printed out.]

   SideEffects        []

   SeeAlso            [finish_parsing_err]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void nusmv\_exit(int n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [General exit routine.]

   Description        [If non local goto are anebaled, instead of
   exiting from the program, then the non local goto is executed.]

   SideEffects        []

   SeeAlso            [util_setjmp util_longjmp]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void rpterr(const char* fmt, ...)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [General error reporting routine.]

   Description        [Produces a message on the
   <code>nusmv_stderr</code>. The arguments are similar to those of the
   <code>printf</code>, but only if fmt is not NULL or the empty string]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void rpterr\_node(node\_ptr node, const char* fmt, ...)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [General error reporting routine.]

   Description        [Produces a message on the
   <code>nusmv_stderr</code>. The arguments are similar to those of the
   <code>printf</code>, except argument "node" which is output at the
   end of the message with function print_node. ]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void internal\_error(const char * fmt, ...)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Prints out an internal error.]

   Description        [Produces a message on the <code>nusmv_stderr</code>.
   The message is considered an internal error. The arguments are
   similar to those of the <code>printf</code>.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void init\_memory()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Initializes the memory routines.]

   Description        [This function deals with the memory routines
   taken form the CUDD. It initializes the pointer to function
   <tt>MMoutOfMemory</tt> which is used by the memory allocation
   functions when the <tt>USE_MM</tt> macro is not defined (the
   default). This pointer specifies the function to call when the
   allocation routines fails to allocate memory.]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void finish\_parsing\_err()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [General routine to terminate error reporting.]

   Description        [This is the general routine to be called as last
   routine in specific error reporting routines.
   If error happens during flattening, the system is also reset.
   Finally, a call to <code>nusmv_exit()</code> is performed.]

   SideEffects        []

   SeeAlso            [start_parsing_err]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void error\_reset\_and\_exit(int val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void error\_invalid\_number(const char* szNumber)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void error\_bmc\_invalid\_k\_l(const int k, const int l)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void error\_property\_already\_specified()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void error\_invalid\_numeric\_value(int value, const char* reason)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void error\_file\_not\_found(const char* filename)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void warning\_processes\_deprecated()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr failure\_make(const char* msg, FailureKind kind, int lineno)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Builder for FAILURE nodes]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* failure\_get\_msg(node\_ptr failure)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the message string associated to the
   failure node]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{FailureKind failure\_get\_kind(node\_ptr failure)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Returns the failure kind associated to the
   failure node]

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int failure\_get\_lineno(node\_ptr failure)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           []

   Description        []

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{heap.c}
		
	\subsection{list.c}
		
	\subsection{object.c}
		
	\texttt{VIRTUAL void Object\_destroy(Object\_ptr self, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class virtual destructor]

  Description        [Class virtual destructor. Call this to destroy any 
  instance of any derived class.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{VIRTUAL Object\_ptr Object\_copy(const Object\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class virtual copy constructor]

  Description        [Call this by passing any class instance derived from
                      Object. Cast the result to the real class type
                      to assign the returned value. 
		      Since Object is a virtual class, it cannot be 
		      really instantiated. This means that the copy constructor
		      must be implemented by derived class if the copy is 
		      a needed operation. ]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void object\_init(Object\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class private inizializer]

  Description        [This private method must be called by 
  derived class inizializer *before* any other operation]

  SideEffects        []

  SeeAlso            [object_deinit]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void object\_deinit(Object\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Class private deinizializer]

  Description        [Must be called by 
  derived class inizializer *after* any other operation. The deinizializer
  in derived class must be called only by the finalizer (which is called 
  the destructor). No other operation is allowed on the instance is being 
  to be destroyed.]

  SideEffects        []

  SeeAlso            [object_init]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void object\_copy\_aux(const Object\_ptr self, Object\_ptr copy)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Copy costructor auxiliary private method]

  Description        [This must be called by any derived class auxiliary copy
  constructor *before* any other operation.]

  SideEffects        []

  SeeAlso            [object_copy]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static Object\_ptr object\_copy(const Object\_ptr self)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private copy constructor]

  Description        [In order to provide copy feature, any derived class must 
  implement two copy private functions: copy and copy_aux functions, to split 
  copy creation and actual copy operations. copy creates an instance and 
  passes it to copy_aux. In any derived class, the base class' copy_aux 
  method must be called by the copy_aux method before any other operation. 
  If the derived class does not override the object's copy constructor, 
  and the user tries to copy the derived class instance by calling the 
  Object_copy method, then an assertion is fired since Object is a class 
  that cannot be instantiated. ]

  SideEffects        []

  SeeAlso            [object_copy_aux]   
  
******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void object\_finalize(Object\_ptr self, void* arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private pure destructor]

  Description        [Since the Object class cannot be really instantiated, 
  the virtual destructor must be overrided by derived classes. If the derived 
  class does not override the finalizer, then an assertion is fired when 
  the virtual destroyer Object_destroy is called.]

  SideEffects        []

  SeeAlso            []   
  
******************************************************************************/

	\end{verbatimtab}
	
	\subsection{portability.c}
		
	\texttt{void* rpl\_malloc(size\_t size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This function is used instead of malloc when 
  a GNU compatible malloc function is not available.]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void* rpl\_realloc(void* ptr, size\_t size)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [This function is used instead of malloc when 
  a GNU compatible malloc function is not available.]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{range.c}
		
	\texttt{void Utils\_set\_data\_for\_range\_check(node\_ptr var, node\_ptr range)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Called before using Utils_range_check callback function]

  Description        []

  SideEffects        [Utils_range_check]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_set\_mode\_for\_range\_check(boolean is\_fatal)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Called before using Utils_range_check callback function]

  Description        []

  SideEffects        [Utils_range_check]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_range\_check(node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the values of <code>n</code> is in the
  range allowed for the variable.]

  Description        [Checks if the values of <code>n</code> is in the
  range allowed for the variable. The allowed values are stored in the
  global variable <code>the_range</code>, which should be set before
  invocation of this function. 
  An error occure if: 
   1. the value is not in the range (all FAILURE node are, of course, irgnored)
  ]
   
  SideEffects        [Utils_set_data_for_range_check]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_failure\_node\_check(node\_ptr n)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the values of <code>n</code> does not 
  contains FAILURE node. If they do then report and terminate.]

  Description        []

  SideEffects        [Utils_set_data_for_range_check]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Utils\_is\_in\_range(node\_ptr s, node\_ptr d)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if the first argument is contained in the second.]

  Description        [Returns true if the first argument is contained in the
  set represented by the second, false otherwise. If the first
  argument is not a CONS, then it is considered to be a singleton.]

  SideEffects        [None]

  SeeAlso            [in_list]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Utils\_check\_subrange(node\_ptr subrange)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks that in given subrange n..m, n<=m]

  Description        [Returns True if in given subrange n..m n <= m. 
  Given node_ptr must be of TWODOTS type]

  SideEffects        []

  SeeAlso            [Utils_check_subrange_not_negative]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Utils\_check\_subrange\_not\_negative(node\_ptr subrange)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks that in given subrange n..m, n<=m, and that n,m 
  are not negative]

  Description        [Check for correct positive (or zero) range]

  SideEffects        []

  SeeAlso            [Utils_check_subrange]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ucmd.c}
		
	\texttt{void apply\_string\_macro\_expansion(const SubstString* const subst, char* string, size\_t buf\_len)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Searches for a symbol in the given string, and
  and substitutes all its occurences with the specified element, using the
  given format.]

  Description        [The first parameter <I>subst</I> contains information
  about the symbol to be checked and about the element which substitutes every
  occurence of the symbol, and the format (as in printf) used to convert the
  element in a string. The element has a type (integer, string, float, etc.)
  and a statically assigned value. <BR>
  The second parameter <I>string</I> contains the string to be searched for,
  and the string finally returned too. So it is *very important* you supply
  a buffer large enought to contain the larger string between source and
  destination strings. Use the third parameter to fix the maximum buffer
  length. <BR><BR>
  The element can be built with a 2-passes procedure.
  The first pass consists in constructing the static instance of the element.
  Use the SYMBOL_CREATE macro to build it, and assign the result to a
  <I>SubstString</I> type variable.
  Then assign the substitution value to the created instance using the macro
  SYMBOL_ASSIGN. <BR>
  <I>Example of usage:</I><BR>
  <PRE>
  {
    char szBuffer[256];
    SubstString sb = SYMBOL_CREATE("$D");

    SYMBOL_ASSIGN(sb, integer, "%d", 10);

    strncpy(szBuffer, "Every symbol $D will be substituted with $D",
            sizeof(szBuffer));

    apply_string_macro_expansion(&sb, szBuffer, sizeof(szBuffer));
  }
  </PRE>
  ]

  SideEffects        [The given string will change]

  SeeAlso            [SYMBOL_CREATE, SYMBOL_ASSIGN, SubstString]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int util\_str2int(const char* str, int* value)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Converts a given string representing a number (base 10)
  to an integer with the same value]

  Description        [Returns zero (0) if conversion is carried out
  successfully, otherwise returns 1]

  SideEffects        ['value' parameter might change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int util\_str2int\_incr(const char* str, char **endptr, int* out)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [An abstraction over BSD strtol for integers]

  Description [Parses an integer value from a string, performing
               error-checking on the parsed value. This function can
               be used to parse incrementally a complex string made of
               numbers and separators.

               Returns 0 iff no error was detected.

               Remarks:

               * Empty strings are allowed as a corner case. They are
                 interpreted as 0.]

  SideEffects [*endptr points to the next character in string, *out
               contains the integer value corresponding to the parsed
               string.]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int util\_is\_string\_null(const char* string)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks if given string is NULL, "", or the converted
  string of NULL]

  Description        [Returns 1 if the string is equal to "", NULL or
  equal to the converted string of NULL (as sprintf does).
  Otherwise returns 0.
  ]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{ustring.c}
		
	\subsection{utils.c}
		
	\texttt{void Utils\_pkg\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the utils package]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_pkg\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [De-initializes the utils package]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{const char* Utils\_StripPath(const char* pathfname)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns pathname without path prefix]

  Description        []

  SideEffects        [None]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_StripPathNoExtension(const char* fpathname, char* filename)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns filename without path and extension]

  Description        [Example: given "~/.../test.smv", "test" will be returned.
  filename must be a string whose length is large enought to contain the "pure"
  filename]

  SideEffects        [the string pointed by 'filename' changes]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_StripPathNoFilenameNoExtension(const char* fpathname, char* dirname)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns directory part of fpathname without filename and
                      extension]

  Description        [dirname must be a string whose length is large enough to
                      contain the directory part]

  SideEffects        [The string pointed to by 'dirname' changes]

  SeeAlso            [Utils_StripPathNoExtension, Utils_StripPath]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_FreeListOfLists(lsList list\_of\_lists)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Destroys a list of list]

  Description        [This function can be used to destroy lists of list. The
  contained set of lists is removed from memory as the top level list.
  More than two levels are not handled at the moment.]

  SideEffects        [Lists are deallocated]

  SeeAlso            [lsDestroy]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{char* Utils\_get\_temp\_filename\_in\_dir(const char* dir, const char* templ)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Return a string to be used as temporary file]

  Description [This functions gets a template parameter for the file
  name, with 6 'X' that will be substituted by an unique id. See
  mkstemp for further info. Ensures that the filename is not already
  in use in the given directory. If NULL is passed as the directory,
  then the standard temporary directory is used instead. Returned
  string must be freed. Returtns NULL if the filename cannot be found
  or if we do not have write priviledges in the specified directory.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Utils\_file\_exists\_in\_paths(const char* filename, const char* paths, const char* delimiters)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks a list of directories for a given file.]

  Description        [The list of directories (delimited by the charaters given)
  are checked for the existence of the file.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{boolean Utils\_file\_exists\_in\_directory(const char* filename, char* directory)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Checks for the existence of a file within a directory.]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Utils\_strcasecmp(const char* s1, const char* s2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [An abstraction over BSD strcasecmp]

  Description        [Compares the two strings s1 and s2,
  ignoring the case of the characters.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_start\_timer(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Starts a timer whose name is given]

  Description [If the timer does not exist, it will be created and
  started. If already started an error occurs.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_stop\_timer(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Stops a timer whose name is given]

  Description [The timer must be already existing and running.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_reset\_timer(const char* name)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Resets a timer whose name is given]

  Description [The timer must be already existing.]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_print\_timer(const char* name, const char* msg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [prints info about a timer whose name is given]

  Description [The timer must be already existing. msg can be NULL]

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void Utils\_str\_escape\_xml\_file(const char* str, FILE* file)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Escapes all characters in given string, and dumps them 
  into the xml file]

  Description        []

  SideEffects        []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Utils\_log2\_round(unsigned long long int a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Computes the log2 of the given unsigned argument
                      rounding the result to the closest upper
                      integer. 0 gives 1 as result.]

  Description [This function can be used to calculate the number of
  bits needed to represent a value.]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void freeListOfLists\_aux(lsList list)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Private service for Utils_FreeListOfLists]

  SideEffects        []

  SeeAlso            [Utils_FreeListOfLists]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hash\_timers\_init(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the hash_timers hash]

  Description        [Initializes the hash_timers hash]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static enum st\_retval hash\_timers\_quit\_fun\_aux(char*k, char* e, char* a)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           []

  Description        []

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hash\_timers\_quit\_fun(hash\_timers\_DESTROY fun)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deinitializes the hash_timers hash]

  Description        [Deinitializes the hash_timers hash]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static TimerBench\_ptr hash\_timers\_lookup(const char* key)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Looks up in the hash_timers hash]

  Description        [Looks up in the hash_timers hash]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void hash\_timers\_insert(const char* key, TimerBench\_ptr val)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Inserts into the hash_timers hash]

  Description        [Inserts into the hash_timers hash]

  SideEffects        []

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{utils\_io.c}
		
	\section{wff}
		
	\section{w2w}
		
	\subsection{wff2nnf.c}
		
	\texttt{node\_ptr Wff2Nnf(node\_ptr wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Makes the <b>negative normal form</b> of given WFF]

   Description        [A positive (1) polarity will not negate entire formula]

   SideEffects        [node hash may change]

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void w2w\_clear\_wff2nnf\_memoization()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Clears the memoization hash of the wff2nff
   conversion function]

   Description        [Clears the memoization hash of the wff2nff
   conversion function]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void w2w\_init\_wff2nnf()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Initializes the wff2nff conversion system]

   Description        [Initializes the wff2nff conversion system]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void w2w\_quit\_wff2nnf()}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Deinitializes the wff2nff conversion system]

   Description        [Deinitializes the wff2nff conversion system]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static void w2w\_wff2nnf\_hash\_insert\_entry(node\_ptr wff, boolean polarity, node\_ptr nnf)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Memoizes the given entry in the wff2nff memoization hash]

   Description        [Memoizes the given entry in the wff2nff memoization hash]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr w2w\_wff2nnf\_hash\_lookup\_entry(node\_ptr wff, boolean polarity)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Looks up in the wff2nff memoization hash for
   the given entry]

   Description        [Looks up in the wff2nff memoization hash for
   the given entry]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr w2w\_wff\_expand\_case(node\_ptr wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Expands the given case expression]

   Description        [Expands the given case expression]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr w2w\_wff\_expand\_case\_aux(node\_ptr wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [Aux fun of w2w_wff_expand_case]

   Description        [Aux fun of w2w_wff_expand_case]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr w2w\_wff\_mk\_nnf(node\_ptr wff, boolean pol)}
	\begin{verbatimtab}
		
/**Function********************************************************************

   Synopsis           [The private function that does the actual
                       wff2nnf conversion]

   Description        [The private function that does the actual
                       wff2nnf conversion]

   SideEffects        []

   SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{exprWff.c}
		
	\texttt{node\_ptr Wff\_make\_truth(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <i>truth</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_falsity(void)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <i>false</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_not(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <i>not</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_and(node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>and</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_or(node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>or</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_implies(node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>implies</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_iff(node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>iff</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_next(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <i>next</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_opnext\_times(node\_ptr arg, int x)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Applies <i>op_next</i> x times]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_opnext(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>op_next</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_opprec(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>op_next</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_opnotprecnot(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>op_next</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_globally(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <i>globally</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_historically(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <i>historically</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_eventually(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>eventually</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_once(node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>once</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_until(node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>until</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_since(node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes an <i>since</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_releases(node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <i>releases</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{node\_ptr Wff\_make\_triggered(node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <i>triggered</i> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{int Wff\_get\_depth(node\_ptr ltl\_wff)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Returns the modal depth of the given formula]

  Description        [Returns 0 for propositional formulae, 1 or more for
  temporal formulae]

  SideEffects        [none]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr\_wff\_make\_binary(int type, node\_ptr arg1, node\_ptr arg2)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <b>binary</b> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr\_wff\_make\_unary(int type, node\_ptr arg)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <b>unary</b> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{static node\_ptr expr\_wff\_make\_const(int type)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Makes a <b>constant</b> WFF]

  Description        []

  SideEffects        [node hash may change]

  SeeAlso            []

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{wffPkg.c}
		
	\texttt{void wff\_pkg\_init()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Initializes the wff package]

  Description        []

  SideEffects        []

  SeeAlso            [wff_pkg_quit]

******************************************************************************/

	\end{verbatimtab}
	
	\texttt{void wff\_pkg\_quit()}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis           [Deinitializes the wff package]

  Description        []

  SideEffects        []

  SeeAlso            [wff_pkg_init]

******************************************************************************/

	\end{verbatimtab}
	
	\subsection{main.c}
		
	\texttt{int main(int argc, char ** argv)}
	\begin{verbatimtab}
		
/**Function********************************************************************

  Synopsis    [required]

  Description [optional]

  SideEffects [required]

  SeeAlso     [optional]

******************************************************************************/

	\end{verbatimtab}
	
		
\end{document}
	