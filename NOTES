PyNuSMV is a Python interface to NuSMV, allowing to use NuSMV as a Python library. It is composed of several classes representing NuSMV data structures that provide functionalities.

This document describes PyNuSMV. First, it presents the goals behind PyNuSMV, then it describes the architecture of the library and covers its limitations. Finally, it discusses some additional tools provided with PyNuSMV that illustrate the use of the library.



1. GOALS
--------------------------------------------------------------------------------

The main goal of PyNuSMV is to provide a Python interface for NuSMV functionalities. This interface can be used as a library of functions on models, BDDs, and other data structures of NuSMV.

One subgoal is to provide all the functionalities of NuSMV at the Python level, e.g. calling the bdd_and function on two bdd_ptrs. This is achieved by using SWIG [SWIG], a wrapper generator, to generate a wrapper for every function of NuSMV. Thanks to this wrapper, there is no restriction to calling NuSMV functions and using its data structures. On the other hand, no barriers are given to forbid malicious or erroneous behaviors.

Another subgoal is to provide a Python-like library to access the main data structures and functions of NuSMV: FSM, BDD, parser, model checking algorithms, simulation, etc. For example, providing a class BDD with a built-in operator &, such that bdd1 & bdd2 computes bdd_and(bdd1, bdd2). This library would contain the error mechanisms required to ensure the correct usage of NuSMV.

In summary, PyNuSMV has two goals: (i) providing a complete Python interface for NuSMV functions and data structures, and (ii) providing a Python-like interface to some major data structures and functionalities.



2. ARCHITECTURE
--------------------------------------------------------------------------------

PyNuSMV is composed of three main layers. The first layer is NuSMV. The second layer is called the lower interface; it contains all the functionalities of NuSMV, at Python level, generated by SWIG. The third layer is called the upper interface; it contains the Python-like functionalities built upon the lower interface.

       _________________________________________________________     _
      |                                             |           |     |
      |     FSM,  BDD,  ...                         |           |     |
      |                             Upper interface |           |     | Python
      |_____________________________________________|           |     |
      |                                         Lower interface |     |
      |_________________________________________________________|    _|
      |                                                         |     |
      |                                                   NuSMV |     | C
      |_________________________________________________________|    _|
      
      
2.1. NuSMV
     -----
     
The version of NuSMV used in PyNuSMV is the version 2.5.4. NuSMV code has been kept unchanged, except for very small details:

- some functions and macro declarations have been commented because they are defined twice;
- some static keywords have been removed to allow exporting the functions;
- in the src/cmd/cmdMisc.c file, at line 170, the nusmv_assert checking that start_time is -1 has been commented. With this check, it is impossible to initialize, deinitialize and reinitialize NuSMV.

All these changes can be found by searching the string "sbusard" in NuSMV sources.
    
    
2.2. LOWER INTERFACE
     ---------------

The lower interface is composed of a set Python modules generated by SWIG. For every NuSMV package, i.e. for every directory in the src/ directory of NuSMV, there is a SWIG interface and a Python module that provide wrappers for functions and data structures of the package. This section briefly discusses the structure and content of the lower interface and presents its limitations.
     
     
2.2.1. STRUCTURE

The structure of the lower interface is a copy of the one of NuSMV. Let's consider as a NuSMV package any sub-directory of the src/ directory of NuSMV sources. For example, NuSMV contains the mc/ package, or the fsm/bdd/ package. The structure of the lower interface is the same, at Python level. The lower interface is located in the pynusmv.nusmv Python package. Every NuSMV package gets its PyNuSMV package. For example, the prop/ NuSMV package is wrapped into the pynusmv.nusmv.prop Python package; the compile/symb_table/ NuSMV package is wrapped into the pynusmv.nusmv.compile.symb_table package.

Furthermore, every wrapped function is automatically documented by SWIG with the corresponding C function signature. It allows the developper to know what types of arguments the wrapped function takes.


2.2.2. CONTENT

The goal of the lower interface is to provide a wrapper for every function of NuSMV. In practice, for every package, only the set of functions that are considered as public are provided. This means that, for every package, all the headers are exported, except the ones with a name ending with Int.h, _int.h or _private.h.

        
2.2.3. LIMITATIONS

The lower interface has some limitations. First, it does not wrap all the functions, but only the ones present in the public headers, as described in the previous section.

Furthermore, there a some other exceptions:
- no SAT solver is included with the used NuSMV; the sat/solvers/ NuSMV package is not wrapped.
- the utils/lsort.h header is not wrapped because SWIG is not able to process it.
- A set of functions, from different packages, are not wrapped because they have no implementation.
    
    
2.3. UPPER INTERFACE
     ---------------
     
The upper interface is composed of Python classes representing data structures of NuSMV as well as additional modules giving access to main functionalities that do not belong to a data structure, like CTL model checking. Each instance of these classes contains a pointer to the corresponding NuSMV data structure and provides a set of methods on this pointer.

This section explains the way all pointers to data structures are defined, how the memory is managed and lists the classes and modules currently defined.

    
2.3.1. POINTERWRAPPER

Every pointer to a NuSMV data structure is wrapped into a Python class that is a subclass of the PointerWrapper class (found in the pynusmv.utils.pointerwrapper module). This class only contains a _ptr attribute (the wrapped pointer) and implements the __del__ destructor. All the other functionalities are left to subclasses.

        
2.3.2. GARBAGE COLLECTION

In PyNuSMV, we distinguish two types of pointers to NuSMV data structures: the pointers that have to be freed and the ones that do not. For example, a pointer to a BDD has to be freed after usage (with bdd_free) while a pointer to the main FSM do not, because NuSMV frees it when deinitiliasing. 

In addition to the wrapped pointer, the PointerWrapper class contains a flag called _freeit that tells whether the pointer has to be freed when destroying the wrapper. If needed, the destructor calls the _free method, that does the work. The _free method of PointerWrapper class does nothing. It is the responsibility of subclasses to reimplement this _free method if the pointer has to be freed. In fact, PointerWrapper cannot say how to free the pointer since the free() NuSMV function to call depends on the wrapped pointer (BDDs have to be freed with bdd_free, other pointers do not).

Furthermore, we define the following conventions:
- wrappers containing pointers that do not have to be freed do not have to reimplement the _free method.
- pointers that do not have to be freed can be shared between any number of wrappers. Since these pointers are not freed, it is not a problem.
- wrappers containing pointers that have to be freed must reimplement the _free method to free the pointer when needed.
- there must exist one and only one wrapper for any pointer that has to be freed. This ensures that the pointer will be freed only once.
- if no wrapper is created to wrap a pointer, it is the responsibility of the one who got the pointer to free it.

Thanks to these conventions, it is possible to manage the memory and to free it when needed.


Thanks to the specific _free method implementations, pointers can be correctly freed when the wrapper is destroyed by Python. But pointers cannot be freed after deinitializing NuSMV. So we need a way to free every pointer before deinitializing NuSMV.

To achieve this garbage collection, PyNuSMV comes with a specific module pynusmv.init.init that allows to initialize and deinitialize NuSMV, with the init_nusmv and deinit_nusmv functions. Before using PyNuSMV, init_nusmv() must be called; after using PyNuSMV, it is necessary to deinitializing NuSMV by calling deinit_nusmv(). Furthermore, init_nusmv creates a new list in which every newly created PointerWrapper (or subclass of it) is registered. When deinit_nusmv is called, all the wrappers of the list are freed before deinitializing NuSMV. This ensures that all pointers are freed before deinitializing NuSMV.

        
2.3.3. CLASSES AND MODULES

This section lists the classes and modules of PyNuSMV, with a brief description.

- the pynusmv.dd package contains all the BDD-related classes. First, the BDD class represents a generic BDD. It implements all the BDD operations using built-in operators, e.g. b1 & b2 computes bdd_and(b1, b2). Furthermore, there is a class for a State, i.e. a BDD representing a single state of an FSM; the Inputs class represents a single input, i.e. values of the IVARs of the model. Finally, the BDDList class represents a node-based BDD list.

- the pynusmv.enc and pynusmv.fsm packages contain classes for BDD encoding and BDD FSM, respectivement. Only basic functionalities are currently implemented like getting symbols table or DD manager from BDD encoding, or getting initial states or computing post- or pre-images from FSM.

- the pynusmv.init provides the functions to initialize and deinitialize NuSMV. It has been discussed in previous section.

- the pynusmv.mc package provides some high-level model checking functionalities like CTL model checking and temporal operators explaining functions.

- the pynusmv.prop package contains a class Prop representing a property of NuSMV, and a class PropDb representing a property database.

- the pynusmv.spec package contains the Spec class. A Spec is a specification defined with nodes; in addition to the class, the pynusmv.spec.spec module implements functions to create new specifications.

- the pynusmv.utils package contains, for now, the PointerWrapper class, described in the previous section.        


        
3. LIMITATIONS
--------------------------------------------------------------------------------

PyNuSMV has some limitations. Two major ones of them are the exposed functionalities and error management.


3.1. EXPOSED FUNCTIONALITIES
     -----------------------
     
Since the upper interface of PyNuSMV is written by hand, it needs some work to implement its functionalities (compared to the lower interface that is generated with SWIG). The number of exposed functionalities is so relatively small for now. For example, nothing has been made to expose SAT-based functionalities like BMC, or LTL model checking and trace generation, simulation and management.


3.2. ERROR MANAGEMENT
     ----------------

NuSMV can react in various ways when an error occurs. It can output a message at stderr and returns an error flag, e.g. when executing a command. It also integrates a try/fail mechanism using lonjmp functionalities. And it can also abruptly exit everything using the exit() function.

For now, there is no (or very little) error management in PyNuSMV. If something is missused, right behaviour cannot be ensured and it can lead to segmentation faults. It is still a huge part of PyNuSMV development to implement error mechanisms and to port them to Python.



4. TOOLS
--------------------------------------------------------------------------------

PyNuSMV is distributed with some tools developed thanks to the library. These tools serve as examples of how to use PyNuSMV and what can be achieved. This section describes the two tools currently distributed with PyNuSMV.


4.1. TLACE
     -----
     
Tree-Like Annotated Counter-Examples (TLACEs for short) are rich branching counter-examples [BP12]. This tool extends NuSMV explanations to produce these rich counter-examples instead of single paths. It uses NuSMV model checking algorithms and path explanation generators (ex_explain, eg_explain, eu_explain), and also parser for CTL formulas, etc. The result is a tool taking an SMV model as argument, checking all CTL properties of the model and producing TLACEs when the property is violated.

    
4.2. ARCTL + TLACE
     -------------
     
Action-Restricted CTL (ARCTL for short) is an extension of CTL where quantified paths are restricted to paths of actions satisfying some propositional properties [PR06]. This tool performs ARCTL model checking on SMV models and produces TLACEs to explain ARCTL properties violation or satisfaction.
  
    
    
REFERENCES
--------------------------------------------------------------------------------

[SWIG] SWIG - Simplified Wrapper and Interface Generator -- http://www.swig.org
[BP12] Simon Busard, Charles Pecheur: Rich Counter-Examples for Temporal-Epistemic Logic Model Checking. IWIGP 2012: 39-53
[PR06] Charles Pecheur, Franco Raimondi: Symbolic Model Checking of Logics with Actions. MoChArt 2006: 113-128